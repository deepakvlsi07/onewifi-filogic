Date: Dec 30, 2023
From: acb7b0ec69f26a7df10af3992359890b09f076e8
Subject: Patch glib-2.0 to address CVE-2021-27218
Source:  gnome.org https://gitlab.gnome.org/GNOME/glib/-/merge_requests/1942/diffs?commit_id=acb7b0ec69f26a7df10af3992359890b09f076e8
License:
Upstream-Status: Pending
Signed-off-by: kmarim851 <Kalidoss_Marimuthu@comcast.com>
---
Index: glib-2.62.4/glib/garray.c
===================================================================
--- glib-2.62.4.orig/glib/garray.c
+++ glib-2.62.4/glib/garray.c
@@ -2010,6 +2010,10 @@ g_byte_array_new (void)
  * Create byte array containing the data. The data will be owned by the array
  * and will be freed with g_free(), i.e. it could be allocated using g_strdup().
  *
+ * Do not use it if @len is greater than %G_MAXUINT. #GByteArray
+ * stores the length of its data in #guint, which may be shorter than
+ * #gsize.
+ *
  * Since: 2.32
  *
  * Returns: (transfer full): a new #GByteArray
@@ -2021,6 +2025,8 @@ g_byte_array_new_take (guint8 *data,
   GByteArray *array;
   GRealArray *real;
 
+  g_return_val_if_fail (len <= G_MAXUINT, NULL);
+
   array = g_byte_array_new ();
   real = (GRealArray *)array;
   g_assert (real->data == NULL);
Index: glib-2.62.4/glib/gbytes.c
===================================================================
--- glib-2.62.4.orig/glib/gbytes.c
+++ glib-2.62.4/glib/gbytes.c
@@ -519,6 +519,10 @@ g_bytes_unref_to_data (GBytes *bytes,
  * g_bytes_new(), g_bytes_new_take() or g_byte_array_free_to_bytes(). In all
  * other cases the data is copied.
  *
+ * Do not use it if @bytes contains more than %G_MAXUINT
+ * bytes. #GByteArray stores the length of its data in #guint, which
+ * may be shorter than #gsize, that @bytes is using.
+ *
  * Returns: (transfer full): a new mutable #GByteArray containing the same byte data
  *
  * Since: 2.32
Index: glib-2.62.4/glib/tests/bytes.c
===================================================================
--- glib-2.62.4.orig/glib/tests/bytes.c
+++ glib-2.62.4/glib/tests/bytes.c
@@ -10,7 +10,6 @@
  */
 
 #undef G_DISABLE_ASSERT
-#undef G_LOG_DOMAIN
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -334,6 +333,38 @@ test_to_array_transferred (void)
 }
 
 static void
+test_to_array_transferred_oversize (void)
+{
+  g_test_message ("g_bytes_unref_to_array() can only take GBytes up to "
+                  "G_MAXUINT in length; test that longer ones are rejected");
+
+  if (sizeof (guint) >= sizeof (gsize))
+    {
+      g_test_skip ("Skipping test as guint is not smaller than gsize");
+    }
+  else if (g_test_undefined ())
+    {
+      GByteArray *array = NULL;
+      GBytes *bytes = NULL;
+      gpointer data = g_memdup2 (NYAN, N_NYAN);
+      gsize len = ((gsize) G_MAXUINT) + 1;
+
+      bytes = g_bytes_new_take (data, len);
+      g_test_expect_message (G_LOG_DOMAIN, G_LOG_LEVEL_CRITICAL,
+                             "g_byte_array_new_take: assertion 'len <= G_MAXUINT' failed");
+      array = g_bytes_unref_to_array (g_steal_pointer (&bytes));
+      g_test_assert_expected_messages ();
+      g_assert_null (array);
+
+      g_free (data);
+    }
+  else
+    {
+      g_test_skip ("Skipping test as testing undefined behaviour is disabled");
+    }
+}
+
+static void
 test_to_array_two_refs (void)
 {
   gconstpointer memory;
@@ -405,6 +436,7 @@ main (int argc, char *argv[])
   g_test_add_func ("/bytes/equal", test_equal);
   g_test_add_func ("/bytes/compare", test_compare);
   g_test_add_func ("/bytes/to-data/transfered", test_to_data_transferred);
+  g_test_add_func ("/bytes/to-array/transferred/oversize", test_to_array_transferred_oversize);
   g_test_add_func ("/bytes/to-data/two-refs", test_to_data_two_refs);
   g_test_add_func ("/bytes/to-data/non-malloc", test_to_data_non_malloc);
   g_test_add_func ("/bytes/to-array/transfered", test_to_array_transferred);
