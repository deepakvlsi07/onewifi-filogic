Source: Backport from later version of opensync

Index: device-core/src/lib/osw/inc/osw.h
===================================================================
--- /dev/null
+++ device-core/src/lib/osw/inc/osw.h
@@ -0,0 +1,7 @@
+#ifndef OSW_H
+#define OSW_H
+
+void
+osw_init(void);
+
+#endif /* OSW_H */
Index: device-core/src/lib/osw/inc/osw_conf.h
===================================================================
--- /dev/null
+++ device-core/src/lib/osw/inc/osw_conf.h
@@ -0,0 +1,134 @@
+#ifndef OSW_CONF_H
+#define OSW_CONF_H
+
+#include <osw_types.h>
+#include <ds_dlist.h>
+#include <ds_tree.h>
+
+struct osw_conf;
+struct osw_conf_phy;
+
+struct osw_conf_acl {
+    struct ds_tree_node node;
+    struct osw_hwaddr mac_addr;
+};
+
+struct osw_conf_psk {
+    struct ds_tree_node node;
+    struct osw_ap_psk ap_psk;
+};
+
+struct osw_conf_vif_ap {
+    enum osw_acl_policy acl_policy;
+    struct osw_ssid ssid;
+    struct osw_channel channel;
+    struct osw_ifname bridge_if_name;
+    struct osw_wpa wpa;
+    struct ds_tree acl_tree; /* osw_conf_acl */
+    struct ds_tree psk_tree; /* osw_conf_psk */
+    struct osw_ap_mode mode;
+    int beacon_interval_tu;
+    bool ssid_hidden;
+    bool isolated;
+    bool mcast2ucast;
+};
+
+struct osw_conf_vif_sta {
+    /* TODO */
+};
+
+struct osw_conf_vif {
+    struct ds_tree_node phy_node;
+    struct osw_conf_phy *phy;
+    char *vif_name;
+    bool enabled;
+    enum osw_vif_type vif_type;
+    union {
+        struct osw_conf_vif_ap ap;
+        struct osw_conf_vif_sta sta;
+    } u;
+};
+
+struct osw_conf_phy {
+    struct ds_tree_node conf_node;
+    struct osw_conf *conf;
+    char *phy_name;
+    bool enabled;
+    int tx_chainmask;
+    enum osw_radar_detect radar;
+    struct ds_tree vif_tree;
+};
+
+struct osw_conf {
+    struct ds_tree phy_tree;
+};
+
+struct osw_conf_mutator;
+struct osw_conf_observer;
+
+typedef void osw_conf_mutate_fn_t(struct osw_conf_mutator *mutator,
+                                  struct osw_conf *conf);
+
+typedef void osw_conf_backup_fn_t(struct osw_conf_mutator *mutator);
+
+typedef void osw_conf_rollback_fn_t(struct osw_conf_mutator *mutator);
+
+typedef void osw_conf_mutated_fn_t(struct osw_conf_observer *observer);
+
+enum osw_conf_type {
+    OSW_CONF_TAIL,
+    OSW_CONF_HEAD,
+};
+
+struct osw_conf_mutator {
+    struct ds_dlist_node node;
+    const char *name;
+    const enum osw_conf_type type;
+    osw_conf_mutate_fn_t *const mutate_fn;
+    osw_conf_backup_fn_t *const backup_fn;
+    osw_conf_rollback_fn_t *const rollback_fn;
+};
+
+struct osw_conf_observer {
+    struct ds_dlist_node node;
+    const char *name;
+    osw_conf_mutated_fn_t *const mutated_fn;
+};
+
+void
+osw_conf_register_mutator(struct osw_conf_mutator *mutator);
+
+void
+osw_conf_register_observer(struct osw_conf_observer *observer);
+
+struct osw_conf *
+osw_conf_build_from_state(void);
+
+struct osw_conf *
+osw_conf_build(void);
+
+void
+osw_conf_free(struct osw_conf *conf);
+
+void
+osw_conf_invalidate(struct osw_conf_mutator *mutator);
+
+void
+osw_conf_backup(void);
+
+void
+osw_conf_rollback(void);
+
+bool
+osw_conf_ap_psk_tree_changed(struct ds_tree *a, struct ds_tree *b);
+
+bool
+osw_conf_ap_acl_tree_changed(struct ds_tree *a, struct ds_tree *b);
+
+void
+osw_conf_ap_psk_tree_to_str(char *out, size_t len, const struct ds_tree *a);
+
+void
+osw_conf_ap_acl_tree_to_str(char *out, size_t len, const struct ds_tree *a);
+
+#endif /* OSW_CONF_H */
Index: device-core/src/lib/osw/inc/osw_confsync.h
===================================================================
--- /dev/null
+++ device-core/src/lib/osw/inc/osw_confsync.h
@@ -0,0 +1,51 @@
+#ifndef OSW_CONFSYNC_H
+#define OSW_CONFSYNC_H
+
+#include <ev.h>
+#include <osw_conf.h>
+#include <osw_state.h>
+
+#define OSW_CONFSYNC_RETRY_SECONDS_DEFAULT 30.0
+
+struct osw_confsync;
+
+typedef void osw_confsync_agitated_fn_t(struct osw_confsync *cs);
+typedef void osw_confsync_settled_fn_t(struct osw_confsync *cs);
+typedef void osw_confsync_idle_fn_t(struct osw_confsync *cs);
+typedef void osw_confsync_busy_fn_t(struct osw_confsync *cs);
+
+struct osw_confsync {
+    /* public */
+    osw_confsync_agitated_fn_t *const agitated_fn;
+    osw_confsync_settled_fn_t *const settled_fn;
+    osw_confsync_idle_fn_t *const idle_fn;
+    osw_confsync_busy_fn_t *const busy_fn;
+    int retry_seconds;
+
+    /* private */
+    struct osw_conf *conf;
+    struct osw_conf *state;
+    struct osw_state_observer obs;
+    ev_timer work;
+    ev_timer retry;
+    bool forced;
+    bool settled;
+    bool idle;
+};
+
+void
+osw_confsync_init(struct osw_confsync *cs);
+
+void
+osw_confsync_fini(struct osw_confsync *cs);
+
+void
+osw_confsync_set(struct osw_confsync *cs,
+                 struct osw_conf *conf,
+                 struct osw_conf *state,
+                  bool force);
+
+bool
+osw_confsync_is_settled(struct osw_confsync *cs);
+
+#endif /* OSW_CONFSYNC_H */
Index: device-core/src/lib/osw/inc/osw_drv.h
===================================================================
--- /dev/null
+++ device-core/src/lib/osw/inc/osw_drv.h
@@ -0,0 +1,391 @@
+#ifndef OSW_DRV_H
+#define OSW_DRV_H
+
+#include <osw_types.h>
+#include <module.h>
+
+struct osw_drv;
+
+struct osw_drv_vif_config_ap {
+    struct osw_ifname bridge_if_name;
+    bool bridge_if_name_changed;
+
+    int beacon_interval_tu;
+    bool beacon_interval_tu_changed;
+
+    struct osw_channel channel;
+    bool channel_changed;
+    bool csa_required;
+
+    bool isolated;
+    bool isolated_changed;
+
+    bool ssid_hidden;
+    bool ssid_hidden_changed;
+
+    bool mcast2ucast;
+    bool mcast2ucast_changed;
+
+    struct osw_ap_mode mode;
+    bool mode_changed;
+
+    enum osw_acl_policy acl_policy;
+    bool acl_policy_changed;
+
+    struct osw_ssid ssid;
+    bool ssid_changed;
+
+    struct osw_hwaddr_list acl;
+    bool acl_changed;
+
+    struct osw_wpa wpa;
+    bool wpa_changed;
+
+    struct osw_ap_psk_list psk_list;
+    bool psk_list_changed;
+
+    struct osw_radius_list radius_list;
+    bool radius_list_changed;
+};
+
+struct osw_drv_vif_config_sta {
+    /* TBD */
+};
+
+struct osw_drv_vif_config {
+    char *vif_name;
+    bool changed;
+
+    enum osw_vif_type vif_type;
+    bool vif_type_changed;
+
+    bool enabled;
+    bool enabled_changed;
+
+    union {
+        struct osw_drv_vif_config_ap ap;
+        struct osw_drv_vif_config_sta sta;
+        /* ap_vlan configuration not supported for now */
+    } u;
+};
+
+struct osw_drv_vif_config_list {
+    struct osw_drv_vif_config *list;
+    size_t count;
+};
+
+struct osw_drv_vif_state_ap {
+    bool isolated;
+    bool ssid_hidden;
+    bool mcast2ucast;
+    int beacon_interval_tu;
+    struct osw_ifname bridge_if_name;
+    struct osw_ap_mode mode;
+    struct osw_channel channel;
+    struct osw_ssid ssid;
+    struct osw_hwaddr_list acl;
+    enum osw_acl_policy acl_policy;
+    struct osw_wpa wpa;
+    struct osw_ap_psk_list psk_list;
+    struct osw_radius_list radius_list;
+};
+
+struct osw_drv_vif_state_ap_vlan {
+    /* TBD */
+};
+
+struct osw_drv_vif_state_sta_link {
+    /* TBD */
+};
+
+struct osw_drv_vif_state_sta {
+    struct osw_drv_vif_state_sta_link link;
+    /* TBD */
+};
+
+struct osw_drv_vif_state {
+    bool exists;
+    bool enabled;
+    enum osw_vif_type vif_type;
+    struct osw_hwaddr mac_addr;
+
+    union {
+        struct osw_drv_vif_state_ap ap;
+        struct osw_drv_vif_state_ap_vlan ap_vlan;
+        struct osw_drv_vif_state_sta sta;
+    } u;
+};
+
+struct osw_drv_phy_config {
+    char *phy_name;
+    bool changed;
+
+    bool enabled;
+    bool enabled_changed;
+
+    int tx_chainmask;
+    bool tx_chainmask_changed;
+
+    enum osw_radar_detect radar;
+    bool radar_changed;
+
+    struct osw_drv_vif_config_list vif_list;
+};
+
+struct osw_drv_phy_state {
+    struct osw_channel_state *channel_states;
+    size_t n_channel_states;
+    struct osw_hwaddr mac_addr;
+    bool exists;
+    bool enabled;
+    int tx_chainmask;
+    enum osw_radar_detect radar;
+};
+
+struct osw_drv_sta_state {
+    int key_id;
+    int connected_duration_seconds;
+    bool connected;
+};
+
+struct osw_drv_conf {
+    struct osw_drv_phy_config *phy_list;
+    size_t n_phy_list;
+};
+
+typedef void
+osw_drv_report_phy_fn_t(const char *phy_name,
+                        void *fn_priv);
+
+typedef void
+osw_drv_report_vif_fn_t(const char *vif_name,
+                        void *fn_priv);
+
+typedef void
+osw_drv_report_sta_fn_t(const struct osw_hwaddr *mac_addr,
+                        void *fn_priv);
+
+typedef void
+osw_drv_init_fn_t(struct osw_drv *drv);
+
+typedef void
+osw_drv_get_phy_list_fn_t(struct osw_drv *drv,
+                          osw_drv_report_phy_fn_t *report_phy_fn,
+                          void *fn_priv);
+
+typedef void
+osw_drv_get_vif_list_fn_t(struct osw_drv *drv,
+                          const char *phy_name,
+                          osw_drv_report_vif_fn_t *report_vif_fn,
+                          void *fn_priv);
+
+typedef void
+osw_drv_get_sta_list_fn_t(struct osw_drv *drv,
+                          const char *phy_name,
+                          const char *vif_name,
+                          osw_drv_report_sta_fn_t *report_sta_fn,
+                          void *fn_priv);
+
+typedef void 
+osw_drv_request_phy_state_fn_t(struct osw_drv *drv,
+                               const char *phy_name);
+
+typedef void
+osw_drv_request_vif_state_fn_t(struct osw_drv *drv,
+                               const char *phy_name,
+                               const char *vif_name);
+
+typedef void
+osw_drv_request_sta_state_fn_t(struct osw_drv *drv,
+                               const char *phy_name,
+                               const char *vif_name,
+                               const struct osw_hwaddr *mac_addr);
+
+typedef void
+osw_drv_request_config_fn_t(struct osw_drv *drv,
+                            struct osw_drv_conf *conf);
+
+typedef void
+osw_drv_request_wps_pbc_fn_t(struct osw_drv *drv);
+
+typedef void
+osw_drv_request_sta_deauth_fn_t(struct osw_drv *drv,
+                                const char *phy_name,
+                                const char *vif_name,
+                                const struct osw_hwaddr *mac_addr,
+                                int dot11_reason_code);
+
+struct osw_drv_ops {
+    const char *name;
+    osw_drv_init_fn_t *init_fn;
+    osw_drv_get_phy_list_fn_t *get_phy_list_fn;
+    osw_drv_get_vif_list_fn_t *get_vif_list_fn;
+    osw_drv_get_sta_list_fn_t *get_sta_list_fn;
+    osw_drv_request_phy_state_fn_t *request_phy_state_fn;
+    osw_drv_request_vif_state_fn_t *request_vif_state_fn;
+    osw_drv_request_sta_state_fn_t *request_sta_state_fn;
+    osw_drv_request_sta_deauth_fn_t *request_sta_deauth_fn;
+    osw_drv_request_wps_pbc_fn_t *request_wps_pbc_fn;
+    osw_drv_request_config_fn_t *request_config_fn;
+
+    /* TODO
+    request_vif_deauth_fn_t
+    request_dpp_auth_fn_t
+    request_dpp_auth_stop_fn_t
+    request_dpp_chirp_fn_t
+    request_dpp_chirp_stop_fn_t
+    request_scan_fn_t
+    request_stats_survey_fn_t
+    request_stats_sta_fn_t
+    request_send_action_frame_fn_t
+    */
+};
+
+struct osw_drv_report_sta_probe_req_arg {
+    unsigned int snr;
+    bool ssid_present;
+};
+
+struct osw_drv_report_sta_auth_fail_arg {
+    unsigned int snr;
+};
+
+struct osw_drv_report_sta_action_frame_arg {
+    const void *action_frame;
+    size_t action_frame_len;
+};
+
+void
+osw_drv_register_ops(const struct osw_drv_ops *ops);
+
+void
+osw_drv_unregister_ops(const struct osw_drv_ops *ops);
+
+void
+osw_drv_set_priv(struct osw_drv *drv, void *priv);
+
+void *
+osw_drv_get_priv(struct osw_drv *drv);
+
+const struct osw_drv_ops *
+osw_drv_get_ops(struct osw_drv *drv);
+
+void
+osw_drv_report_config_failed(struct osw_drv *drv,
+                             const char *msg);
+
+void
+osw_drv_report_phy_changed(struct osw_drv *drv,
+                           const char *phy_name);
+
+void
+osw_drv_report_phy_state(struct osw_drv *drv,
+                         const char *phy_name,
+                         const struct osw_drv_phy_state *state);
+
+void
+osw_drv_report_vif_changed(struct osw_drv *drv,
+                           const char *phy_name,
+                           const char *vif_name);
+
+void
+osw_drv_report_vif_state(struct osw_drv *drv,
+                         const char *phy_name,
+                         const char *vif_name,
+                         const struct osw_drv_vif_state *state);
+
+void
+osw_drv_report_vif_channel_change_started(struct osw_drv *drv,
+                                          const char *phy_name,
+                                          const char *vif_name,
+                                          const struct osw_channel *target_channel);
+
+void
+osw_drv_report_sta_changed(struct osw_drv *drv,
+                           const char *phy_name,
+                           const char *vif_name,
+                           const struct osw_hwaddr *mac_addr);
+
+void
+osw_drv_report_sta_state(struct osw_drv *drv,
+                         const char *phy_name,
+                         const char *vif_name,
+                         const struct osw_hwaddr *mac_addr,
+                         const struct osw_drv_sta_state *state);
+
+void
+osw_drv_report_sta_connected(struct osw_drv *drv,
+                             const char *phy_name,
+                             const char *vif_name,
+                             const struct osw_hwaddr *mac_addr);
+
+void
+osw_drv_report_sta_disconnected(struct osw_drv *drv,
+                                const char *phy_name,
+                                const char *vif_name,
+                                const struct osw_hwaddr *mac_addr);
+
+void
+osw_drv_report_sta_probe_req(struct osw_drv *drv,
+                             const char *phy_name,
+                             const char *vif_name,
+                             const struct osw_hwaddr *mac_addr,
+                             const struct osw_drv_report_sta_probe_req_arg *arg);
+
+void
+osw_drv_report_sta_auth_fail(struct osw_drv *drv,
+                             const char *phy_name,
+                             const char *vif_name,
+                             const struct osw_hwaddr *mac_addr,
+                             const struct osw_drv_report_sta_auth_fail_arg *arg);
+
+void
+osw_drv_report_sta_action_frame(struct osw_drv *drv,
+                                const char *phy_name,
+                                const char *vif_name,
+                                const struct osw_hwaddr *mac_addr,
+                                const struct osw_drv_report_sta_action_frame_arg *arg);
+
+void
+osw_drv_conf_free(struct osw_drv_conf *conf);
+
+bool
+osw_drv_work_is_settled(void);
+
+/* TODO
+void osw_drv_report_sta_deauth_tx
+void osw_drv_report_sta_deauth_rx
+void osw_drv_report_sta_disassoc_rx
+void osw_drv_report_sta_disassoc_tx
+void osw_drv_report_sta_authenticate_rx
+void osw_drv_report_sta_authenticate_tx
+void osw_drv_report_sta_associate_rx
+void osw_drv_report_sta_associate_tx
+void osw_drv_report_sta_authorize
+void osw_drv_report_sta_deauthorize
+void osw_drv_report_sta_low_ack
+void osw_drv_report_sta_assoc_ies
+void osw_drv_report_phy_radar_detected
+void osw_drv_report_vif_channel_changed
+void osw_drv_report_vif_channel_change_started
+void osw_drv_report_vif_disconnected
+void osw_drv_report_vif_beacon_loss
+void osw_drv_report_stats_survey
+void osw_drv_report_stats_sta
+void osw_drv_report_scan_entry
+void osw_drv_report_scan_completed
+void osw_drv_report_wps_enrollee_handled
+void osw_drv_report_wps_pbc_stopped
+void osw_drv_report_dpp_enrollee_handled
+void osw_drv_report_dpp_auth_stopped
+void osw_drv_report_dpp_chirp_stopped
+void osw_drv_report_rx_probe_request
+void osw_drv_report_rx_action_frame
+*/
+
+#define OSW_DRV_DEFINE(ops) \
+    static void ops##module_start(void *data) { osw_drv_register_ops(&ops); } \
+    static void ops##module_stop(void *data) {} \
+    MODULE(ops##module, ops##module_start, ops##module_stop)
+
+#endif /* OSW_DRV_H */
Index: device-core/src/lib/osw/inc/osw_drv_dummy.h
===================================================================
--- /dev/null
+++ device-core/src/lib/osw/inc/osw_drv_dummy.h
@@ -0,0 +1,66 @@
+#ifndef OSW_DRV_DUMMY_H
+#define OSW_DRV_DUMMY_H
+
+#include <ds_tree.h>
+#include <ds_dlist.h>
+#include <osw_drv.h>
+
+struct osw_drv_dummy_phy;
+struct osw_drv_dummy_vif;
+struct osw_drv_dummy_sta;
+struct osw_drv_dummy;
+
+typedef void osw_drv_dummy_fini_phy_fn_t(struct osw_drv_dummy *dummy, struct osw_drv_phy_state *phy);
+typedef void osw_drv_dummy_fini_vif_fn_t(struct osw_drv_dummy *dummy, struct osw_drv_vif_state *vif);
+typedef void osw_drv_dummy_fini_sta_fn_t(struct osw_drv_dummy *dummy, struct osw_drv_sta_state *sta);
+typedef void osw_drv_dummy_iter_sta_fn_t(struct osw_drv_dummy *dummy,
+                                         const char *phy_name,
+                                         const char *vif_name,
+                                         const struct osw_hwaddr *sta_addr,
+                                         void *fn_data);
+
+struct osw_drv_dummy {
+    char name[32];
+    struct osw_drv_ops ops;
+    struct osw_drv *drv;
+    struct ds_tree phy_tree;
+    struct ds_tree vif_tree;
+    struct ds_dlist sta_list;
+    osw_drv_dummy_fini_phy_fn_t *const fini_phy_fn;
+    osw_drv_dummy_fini_vif_fn_t *const fini_vif_fn;
+    osw_drv_dummy_fini_sta_fn_t *const fini_sta_fn;
+    osw_drv_init_fn_t *const init_fn;
+    osw_drv_request_config_fn_t *const request_config_fn;
+};
+
+void
+osw_drv_dummy_init(struct osw_drv_dummy *dummy);
+
+void
+osw_drv_dummy_fini(struct osw_drv_dummy *dummy);
+
+void
+osw_drv_dummy_set_phy(struct osw_drv_dummy *dummy,
+                      const char *phy_name,
+                      struct osw_drv_phy_state *state);
+
+void
+osw_drv_dummy_set_vif(struct osw_drv_dummy *dummy,
+                      const char *phy_name,
+                      const char *vif_name,
+                      struct osw_drv_vif_state *state);
+
+void
+osw_drv_dummy_set_sta(struct osw_drv_dummy *dummy,
+                      const char *phy_name,
+                      const char *vif_name,
+                      const struct osw_hwaddr *sta_addr,
+                      struct osw_drv_sta_state *state);
+
+void
+osw_drv_dummy_iter_sta(struct osw_drv_dummy *dummy,
+                       osw_drv_dummy_iter_sta_fn_t *fn,
+                       void *fn_data);
+
+
+#endif /* OSW_DRV_DUMMY_H */
Index: device-core/src/lib/osw/inc/osw_mux.h
===================================================================
--- /dev/null
+++ device-core/src/lib/osw/inc/osw_mux.h
@@ -0,0 +1,13 @@
+#ifndef OSW_MUX_H
+#define OSW_MUX_H
+
+bool
+osw_mux_request_config(struct osw_drv_conf *conf);
+
+bool
+osw_mux_request_sta_deauth(const char *phy_name,
+                           const char *vif_name,
+                           const struct osw_hwaddr *mac_addr,
+                           int dot11_reason_code);
+
+#endif /* OSW_MUX_H */
Index: device-core/src/lib/osw/inc/osw_req.h
===================================================================
--- /dev/null
+++ device-core/src/lib/osw/inc/osw_req.h
@@ -0,0 +1,15 @@
+#ifndef OSW_REQ_H
+#define OSW_REQ_H
+
+#include <osw_conf.h>
+
+void
+osw_req_config(struct osw_conf *conf);
+
+void
+osw_req_sta_deauth(const char *phy_name,
+                   const char *vif_name,
+                   const struct osw_hwaddr *mac_addr,
+                   int dot11_reason);
+
+#endif /* OSW_REQ_H */
Index: device-core/src/lib/osw/inc/osw_state.h
===================================================================
--- /dev/null
+++ device-core/src/lib/osw/inc/osw_state.h
@@ -0,0 +1,172 @@
+#ifndef OSW_STATE_H
+#define OSW_STATE_H
+
+#include <osw_drv.h>
+#include <ds_dlist.h>
+
+struct osw_state_observer;
+
+struct osw_state_phy_info {
+    const char *phy_name;
+    const struct osw_drv_phy_state *drv_state;
+};
+
+struct osw_state_vif_info {
+    const char *vif_name;
+    const struct osw_state_phy_info *phy;
+    const struct osw_drv_vif_state *drv_state;
+};
+
+struct osw_state_sta_info {
+    const struct osw_hwaddr *mac_addr;
+    const struct osw_state_vif_info *vif;
+    const struct osw_drv_sta_state *drv_state;
+    time_t connected_at;
+    const void *assoc_req_ies;
+    size_t assoc_req_ies_len;
+};
+
+struct osw_state_sta_probe_req_arg {
+    unsigned int snr;
+    bool ssid_present;
+};
+
+struct osw_state_sta_auth_fail_arg {
+    unsigned int snr;
+};
+
+struct osw_state_sta_action_frame_arg {
+    const void *action_frame;
+    size_t action_frame_len;
+};
+
+typedef void
+osw_state_report_phy_fn_t(const struct osw_state_phy_info *info,
+                          void *priv);
+
+typedef void
+osw_state_report_vif_fn_t(const struct osw_state_vif_info *info,
+                          void *priv);
+
+typedef void
+osw_state_report_sta_fn_t(const struct osw_state_sta_info *info,
+                          void *priv);
+
+typedef void
+osw_state_idle_fn_t(struct osw_state_observer *self);
+
+typedef void
+osw_state_busy_fn_t(struct osw_state_observer *self);
+
+typedef void
+osw_state_phy_added_fn_t(struct osw_state_observer *self,
+                         const struct osw_state_phy_info *phy);
+
+typedef void
+osw_state_phy_removed_fn_t(struct osw_state_observer *self,
+                           const struct osw_state_phy_info *phy);
+
+typedef void
+osw_state_phy_changed_fn_t(struct osw_state_observer *self,
+                           const struct osw_state_phy_info *phy);
+
+typedef void
+osw_state_vif_added_fn_t(struct osw_state_observer *self,
+                         const struct osw_state_vif_info *vif);
+
+typedef void
+osw_state_vif_removed_fn_t(struct osw_state_observer *self,
+                           const struct osw_state_vif_info *vif);
+
+typedef void
+osw_state_vif_changed_fn_t(struct osw_state_observer *self,
+                           const struct osw_state_vif_info *vif);
+
+typedef void
+osw_state_sta_connected_fn_t(struct osw_state_observer *self,
+                             const struct osw_state_sta_info *sta);
+
+typedef void
+osw_state_sta_disconnected_fn_t(struct osw_state_observer *self,
+                                const struct osw_state_sta_info *sta);
+
+typedef void
+osw_state_sta_probe_req_fn_t(struct osw_state_observer *self,
+                             const struct osw_state_sta_info *sta,
+                             const struct osw_state_sta_probe_req_arg *arg);
+
+typedef void
+osw_state_sta_auth_fail_fn_t(struct osw_state_observer *self,
+                             const struct osw_state_sta_info *sta,
+                             const struct osw_state_sta_auth_fail_arg *arg);
+
+typedef void
+osw_state_sta_action_frame_fn_t(struct osw_state_observer *self,
+                                const struct osw_state_sta_info *sta,
+                                const struct osw_state_sta_action_frame_arg *arg);
+
+typedef void
+osw_state_sta_changed_fn_t(struct osw_state_observer *self,
+                           const struct osw_state_sta_info *sta);
+
+struct osw_state_observer {
+    struct ds_dlist_node node;
+    const char *const name;
+    osw_state_idle_fn_t *const idle_fn;
+    osw_state_busy_fn_t *const busy_fn;
+    osw_state_phy_added_fn_t *const phy_added_fn;
+    osw_state_phy_removed_fn_t *const phy_removed_fn;
+    osw_state_phy_changed_fn_t *const phy_changed_fn;
+    osw_state_vif_added_fn_t *const vif_added_fn;
+    osw_state_vif_removed_fn_t *const vif_removed_fn;
+    osw_state_vif_changed_fn_t *const vif_changed_fn;
+    osw_state_sta_connected_fn_t *const sta_connected_fn;
+    osw_state_sta_disconnected_fn_t *const sta_disconnected_fn;
+    osw_state_sta_probe_req_fn_t *const sta_probe_req_fn;
+    osw_state_sta_auth_fail_fn_t *const sta_auth_fail_fn;
+    osw_state_sta_action_frame_fn_t *const sta_action_frame_fn;
+    osw_state_sta_changed_fn_t *const sta_changed_fn;
+};
+
+void
+osw_state_register_observer(struct osw_state_observer *observer);
+
+void
+osw_state_unregister_observer(struct osw_state_observer *observer);
+
+const struct osw_state_phy_info *
+osw_state_phy_lookup(const char *phy_name);
+
+const struct osw_state_vif_info *
+osw_state_vif_lookup(const char *phy_name,
+                     const char *vif_name);
+
+const struct osw_state_sta_info *
+osw_state_sta_lookup(const char *phy_name,
+                     const char *vif_name,
+                     const struct osw_hwaddr *mac_addr);
+
+const struct osw_state_sta_info *
+osw_state_sta_lookup_newest(const struct osw_hwaddr *mac_addr);
+
+void
+osw_state_phy_get_list(osw_state_report_phy_fn_t fn,
+                       void *priv);
+
+void
+osw_state_vif_get_list(osw_state_report_vif_fn_t fn,
+                       const char *phy_name,
+                       void *priv);
+
+void
+osw_state_sta_get_list(osw_state_report_sta_fn_t fn,
+                       const char *phy_name,
+                       const char *vif_name,
+                       void *priv);
+
+#define OSW_STATE_DEFINE(obs) \
+    static void obs##module_start(void *data) { osw_state_register_observer(&obj); } \
+    static void obs##module_stop(void *data) { osw_state_unregister_observer(&obj); } \
+    MODULE(obs##module, obs##module_start, obs##module_stop)
+
+#endif /* OSW_STATE_H */
Index: device-core/src/lib/osw/inc/osw_thread.h
===================================================================
--- /dev/null
+++ device-core/src/lib/osw/inc/osw_thread.h
@@ -0,0 +1,10 @@
+#ifndef OSW_THREAD_H
+#define OSW_THREAD_H
+
+void
+osw_thread_init(void);
+
+void
+osw_thread_sanity_check(void);
+
+#endif /* OSW_THREAD_H */
Index: device-core/src/lib/osw/inc/osw_types.h
===================================================================
--- /dev/null
+++ device-core/src/lib/osw/inc/osw_types.h
@@ -0,0 +1,286 @@
+#ifndef OSW_TYPES_H
+#define OSW_TYPES_H
+
+#include <stdio.h>
+#include <stdbool.h>
+#include <stddef.h>
+#include <string.h>
+
+enum osw_vif_type {
+    OSW_VIF_UNDEFINED,
+    OSW_VIF_AP,
+    OSW_VIF_AP_VLAN,
+    OSW_VIF_STA,
+};
+
+enum osw_acl_policy {
+    OSW_ACL_NONE,
+    OSW_ACL_ALLOW_LIST,
+    OSW_ACL_DENY_LIST,
+};
+
+enum osw_channel_width {
+    OSW_CHANNEL_20MHZ,
+    OSW_CHANNEL_40MHZ,
+    OSW_CHANNEL_80MHZ,
+    OSW_CHANNEL_160MHZ,
+    OSW_CHANNEL_80P80MHZ,
+};
+
+enum osw_pmf {
+    OSW_PMF_DISABLED,
+    OSW_PMF_OPTIONAL,
+    OSW_PMF_REQUIRED,
+};
+
+enum osw_radar_detect {
+    OSW_RADAR_UNSUPPORTED,
+    OSW_RADAR_DETECT_ENABLED,
+    OSW_RADAR_DETECT_DISABLED,
+};
+
+enum osw_channel_state_dfs {
+    OSW_CHANNEL_NON_DFS,
+    OSW_CHANNEL_DFS_CAC_POSSIBLE,
+    OSW_CHANNEL_DFS_CAC_IN_PROGRESS,
+    OSW_CHANNEL_DFS_CAC_COMPLETED,
+    OSW_CHANNEL_DFS_NOL,
+};
+
+enum osw_band {
+    OSW_BAND_UNDEFINED,
+    OSW_BAND_2GHZ,
+    OSW_BAND_5GHZ,
+    OSW_BAND_6GHZ,
+};
+
+struct osw_channel {
+    enum osw_channel_width width;
+    int control_freq_mhz;
+    int center_freq0_mhz;
+    int center_freq1_mhz;
+};
+
+#define OSW_CHANNEL_FMT "%d (%s/%d)"
+#define OSW_CHANNEL_ARG(c) \
+    (c)->control_freq_mhz, \
+    osw_channel_width_to_str((c)->width), \
+    (c)->center_freq0_mhz
+
+struct osw_channel_state {
+    struct osw_channel channel;
+    enum osw_channel_state_dfs dfs_state;
+    int dfs_nol_remaining_seconds;
+};
+
+#define OSW_HWADDR_LEN 6
+#define OSW_HWADDR_FMT "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx"
+#define OSW_HWADDR_ARG(ptr) \
+    (ptr)->octet[0], \
+    (ptr)->octet[1], \
+    (ptr)->octet[2], \
+    (ptr)->octet[3], \
+    (ptr)->octet[4], \
+    (ptr)->octet[5]
+#define OSW_HWADDR_SARG(ptr) \
+    &(ptr)->octet[0], \
+    &(ptr)->octet[1], \
+    &(ptr)->octet[2], \
+    &(ptr)->octet[3], \
+    &(ptr)->octet[4], \
+    &(ptr)->octet[5]
+
+struct osw_hwaddr {
+    unsigned char octet[OSW_HWADDR_LEN];
+};
+
+struct osw_hwaddr_str {
+    char buf[18];
+};
+
+static inline char *
+osw_hwaddr2str(const struct osw_hwaddr *addr, struct osw_hwaddr_str *str)
+{
+    snprintf(str->buf, sizeof(str->buf), OSW_HWADDR_FMT, OSW_HWADDR_ARG(addr));
+    return str->buf;
+}
+
+#define OSW_IEEE80211_SSID_LEN 32
+
+struct osw_ifname {
+    char buf[16];
+};
+
+struct osw_ssid {
+    char buf[OSW_IEEE80211_SSID_LEN + sizeof('\0')];
+    size_t len;
+};
+
+#define OSW_SSID_FMT "%.*s (len=%zu)"
+#define OSW_SSID_ARG(x) (int)(x)->len, (x)->buf, (x)->len
+
+static inline int
+osw_ssid_cmp(const struct osw_ssid *a, const struct osw_ssid *b)
+{
+    struct osw_ssid x = *a;
+    struct osw_ssid y = *b;
+    x.buf[x.len] = 0;
+    y.buf[y.len] = 0;
+    return strcmp(x.buf, y.buf);
+}
+
+#define OSW_WPA_GROUP_REKEY_UNDEFINED -1
+
+struct osw_wpa {
+    bool wpa;
+    bool rsn;
+    bool akm_psk;
+    bool akm_sae;
+    bool akm_ft_psk;
+    bool akm_ft_sae;
+    bool pairwise_tkip;
+    bool pairwise_ccmp;
+    enum osw_pmf pmf;
+    int group_rekey_seconds;
+    int ft_mobility_domain;
+};
+
+enum osw_rate_legacy {
+    OSW_RATE_CCK_1_MBPS,
+    OSW_RATE_CCK_2_MBPS,
+    OSW_RATE_CCK_5_5_MBPS,
+    OSW_RATE_CCK_11_MBPS,
+
+    OSW_RATE_OFDM_6_MBPS,
+    OSW_RATE_OFDM_12_MBPS,
+    OSW_RATE_OFDM_18_MBPS,
+    OSW_RATE_OFDM_24_MBPS,
+    OSW_RATE_OFDM_36_MBPS,
+    OSW_RATE_OFDM_48_MBPS,
+    OSW_RATE_OFDM_54_MBPS,
+};
+
+struct osw_rateset_legacy {
+    enum osw_rate_legacy *rates;
+    size_t n_rates;
+};
+
+enum osw_beacon_rate_type {
+    OSW_RATE_BEACON_ABG,
+    OSW_RATE_BEACON_HT,
+    OSW_RATE_BEACON_VHT,
+    OSW_RATE_BEACON_HE,
+};
+
+struct osw_beacon_rate {
+    enum osw_beacon_rate_type type;
+    union {
+        enum osw_rate_legacy legacy;
+        int ht_mcs;
+        int vht_mcs;
+        int he_mcs;
+    } u;
+};
+
+struct osw_ap_mode {
+    struct osw_rateset_legacy supported_rates;
+    struct osw_rateset_legacy basic_rates;
+    struct osw_beacon_rate beacon_rate;
+    bool wnm_bss_trans;
+    bool rrm_neighbor_report;
+    bool wmm_enabled;
+    bool wmm_uapsd_enabled;
+    bool ht_enabled;
+    bool ht_required;
+    bool vht_enabled;
+    bool vht_required;
+    bool he_enabled;
+    bool he_required;
+    bool wps;
+};
+
+struct osw_psk {
+    char str[64 + 1]; /** 8-63 bytes: passphrase, 64 bytes: hex psk */
+};
+
+struct osw_ap_psk {
+    int key_id;
+    struct osw_psk psk;
+};
+
+struct osw_net {
+    struct osw_ssid ssid;
+    struct osw_wpa wpa;
+    struct osw_psk psk;
+};
+
+struct osw_radius {
+    char *server;
+    char *passphrase;
+    int port;
+};
+
+struct osw_hwaddr_list {
+    struct osw_hwaddr *list;
+    size_t count;
+};
+
+struct osw_ap_psk_list {
+    struct osw_ap_psk *list;
+    size_t count;
+};
+
+struct osw_radius_list {
+    struct osw_radius *list;
+    size_t count;
+};
+
+struct osw_net_list {
+    struct osw_net *list;
+    size_t count;
+};
+
+const char *
+osw_pmf_to_str(enum osw_pmf pmf);
+
+const char *
+osw_vif_type_to_str(enum osw_vif_type t);
+
+const char *
+osw_acl_policy_to_str(enum osw_acl_policy p);
+
+const char *
+osw_channel_width_to_str(enum osw_channel_width w);
+
+const char *
+osw_radar_to_str(enum osw_radar_detect r);
+
+void
+osw_wpa_to_str(char *out, size_t len, const struct osw_wpa *wpa);
+
+void
+osw_ap_mode_to_str(char *out, size_t len, const struct osw_ap_mode *mode);
+
+enum osw_band
+osw_freq_to_band(const int freq);
+
+int
+osw_freq_to_chan(const int freq);
+
+int
+osw_channel_width_to_mhz(const enum osw_channel_width w);
+
+const int *
+osw_channel_sidebands(enum osw_band band, int chan, int width, int max_2g_chan);
+
+int
+osw_chan_to_freq(enum osw_band band, int chan);
+
+void
+osw_channel_compute_center_freq(struct osw_channel *c, int max_2g_chan);
+
+int
+osw_hwaddr_cmp(const struct osw_hwaddr *addr_a,
+               const struct osw_hwaddr *addr_b);
+
+#endif /* OSW_TYPES_H */
Index: device-core/src/lib/osw/inc/osw_ut.h
===================================================================
--- /dev/null
+++ device-core/src/lib/osw/inc/osw_ut.h
@@ -0,0 +1,43 @@
+#ifndef OSW_UT_H
+#define OSW_UT_H
+
+#define OSW_UT_EVAL(cond) assert(cond)
+
+typedef void (*osw_ut_module_run_f) (void *data);
+
+#define osw_ut_register(name, fun, data) \
+    osw_ut_register_raw(name, __FILE__, #fun, fun, data)
+
+void
+osw_ut_register_raw(const char *name,
+                    const char *file_name,
+                    const char *fun_name,
+                    osw_ut_module_run_f fun,
+                    void *data);
+
+void
+osw_ut_run_by_prefix(const char *prefix, bool verbose);
+
+void
+osw_ut_run_all(bool verbose);
+
+#if 0
+// FIXME: Make kconfig configurable?
+static inline void
+osw_ut_register_raw(const char *name,
+                    const char *file_name,
+                    const char *fun_name,
+                    osw_ut_module_run_f fun,
+                    void *data)
+{
+    /* nop */
+}
+
+static inline void
+osw_ut_run_all(bool verbose)
+{
+    fprintf(stderr, "Binary compiled without unit tests, exiting\n");
+}
+#endif
+
+#endif /* OSW_UT_H */
Index: device-core/src/lib/osw/kconfig/Kconfig.libs
===================================================================
--- /dev/null
+++ device-core/src/lib/osw/kconfig/Kconfig.libs
@@ -0,0 +1,7 @@
+menu "OSW Configuration"
+    config OSW_UT
+        bool "Built unit tests"
+        default n
+        help
+            OSW unit tests
+endmenu
Index: device-core/src/lib/osw/src/osw.c
===================================================================
--- /dev/null
+++ device-core/src/lib/osw/src/osw.c
@@ -0,0 +1,7 @@
+#include "osw_drv_i.h"
+
+void
+osw_init(void)
+{
+    osw_drv_init();
+}
Index: device-core/src/lib/osw/src/osw_conf.c
===================================================================
--- /dev/null
+++ device-core/src/lib/osw/src/osw_conf.c
@@ -0,0 +1,449 @@
+#include <osw_conf.h>
+#include <ds_dlist.h>
+#include <log.h>
+#include <util.h>
+#include <memutil.h>
+#include <module.h>
+#include <const.h>
+#include <osw_state.h>
+#include <osw_ut.h>
+
+static struct ds_dlist g_osw_conf_mutator_list
+    = DS_DLIST_INIT(struct osw_conf_mutator, node);
+static struct ds_dlist g_osw_conf_observer_list
+    = DS_DLIST_INIT(struct osw_conf_observer, node);
+
+
+static int
+osw_conf_vif_acl_cmp(const void *a, const void *b)
+{
+    const struct osw_hwaddr *addr1 = a;
+    const struct osw_hwaddr *addr2 = b;
+    return memcmp(addr1, addr2, sizeof(*addr1));
+}
+
+static void
+osw_conf_build_vif_cb(const struct osw_state_vif_info *info,
+                      void *ptr)
+{
+    struct osw_conf_phy *phy = ptr;
+    struct osw_conf_vif *vif = CALLOC(1, sizeof(*vif));
+    size_t i;
+
+    assert(info != NULL);
+    assert(info->vif_name != NULL);
+    assert(info->phy != NULL);
+    assert(info->drv_state != NULL);
+
+    /* AP_VLAN interfaces aren't expected to be configurable for now. They are
+     * expected to be runtime artifacts spawned by the driver/system when
+     * a 4-addr client connects.
+     */
+    if (info->drv_state->vif_type == OSW_VIF_AP_VLAN) {
+        FREE(vif);
+        return;
+    }
+
+    vif->phy = phy;
+    vif->vif_name = STRDUP(info->vif_name);
+    vif->enabled = info->drv_state->enabled;
+    vif->vif_type = info->drv_state->vif_type;
+    switch (vif->vif_type) {
+        case OSW_VIF_UNDEFINED:
+            assert(0); /* driver bug, FIXME: dont use assert, be gentler and free memory */
+            break;
+        case OSW_VIF_AP:
+            ds_tree_init(&vif->u.ap.acl_tree, osw_conf_vif_acl_cmp, struct osw_conf_acl, node);
+            ds_tree_init(&vif->u.ap.psk_tree, ds_int_cmp, struct osw_conf_psk, node);
+            vif->u.ap.acl_policy = info->drv_state->u.ap.acl_policy;
+            vif->u.ap.ssid = info->drv_state->u.ap.ssid;
+            vif->u.ap.channel = info->drv_state->u.ap.channel;
+            vif->u.ap.mode = info->drv_state->u.ap.mode;
+            STRSCPY_WARN(vif->u.ap.bridge_if_name.buf, info->drv_state->u.ap.bridge_if_name.buf ?: "");
+            vif->u.ap.wpa = info->drv_state->u.ap.wpa;
+
+            for (i = 0; i < info->drv_state->u.ap.acl.count; i++) {
+                struct osw_conf_acl *acl = CALLOC(1, sizeof(*acl));
+                acl->mac_addr = info->drv_state->u.ap.acl.list[i];
+                ds_tree_insert(&vif->u.ap.acl_tree, acl, &acl->mac_addr);
+            }
+
+            for (i = 0; i < info->drv_state->u.ap.psk_list.count; i++) {
+                struct osw_conf_psk *psk = CALLOC(1, sizeof(*psk));
+                psk->ap_psk = info->drv_state->u.ap.psk_list.list[i];
+                ds_tree_insert(&vif->u.ap.psk_tree, psk, &psk->ap_psk.key_id);
+            }
+
+            vif->u.ap.beacon_interval_tu = info->drv_state->u.ap.beacon_interval_tu;
+            vif->u.ap.ssid_hidden = info->drv_state->u.ap.ssid_hidden;
+            vif->u.ap.isolated = info->drv_state->u.ap.isolated;
+            vif->u.ap.mcast2ucast = info->drv_state->u.ap.mcast2ucast;
+            // FIXME: radius_list
+            break;
+        case OSW_VIF_AP_VLAN:
+            assert(0); /* shouldn't reach here */
+            break;
+        case OSW_VIF_STA:
+            assert(0); /* TBD */
+            break;
+    }
+    ds_tree_insert(&phy->vif_tree, vif, vif->vif_name);
+}
+
+static void
+osw_conf_build_phy_cb(const struct osw_state_phy_info *info,
+                      void *ptr)
+{
+    struct osw_conf *conf = ptr;
+    struct osw_conf_phy *phy = CALLOC(1, sizeof(*phy));
+
+    assert(info != NULL);
+    assert(info->phy_name != NULL);
+    assert(info->drv_state != NULL);
+
+    phy->conf = conf;
+    phy->phy_name = STRDUP(info->phy_name);
+    phy->enabled = info->drv_state->enabled;
+    phy->tx_chainmask = info->drv_state->tx_chainmask;
+    phy->radar = info->drv_state->radar;
+    ds_tree_init(&phy->vif_tree, ds_str_cmp, struct osw_conf_vif, phy_node);
+    osw_state_vif_get_list(osw_conf_build_vif_cb, phy->phy_name, phy);
+    ds_tree_insert(&conf->phy_tree, phy, phy->phy_name);
+}
+
+struct osw_conf *
+osw_conf_build_from_state(void)
+{
+    struct osw_conf *conf = CALLOC(1, sizeof(*conf));
+    ds_tree_init(&conf->phy_tree, ds_str_cmp, struct osw_conf_phy, conf_node);
+    osw_state_phy_get_list(osw_conf_build_phy_cb, conf);
+    return conf;
+}
+
+struct osw_conf *
+osw_conf_build(void)
+{
+    struct osw_conf_mutator *i;
+    struct osw_conf *conf = osw_conf_build_from_state();
+
+    ds_dlist_foreach(&g_osw_conf_mutator_list, i)
+        i->mutate_fn(i, conf);
+
+    return conf;
+}
+
+static void
+osw_conf_free_vif_ap_acl(struct osw_conf_vif *vif,
+                         struct osw_conf_acl *acl)
+{
+    ds_tree_remove(&vif->u.ap.acl_tree, acl);
+    FREE(acl);
+}
+
+static void
+osw_conf_free_vif_ap_psk(struct osw_conf_vif *vif,
+                         struct osw_conf_psk *psk)
+{
+    ds_tree_remove(&vif->u.ap.psk_tree, psk);
+    FREE(psk);
+}
+
+static void
+osw_conf_free_vif(struct osw_conf_vif *vif)
+{
+    struct osw_conf_acl *acl;
+    struct osw_conf_psk *psk;
+
+    switch (vif->vif_type) {
+        case OSW_VIF_UNDEFINED:
+            break;
+        case OSW_VIF_AP:
+            while ((acl = ds_tree_head(&vif->u.ap.acl_tree)) != NULL)
+                osw_conf_free_vif_ap_acl(vif, acl);
+
+            while ((psk = ds_tree_head(&vif->u.ap.psk_tree)) != NULL)
+                osw_conf_free_vif_ap_psk(vif, psk);
+            break;
+        case OSW_VIF_AP_VLAN:
+            break;
+        case OSW_VIF_STA:
+            break;
+    }
+
+    ds_tree_remove(&vif->phy->vif_tree, vif);
+    FREE(vif->vif_name);
+    FREE(vif);
+}
+
+static void
+osw_conf_free_phy(struct osw_conf_phy *phy)
+{
+    struct osw_conf_vif *vif;
+    struct osw_conf_vif *tmp;
+
+    ds_tree_foreach_safe(&phy->vif_tree, vif, tmp)
+        osw_conf_free_vif(vif);
+
+    ds_tree_remove(&phy->conf->phy_tree, phy);
+    FREE(phy->phy_name);
+    FREE(phy);
+}
+
+void
+osw_conf_free(struct osw_conf *conf)
+{
+    struct osw_conf_phy *phy;
+    struct osw_conf_phy *tmp;
+
+    if (conf == NULL)
+        return;
+
+    ds_tree_foreach_safe(&conf->phy_tree, phy, tmp)
+        osw_conf_free_phy(phy);
+
+    FREE(conf);
+}
+
+void
+osw_conf_register_mutator(struct osw_conf_mutator *mutator)
+{
+    switch (mutator->type) {
+    case OSW_CONF_HEAD:
+        ds_dlist_insert_head(&g_osw_conf_mutator_list, mutator);
+        break;
+    case OSW_CONF_TAIL:
+        ds_dlist_insert_tail(&g_osw_conf_mutator_list, mutator);
+        break;
+    }
+}
+
+void
+osw_conf_register_observer(struct osw_conf_observer *observer)
+{
+    ds_dlist_insert_tail(&g_osw_conf_observer_list, observer);
+}
+
+void
+osw_conf_invalidate(struct osw_conf_mutator *mutator)
+{
+    struct osw_conf_observer *i;
+
+    /* TBD: The list of mutators is ordered. If a mutator
+     * expresses that it changed its mind it should be
+     * possible to re-use prior (unchanged) mutator outputs
+     * for performance.
+     *
+     * For now nothing is done. Only observers are notified
+     * so they can take action. Typically call the sequence
+     * of:
+     *   - osw_conf_build()
+     *   - osw_req_config()
+     *   - osw_conf_free()
+    */
+    ds_dlist_foreach(&g_osw_conf_observer_list, i)
+        i->mutated_fn(i);
+}
+
+void
+osw_conf_backup(void)
+{
+    struct osw_conf_mutator *i;
+
+    ds_dlist_foreach(&g_osw_conf_mutator_list, i)
+        if (i->backup_fn != NULL)
+            i->backup_fn(i);
+}
+
+void
+osw_conf_rollback(void)
+{
+    struct osw_conf_mutator *i;
+
+    /* TBD: This could be more complex. Typically one of
+     * many mutators in the sequence could be generating an
+     * issue with the configuration object. This could be
+     * bisected by applying a subset of mutators to find
+     * which one to rollback. That would however require a
+     * more involving implementation on mutators as well.
+     * For now this should be sufficient.
+     */
+    ds_dlist_foreach(&g_osw_conf_mutator_list, i)
+        if (i->rollback_fn != NULL)
+            i->rollback_fn(i);
+}
+
+bool
+osw_conf_ap_psk_tree_changed(struct ds_tree *a, struct ds_tree *b)
+{
+    struct osw_conf_psk *i;
+    size_t n = 0;
+    size_t m = 0;
+
+    ds_tree_foreach(a, i) {
+        struct osw_conf_psk *j = ds_tree_find(b, &i->ap_psk.key_id);
+        if (j == NULL) return true;
+
+        const char *x = i->ap_psk.psk.str;
+        const char *y = j->ap_psk.psk.str;
+        size_t l = sizeof(i->ap_psk.psk.str);
+        if (strncmp(x, y, l) != 0) return true;
+
+        n++;
+    }
+
+    ds_tree_foreach(b, i)
+        m++;
+
+    if (n != m) return true;
+
+    return false;
+}
+
+bool
+osw_conf_ap_acl_tree_changed(struct ds_tree *a, struct ds_tree *b)
+{
+    struct osw_conf_acl *i;
+    size_t n = 0;
+    size_t m = 0;
+
+    ds_tree_foreach(a, i) {
+        struct osw_conf_acl *j = ds_tree_find(b, &i->mac_addr);
+        if (j == NULL) return true;
+        n++;
+    }
+
+    ds_tree_foreach(b, i)
+        m++;
+
+    if (n != m) return true;
+
+    return false;
+}
+
+void
+osw_conf_ap_psk_tree_to_str(char *out, size_t len, const struct ds_tree *a)
+{
+    /* FIXME: ds_tree APIs don't have const variants necessary */
+    struct ds_tree *b = (struct ds_tree *)a;
+    struct osw_conf_psk *i;
+    const size_t max = ARRAY_SIZE(i->ap_psk.psk.str);
+
+    out[0] = 0;
+    ds_tree_foreach(b, i) {
+        csnprintf(&out, &len, "%d:len=%d,",
+                  i->ap_psk.key_id,
+                  strnlen(i->ap_psk.psk.str, max));
+    }
+    if (ds_tree_is_empty(b) == false && out[-1] == ',')
+        out[-1] = 0;
+}
+
+void
+osw_conf_ap_acl_tree_to_str(char *out, size_t len, const struct ds_tree *a)
+{
+    /* FIXME: ds_tree APIs don't have const variants necessary */
+    struct ds_tree *b = (struct ds_tree *)a;
+    struct osw_conf_acl *i;
+
+    out[0] = 0;
+    ds_tree_foreach(b, i) {
+        csnprintf(&out, &len, OSW_HWADDR_FMT ",",
+                  OSW_HWADDR_ARG(&i->mac_addr));
+    }
+    if (ds_tree_is_empty(b) == false && out[-1] == ',')
+        out[-1] = 0;
+}
+
+static void
+osw_conf_ut_psk_changed_cb(void *data)
+{
+    struct ds_tree a = DS_TREE_INIT(ds_int_cmp, struct osw_conf_psk, node);
+    struct ds_tree b = DS_TREE_INIT(ds_int_cmp, struct osw_conf_psk, node);
+    struct osw_conf_psk psk1 = { .ap_psk = { .psk = { .str = "12345678" }, .key_id = 1 } };
+    struct osw_conf_psk psk2 = { .ap_psk = { .psk = { .str = "87654321" }, .key_id = 1 } };
+    struct osw_conf_psk psk3 = { .ap_psk = { .psk = { .str = "12345678" }, .key_id = 2 } };
+    struct osw_conf_psk psk4 = psk1;
+
+    assert(osw_conf_ap_psk_tree_changed(&a, &b) == false);
+
+    ds_tree_insert(&a, &psk1, &psk1.ap_psk.key_id);
+    ds_tree_insert(&b, &psk4, &psk4.ap_psk.key_id);
+    assert(osw_conf_ap_psk_tree_changed(&a, &b) == false);
+    ds_tree_remove(&a, &psk1);
+    ds_tree_remove(&b, &psk4);
+
+    ds_tree_insert(&a, &psk1, &psk1.ap_psk.key_id);
+    ds_tree_insert(&b, &psk2, &psk2.ap_psk.key_id);
+    assert(osw_conf_ap_psk_tree_changed(&a, &b) == true);
+    ds_tree_remove(&a, &psk1);
+    ds_tree_remove(&b, &psk2);
+
+    ds_tree_insert(&a, &psk1, &psk1.ap_psk.key_id);
+    ds_tree_insert(&b, &psk3, &psk3.ap_psk.key_id);
+    assert(osw_conf_ap_psk_tree_changed(&a, &b) == true);
+    ds_tree_remove(&a, &psk1);
+    ds_tree_remove(&b, &psk3);
+
+    ds_tree_insert(&a, &psk1, &psk1.ap_psk.key_id);
+    ds_tree_insert(&a, &psk2, &psk2.ap_psk.key_id);
+    ds_tree_insert(&b, &psk3, &psk3.ap_psk.key_id);
+    assert(osw_conf_ap_psk_tree_changed(&a, &b) == true);
+    ds_tree_remove(&a, &psk1);
+    ds_tree_remove(&a, &psk2);
+    ds_tree_remove(&b, &psk3);
+
+    ds_tree_insert(&a, &psk1, &psk1.ap_psk.key_id);
+    ds_tree_insert(&b, &psk2, &psk2.ap_psk.key_id);
+    ds_tree_insert(&b, &psk3, &psk3.ap_psk.key_id);
+    assert(osw_conf_ap_psk_tree_changed(&a, &b) == true);
+    ds_tree_remove(&a, &psk1);
+    ds_tree_remove(&b, &psk2);
+    ds_tree_remove(&b, &psk3);
+}
+
+static void
+osw_conf_ut_acl_changed_cb(void *data)
+{
+    struct ds_tree a = DS_TREE_INIT(osw_conf_vif_acl_cmp, struct osw_conf_acl, node);
+    struct ds_tree b = DS_TREE_INIT(osw_conf_vif_acl_cmp, struct osw_conf_acl, node);
+    struct osw_conf_acl acl1 = { .mac_addr = { .octet = { 0, 1, 2, 3, 4, 5 } } };
+    struct osw_conf_acl acl2 = { .mac_addr = { .octet = { 0, 1, 2, 3, 4, 6 } } };
+    struct osw_conf_acl acl3 = { .mac_addr = { .octet = { 0, 1, 2, 3, 4, 7 } } };
+    struct osw_conf_acl acl4 = acl1;
+
+    assert(osw_conf_ap_acl_tree_changed(&a, &b) == false);
+
+    ds_tree_insert(&a, &acl1, &acl1.mac_addr);
+    ds_tree_insert(&b, &acl4, &acl4.mac_addr);
+    assert(osw_conf_ap_acl_tree_changed(&a, &b) == false);
+    ds_tree_remove(&a, &acl1);
+    ds_tree_remove(&b, &acl4);
+
+    ds_tree_insert(&a, &acl1, &acl1.mac_addr);
+    ds_tree_insert(&b, &acl2, &acl2.mac_addr);
+    assert(osw_conf_ap_acl_tree_changed(&a, &b) == true);
+    ds_tree_remove(&a, &acl1);
+    ds_tree_remove(&b, &acl2);
+
+    ds_tree_insert(&a, &acl1, &acl1.mac_addr);
+    ds_tree_insert(&a, &acl2, &acl2.mac_addr);
+    ds_tree_insert(&b, &acl3, &acl3.mac_addr);
+    assert(osw_conf_ap_acl_tree_changed(&a, &b) == true);
+    ds_tree_remove(&a, &acl1);
+    ds_tree_remove(&a, &acl2);
+    ds_tree_remove(&b, &acl3);
+}
+
+static void
+osw_conf_ut_module_init(void *data)
+{
+    osw_ut_register("osw_conf_ut_psk_changed", osw_conf_ut_psk_changed_cb, NULL);
+    osw_ut_register("osw_conf_ut_acl_changed", osw_conf_ut_acl_changed_cb, NULL);
+}
+
+static void
+osw_conf_ut_module_fini(void *data)
+{
+}
+
+MODULE(osw_conf_ut_module, osw_conf_ut_module_init, osw_conf_ut_module_fini);
Index: device-core/src/lib/osw/src/osw_confsync.c
===================================================================
--- /dev/null
+++ device-core/src/lib/osw/src/osw_confsync.c
@@ -0,0 +1,664 @@
+#include <util.h>
+#include <log.h>
+#include <memutil.h>
+#include <const.h>
+#include <module.h>
+#include <osw.h>
+#include <osw_ut.h>
+#include <osw_confsync.h>
+#include <osw_drv_dummy.h>
+#include <osw_mux.h>
+
+static void
+osw_confsync_build_phy_debug(const struct osw_drv_phy_config *cmd,
+                             const struct osw_conf_phy *conf,
+                             const struct osw_conf_phy *state)
+{
+    const char *phy = cmd->phy_name;
+
+    if (cmd->changed) {
+        LOGI("osw: confsync: %s: changed", phy);
+    }
+
+    if (cmd->enabled_changed) {
+        LOGI("osw: confsync: %s: enabled: %d -> %d",
+             phy, state->enabled, conf->enabled);
+    }
+
+    if (cmd->tx_chainmask_changed) {
+        LOGI("osw: confsync: %s: tx_chainmask: 0x%04x -> 0x%04x",
+             phy, state->tx_chainmask, conf->tx_chainmask);
+    }
+
+    if (cmd->radar_changed) {
+        const char *from = osw_radar_to_str(state->radar);
+        const char *to = osw_radar_to_str(conf->radar);
+        LOGI("osw: confsync: %s: radar: %s -> %s", phy, from, to);
+    }
+}
+
+static void
+osw_confsync_build_vif_ap_debug(const char *phy,
+                                const char *vif,
+                                const struct osw_drv_vif_config_ap *cmd,
+                                const struct osw_conf_vif_ap *conf,
+                                const struct osw_conf_vif_ap *state)
+{
+    const int max_2g_chan = 11; /* FIXME: Assuming worst case regulatory. Could use phy chan list */
+
+    if (cmd->bridge_if_name_changed) {
+        const int max = ARRAY_SIZE(conf->bridge_if_name.buf);
+        LOGI("osw: confsync: %s/%s: bridge_if_name: '%.*s' -> '%.*s'",
+             phy, vif,
+             max, state->bridge_if_name.buf,
+             max, conf->bridge_if_name.buf);
+    }
+
+    if (cmd->beacon_interval_tu_changed) {
+        LOGI("osw: confsync: %s/%s: beacon_interval_tu: %d -> %d",
+             phy, vif, state->beacon_interval_tu, conf->beacon_interval_tu);
+    }
+
+    if (cmd->isolated_changed) {
+        // FIXME: isolate vs isolated
+        LOGI("osw: confsync: %s/%s: isolate: %d -> %d",
+             phy, vif, state->isolated, conf->isolated);
+    }
+
+    if (cmd->ssid_hidden_changed) {
+        LOGI("osw: confsync: %s/%s: ssid_hidden: %d -> %d",
+             phy, vif, state->ssid_hidden, conf->ssid_hidden);
+    }
+
+    if (cmd->mcast2ucast_changed) {
+        LOGI("osw: confsync: %s/%s: mcast2ucast: %d -> %d",
+             phy, vif, state->mcast2ucast, conf->mcast2ucast);
+    }
+
+    if (cmd->channel_changed) {
+        // FIXME: common fmt for channel? fix bw
+        struct osw_channel s = state->channel;
+        struct osw_channel c = conf->channel;
+        osw_channel_compute_center_freq(&s, max_2g_chan);
+        osw_channel_compute_center_freq(&c, max_2g_chan);
+        LOGI("osw: confsync: %s/%s: channel: "OSW_CHANNEL_FMT" -> "OSW_CHANNEL_FMT,
+             phy, vif,
+             OSW_CHANNEL_ARG(&s),
+             OSW_CHANNEL_ARG(&c));
+    }
+
+    if (cmd->mode_changed) {
+        char from[128];
+        char to[128];
+        osw_ap_mode_to_str(from, sizeof(from), &state->mode);
+        osw_ap_mode_to_str(to, sizeof(to), &conf->mode);
+        LOGI("osw: confsync: %s/%s: mode: %s -> %s", phy, vif, from, to);
+    }
+
+    if (cmd->acl_policy_changed) {
+        const char *from = osw_acl_policy_to_str(state->acl_policy);
+        const char *to = osw_acl_policy_to_str(conf->acl_policy);
+        LOGI("osw: confsync: %s/%s: acl policy: %s -> %s", phy, vif, from, to);
+    }
+
+    if (cmd->ssid_changed) {
+        LOGI("osw: confsync: %s/%s: ssid: "OSW_SSID_FMT" -> "OSW_SSID_FMT,
+             phy, vif,
+             OSW_SSID_ARG(&state->ssid),
+             OSW_SSID_ARG(&conf->ssid));
+    }
+
+    if (cmd->wpa_changed) {
+        char from[128];
+        char to[128];
+        osw_wpa_to_str(from, sizeof(from), &state->wpa);
+        osw_wpa_to_str(to, sizeof(to), &conf->wpa);
+        LOGI("osw: confsync: %s/%s: wpa: %s -> %s", phy, vif, from, to);
+    }
+
+    if (cmd->acl_changed) {
+        char from[1024];
+        char to[1024];
+        osw_conf_ap_acl_tree_to_str(from, sizeof(from), &state->acl_tree);
+        osw_conf_ap_acl_tree_to_str(to, sizeof(to), &conf->acl_tree);
+        LOGI("osw: confsync: %s/%s: acl: %s -> %s", phy, vif, from, to);
+    }
+
+    if (cmd->psk_list_changed) {
+        char from[1024];
+        char to[1024];
+        osw_conf_ap_psk_tree_to_str(from, sizeof(from), &state->psk_tree);
+        osw_conf_ap_psk_tree_to_str(to, sizeof(to), &conf->psk_tree);
+        LOGI("osw: confsync: %s/%s: psk: %s -> %s", phy, vif, from, to);
+    }
+}
+
+static void
+osw_confsync_build_vif_debug(const struct osw_drv_vif_config *cmd,
+                             const struct osw_conf_vif *conf,
+                             const struct osw_conf_vif *state)
+{
+    const char *phy = conf->phy->phy_name;
+    const char *vif = conf->vif_name;
+
+    if (cmd->changed) {
+        LOGI("osw: confsync: %s/%s: changed", phy, vif);
+    }
+
+    if (cmd->enabled_changed) {
+        LOGI("osw: confsync: %s/%s: enabled: %d -> %d",
+             phy, vif, state->enabled, conf->enabled);
+    }
+
+    if (cmd->vif_type_changed) {
+        const char *from = osw_vif_type_to_str(state->vif_type);
+        const char *to = osw_vif_type_to_str(conf->vif_type);
+        LOGI("osw: confsync: %s/%s: vif_type: %s -> %s",
+             phy, vif, from, to);
+
+    }
+
+    if (cmd->vif_type_changed == false) {
+        switch (cmd->vif_type) {
+            case OSW_VIF_UNDEFINED:
+                break;
+            case OSW_VIF_AP:
+                osw_confsync_build_vif_ap_debug(phy, vif,
+                                                &cmd->u.ap,
+                                                &conf->u.ap,
+                                                &state->u.ap);
+                break;
+            case OSW_VIF_AP_VLAN:
+                break;
+            case OSW_VIF_STA:
+                break;
+        }
+    }
+}
+
+static bool
+osw_confsync_vif_ap_ssid_changed(const struct osw_ssid *a,
+                                 const struct osw_ssid *b)
+{
+    size_t max = ARRAY_SIZE(a->buf);
+    size_t n = a->len;
+    size_t m = b->len;
+    const char *x = a->buf;
+    const char *y = b->buf;
+    size_t len = MIN(MIN(max, n), m);
+    WARN_ON(n >= max);
+    WARN_ON(m >= max);
+    if (n != m || memcmp(x, y, len) != 0)
+        return true;
+
+    else
+        return false;
+}
+
+static bool
+osw_confsync_vif_ap_channel_changed(const struct osw_channel *a,
+                                    const struct osw_channel *b)
+{
+    struct osw_channel x = *a;
+    struct osw_channel y = *b;
+    const int max_2g_chan = 11; /* FIXME: Assuming worst case regulatory. Could use phy chan list */
+
+    if (x.center_freq0_mhz == 0) {
+        osw_channel_compute_center_freq(&x, max_2g_chan);
+        LOGD("x: auto center freq: %d", x.center_freq0_mhz);
+    }
+
+    if (y.center_freq0_mhz == 0) {
+        osw_channel_compute_center_freq(&y, max_2g_chan);
+        LOGD("y: auto center freq: %d", y.center_freq0_mhz);
+    }
+
+    if (memcmp(&x, &y, sizeof(x)) == 0)
+        return false;
+    else
+        return true;
+}
+
+static void
+osw_confsync_vif_ap_mark_changed(struct osw_conf_vif *cvif,
+                                 struct osw_conf_vif *svif,
+                                 struct osw_drv_vif_config *dvif)
+{
+    dvif->u.ap.ssid_changed = osw_confsync_vif_ap_ssid_changed(&cvif->u.ap.ssid, &svif->u.ap.ssid);
+    dvif->u.ap.psk_list_changed = osw_conf_ap_psk_tree_changed(&cvif->u.ap.psk_tree, &svif->u.ap.psk_tree);
+    dvif->u.ap.acl_changed = osw_conf_ap_acl_tree_changed(&cvif->u.ap.acl_tree, &svif->u.ap.acl_tree);
+    dvif->u.ap.channel_changed = osw_confsync_vif_ap_channel_changed(&cvif->u.ap.channel, &svif->u.ap.channel);
+
+    dvif->changed |= (dvif->u.ap.beacon_interval_tu_changed = (svif->u.ap.beacon_interval_tu != cvif->u.ap.beacon_interval_tu));
+    dvif->changed |= (dvif->u.ap.isolated_changed = (svif->u.ap.isolated != cvif->u.ap.isolated));
+    dvif->changed |= (dvif->u.ap.ssid_hidden_changed = (svif->u.ap.ssid_hidden != cvif->u.ap.ssid_hidden));
+    dvif->changed |= (dvif->u.ap.mcast2ucast_changed = (svif->u.ap.mcast2ucast != cvif->u.ap.mcast2ucast));
+    dvif->changed |= (dvif->u.ap.acl_policy_changed = (svif->u.ap.acl_policy != cvif->u.ap.acl_policy));
+    dvif->changed |= (dvif->u.ap.wpa_changed = (memcmp(&svif->u.ap.wpa, &cvif->u.ap.wpa, sizeof(svif->u.ap.wpa)) != 0));
+    dvif->changed |= (dvif->u.ap.mode_changed = (memcmp(&svif->u.ap.mode, &cvif->u.ap.mode, sizeof(svif->u.ap.mode)) != 0));
+    dvif->changed |= (dvif->u.ap.bridge_if_name_changed = (strcmp(svif->u.ap.bridge_if_name.buf, cvif->u.ap.bridge_if_name.buf) != 0));
+    dvif->changed |= dvif->u.ap.psk_list_changed;
+    dvif->changed |= dvif->u.ap.acl_changed;
+    dvif->changed |= dvif->u.ap.ssid_changed;
+    dvif->changed |= dvif->u.ap.channel_changed;
+
+    dvif->u.ap.csa_required = (dvif->u.ap.channel_changed && svif->enabled == true);
+}
+
+static struct osw_drv_conf *
+osw_confsync_build_drv_conf(struct osw_confsync *cs, const bool debug)
+{
+    struct osw_drv_conf *drv_conf = CALLOC(1, sizeof(*drv_conf));
+    struct osw_conf *conf = cs->conf;
+    struct osw_conf *state = cs->state;
+    struct osw_conf_phy *cphy;
+    struct osw_conf_phy *sphy;
+    struct osw_drv_phy_config *dphy;
+    struct osw_conf_vif *cvif;
+    struct osw_conf_vif *svif;
+    struct osw_drv_vif_config *dvif;
+    const int max_2g_chan = 11; /* FIXME: Assuming worst case regulatory. Could use phy chan list */
+
+    ds_tree_foreach(&state->phy_tree, sphy) {
+        cphy = ds_tree_find(&conf->phy_tree, sphy->phy_name);
+        assert(cphy != NULL);
+
+        drv_conf->n_phy_list++;
+        drv_conf->phy_list = REALLOC(drv_conf->phy_list, drv_conf->n_phy_list * sizeof(*dphy));
+        dphy = &drv_conf->phy_list[drv_conf->n_phy_list - 1];
+        memset(dphy, 0, sizeof(*dphy));
+
+        dphy->phy_name = STRDUP(cphy->phy_name);
+        dphy->enabled = cphy->enabled;
+        dphy->tx_chainmask = cphy->tx_chainmask;
+        dphy->radar = cphy->radar;
+
+        if (dphy->enabled == false && sphy->enabled == false)
+            cphy = sphy;
+
+        dphy->changed = false;
+        dphy->changed |= (dphy->enabled_changed = cphy->enabled != sphy->enabled);
+        dphy->changed |= (dphy->tx_chainmask_changed = cphy->tx_chainmask != sphy->tx_chainmask);
+        dphy->changed |= (dphy->radar_changed = cphy->radar != sphy->radar);
+
+        if (debug) osw_confsync_build_phy_debug(dphy, cphy, sphy);
+
+        /* Recover real cphy back in case it was overridden
+         * due to disablement.
+         */
+        cphy = ds_tree_find(&conf->phy_tree, sphy->phy_name);
+
+        ds_tree_foreach(&sphy->vif_tree, svif) {
+            cvif = ds_tree_find(&cphy->vif_tree, svif->vif_name);
+            assert(cvif != NULL);
+
+            dphy->vif_list.count++;
+            dphy->vif_list.list = REALLOC(dphy->vif_list.list, dphy->vif_list.count * sizeof(*dvif));
+            dvif = &dphy->vif_list.list[dphy->vif_list.count - 1];
+            memset(dvif, 0, sizeof(*dvif));
+
+            cvif->enabled &= cphy->enabled;
+
+            dvif->vif_name = STRDUP(cvif->vif_name);
+            dvif->enabled = cvif->enabled;
+            dvif->vif_type = cvif->vif_type;
+
+            if (dvif->enabled == false && svif->enabled == false)
+                cvif = svif;
+
+            dvif->changed = false;
+            dvif->changed |= (dvif->enabled_changed = (cvif->enabled != svif->enabled));
+            dvif->changed |= (dvif->vif_type_changed = (cvif->vif_type != svif->vif_type));
+
+            switch (cvif->vif_type) {
+                case OSW_VIF_UNDEFINED:
+                    break;
+                case OSW_VIF_AP:
+                    dvif->u.ap.bridge_if_name = cvif->u.ap.bridge_if_name;
+                    dvif->u.ap.beacon_interval_tu = cvif->u.ap.beacon_interval_tu;
+                    dvif->u.ap.channel = cvif->u.ap.channel;
+                    dvif->u.ap.isolated = cvif->u.ap.isolated;
+                    dvif->u.ap.ssid_hidden = cvif->u.ap.ssid_hidden;
+                    dvif->u.ap.mcast2ucast = cvif->u.ap.mcast2ucast;
+                    dvif->u.ap.mode = cvif->u.ap.mode;
+                    dvif->u.ap.acl_policy = cvif->u.ap.acl_policy;
+                    dvif->u.ap.ssid = cvif->u.ap.ssid;
+                    dvif->u.ap.wpa = cvif->u.ap.wpa;
+
+                    if (dvif->u.ap.channel.center_freq0_mhz == 0)
+                        osw_channel_compute_center_freq(&dvif->u.ap.channel, max_2g_chan);
+
+                    {
+                        struct osw_ap_psk *psks;
+                        struct osw_conf_psk *psk;
+                        int n = 0;
+                        int i = 0;
+
+                        ds_tree_foreach(&cvif->u.ap.psk_tree, psk)
+                            n++;
+
+                        psks = CALLOC(n, sizeof(*psks));
+                        ds_tree_foreach(&cvif->u.ap.psk_tree, psk) {
+                            psks[i].key_id = psk->ap_psk.key_id;
+                            STRSCPY_WARN(psks[i].psk.str, psk->ap_psk.psk.str);
+                            i++;
+                        }
+
+                        dvif->u.ap.psk_list.list = psks;
+                        dvif->u.ap.psk_list.count = n;
+                    }
+                    {
+                        struct osw_hwaddr *addrs;
+                        struct osw_conf_acl *acl;
+                        int n = 0;
+                        int i = 0;
+
+                        ds_tree_foreach(&cvif->u.ap.acl_tree, acl)
+                            n++;
+
+                        addrs = CALLOC(n, sizeof(*addrs));
+                        ds_tree_foreach(&cvif->u.ap.acl_tree, acl) {
+                            addrs[i] = acl->mac_addr;
+                            i++;
+                        }
+
+                        dvif->u.ap.acl.list = addrs;
+                        dvif->u.ap.acl.count = n;
+                    }
+                    // FIXME: radius
+
+                    if (dvif->vif_type_changed == false)
+                        osw_confsync_vif_ap_mark_changed(cvif, svif, dvif);
+
+                    /* FIXME: Arguably if vif_type is changing _all_ parameters
+                     * are changing?
+                     */
+                    break;
+                case OSW_VIF_AP_VLAN:
+                    break;
+                case OSW_VIF_STA:
+                    break;
+            }
+
+            if (debug) osw_confsync_build_vif_debug(dvif, cvif, svif);
+        }
+    }
+
+    return drv_conf;
+}
+
+static void
+osw_confsync_set_idle(struct osw_confsync *cs, const bool idle)
+{
+    if (cs->idle == idle) return;
+    if (idle == true && cs->idle_fn != NULL) cs->idle_fn(cs);
+    if (idle == false && cs->busy_fn != NULL) cs->busy_fn(cs);
+    cs->idle = idle;
+}
+
+static void
+osw_confsync_update_idle(struct osw_confsync *cs)
+{
+    const bool working = ev_is_active(&cs->work);
+    const bool retrying = ev_is_active(&cs->retry);
+    const bool idle = (working == false) && (retrying == false);
+    osw_confsync_set_idle(cs, idle);
+}
+
+static void
+osw_confsync_set_settled(struct osw_confsync *cs, bool settled)
+{
+    if (cs->settled == settled) goto out;
+
+    if (settled == true) {
+        ev_timer_stop(EV_DEFAULT_ &cs->retry);
+        cs->settled = true;
+        if (cs->settled_fn != NULL) cs->settled_fn(cs);
+    }
+
+    if (settled == false) {
+        assert(!ev_is_active(&cs->retry));
+        ev_timer_start(EV_DEFAULT_ &cs->retry);
+        cs->settled = false;
+        if (cs->agitated_fn != NULL) cs->agitated_fn(cs);
+    }
+
+out:
+    osw_confsync_update_idle(cs);
+}
+
+static bool
+osw_confsync_can_request(struct osw_confsync *cs, bool force)
+{
+    if (cs->conf == NULL) return false;
+    if (cs->state == NULL) return false;
+    if (force == true) return true;
+    return cs->settled;
+}
+
+static bool
+osw_confsync_conf_is_synced(struct osw_confsync *cs)
+{
+    if (cs->conf == NULL) return false;
+    if (cs->state == NULL) return false;
+    const bool debug = false;
+    struct osw_drv_conf *conf = osw_confsync_build_drv_conf(cs, debug);
+    bool changed = false;
+    size_t i;
+    for (i = 0; i < conf->n_phy_list && changed == false; i++) {
+        const struct osw_drv_phy_config *pc = &conf->phy_list[i];
+        size_t j;
+        if (pc->changed) changed = true;
+        for (j = 0; j < pc->vif_list.count && changed == false; j++) {
+            const struct osw_drv_vif_config *vc = &pc->vif_list.list[j];
+            if (vc->changed) changed = true;
+        }
+    }
+    osw_drv_conf_free(conf);
+    return !changed;
+}
+
+static void
+osw_confsync_work(struct osw_confsync *cs, bool force)
+{
+    LOGT("%s", __func__);
+
+    if (osw_confsync_can_request(cs, force) == true) {
+        const bool debug = true;
+        struct osw_drv_conf *conf = osw_confsync_build_drv_conf(cs, debug);
+        bool requested = osw_mux_request_config(conf);
+        osw_confsync_set_settled(cs, requested ? false : true);
+    }
+    else if (osw_confsync_conf_is_synced(cs)) {
+        osw_confsync_set_settled(cs, true);
+    }
+}
+
+static void
+osw_confsync_work_cb(EV_P_  ev_timer *arg, int events)
+{
+    struct osw_confsync *cs = container_of(arg, struct osw_confsync, work);
+    bool forced = cs->forced;
+    cs->forced = false;
+    LOGT("%s", __func__);
+    osw_confsync_work(cs, forced);
+}
+
+static void
+osw_confsync_retry_cb(EV_P_  ev_timer *arg, int events)
+{
+    struct osw_confsync *cs = container_of(arg, struct osw_confsync, retry);
+    LOGT("%s", __func__);
+    osw_confsync_work(cs, true);
+}
+
+void
+osw_confsync_init(struct osw_confsync *cs)
+{
+    if (cs->retry_seconds == 0)
+        cs->retry_seconds = OSW_CONFSYNC_RETRY_SECONDS_DEFAULT;
+
+    ev_timer_init(&cs->work, osw_confsync_work_cb, 0, 0);
+    ev_timer_init(&cs->retry, osw_confsync_retry_cb,
+                  cs->retry_seconds, cs->retry_seconds);
+    osw_confsync_set_settled(cs, true);
+}
+
+void
+osw_confsync_fini(struct osw_confsync *cs)
+{
+    ev_timer_stop(EV_DEFAULT_ &cs->work);
+    ev_timer_stop(EV_DEFAULT_ &cs->retry);
+}
+
+static void
+osw_confsync_work_schedule(struct osw_confsync *cs)
+{
+    LOGT("%s", __func__);
+    ev_timer_start(EV_DEFAULT_ &cs->work);
+    osw_confsync_update_idle(cs);
+}
+
+void
+osw_confsync_set(struct osw_confsync *cs,
+                 struct osw_conf *conf,
+                 struct osw_conf *state,
+                 bool forced)
+{
+    LOGT("%s", __func__);
+    osw_conf_free(cs->conf);
+    osw_conf_free(cs->state);
+    cs->conf = conf;
+    cs->state = state;
+    cs->forced |= forced;
+    osw_confsync_work_schedule(cs);
+}
+
+bool
+osw_confsync_is_settled(struct osw_confsync *cs)
+{
+    if (ev_is_active(&cs->work)) return false;
+    if (ev_is_active(&cs->retry)) return false;
+    return true;
+}
+
+static void
+osw_confsync_ut_two_drivers_conf1_cb(struct osw_drv *drv, struct osw_drv_conf *conf)
+{
+    struct osw_drv_dummy *dummy = osw_drv_get_priv(drv);
+    static bool run;
+    LOGI("ow: confsync: ut: conf1");
+    assert(run == false);
+    run = true;
+    assert(conf->n_phy_list == 1);
+    assert(strcmp(conf->phy_list[0].phy_name, "phy1") == 0);
+    ev_unref(EV_DEFAULT);
+    osw_drv_dummy_set_phy(dummy, "phy1", (struct osw_drv_phy_state []) {{ .exists = true, .enabled = true }});
+}
+
+static void
+osw_confsync_ut_two_drivers_conf2_cb(struct osw_drv *drv, struct osw_drv_conf *conf)
+{
+    struct osw_drv_dummy *dummy = osw_drv_get_priv(drv);
+    static bool run;
+    LOGI("ow: confsync: ut: conf2");
+    assert(run == false);
+    run = true;
+    assert(conf->n_phy_list == 1);
+    assert(strcmp(conf->phy_list[0].phy_name, "phy2") == 0);
+    ev_unref(EV_DEFAULT);
+    osw_drv_dummy_set_phy(dummy, "phy2", (struct osw_drv_phy_state []) {{ .exists = true, .enabled = true }});
+}
+
+static void
+osw_confsync_ut_two_drivers_agitated_cb(struct osw_confsync *cs)
+{
+    LOGI("ow: confsync: ut: agitated");
+}
+
+static void
+osw_confsync_ut_two_drivers_settled_cb(struct osw_confsync *cs)
+{
+    LOGI("ow: confsync: ut: settled");
+}
+
+struct osw_confsync_ut_two_drivers {
+    struct osw_confsync cs;
+    struct osw_state_observer obs;
+};
+
+static void
+osw_confsync_ut_two_drivers_idle_cb(struct osw_state_observer *obs)
+{
+    struct osw_confsync_ut_two_drivers *ut;
+    ut = container_of(obs, struct osw_confsync_ut_two_drivers, obs);
+    LOGI("ow: confsync: ut: idle");
+    ev_unref(EV_DEFAULT);
+
+    struct osw_conf *conf = osw_conf_build_from_state();
+    struct osw_conf *state = osw_conf_build_from_state();
+    osw_confsync_set(&ut->cs, conf, state, true);
+}
+
+static void
+osw_confsync_ut_two_drivers(void *data)
+{
+    struct osw_drv_dummy dummy1 = {
+        .name = "dummy1",
+        .request_config_fn = osw_confsync_ut_two_drivers_conf1_cb,
+    };
+    struct osw_drv_dummy dummy2 = {
+        .name = "dummy2",
+        .request_config_fn = osw_confsync_ut_two_drivers_conf2_cb,
+    };
+    struct osw_confsync_ut_two_drivers ut = {
+        .cs = {
+            .agitated_fn = osw_confsync_ut_two_drivers_agitated_cb,
+            .settled_fn = osw_confsync_ut_two_drivers_settled_cb,
+        },
+        .obs = {
+            .idle_fn = osw_confsync_ut_two_drivers_idle_cb,
+            .name = "two_drivers",
+        },
+    };
+
+    osw_init();
+    osw_drv_dummy_init(&dummy1);
+    osw_drv_dummy_init(&dummy2);
+    osw_state_register_observer(&ut.obs);
+    osw_confsync_init(&ut.cs);
+    osw_confsync_set(&ut.cs, NULL, NULL, true);
+    osw_drv_dummy_set_phy(&dummy1, "phy1", (struct osw_drv_phy_state []) {{ .exists = true }});
+    osw_drv_dummy_set_phy(&dummy2, "phy2", (struct osw_drv_phy_state []) {{ .exists = true }});
+    ev_ref(EV_DEFAULT); /* idle */
+    LOGI("ow: confsync: ut: wait idle");
+    ev_run(EV_DEFAULT_ 0);
+
+    struct osw_conf *conf = osw_conf_build_from_state();
+    struct osw_conf *state = osw_conf_build_from_state();
+    struct osw_conf_phy *phy1 = ds_tree_find(&conf->phy_tree, "phy1");
+    struct osw_conf_phy *phy2 = ds_tree_find(&conf->phy_tree, "phy2");
+    phy1->enabled = true;
+    phy2->enabled = true;
+    osw_confsync_set(&ut.cs, conf, state, true);
+    ev_ref(EV_DEFAULT); /* obs */
+    ev_ref(EV_DEFAULT); /* conf1 */
+    ev_ref(EV_DEFAULT); /* conf2 */
+    LOGI("ow: confsync: ut: wait conf");
+    ev_run(EV_DEFAULT_ 0);
+}
+
+static void
+osw_confsync_ut_module_init(void *data)
+{
+    osw_ut_register("osw_confsync_ut_two_drivers", osw_confsync_ut_two_drivers, NULL);
+}
+
+static void
+osw_confsync_ut_module_fini(void *data)
+{
+}
+
+MODULE(osw_confsync_ut_module,
+       osw_confsync_ut_module_init,
+       osw_confsync_ut_module_fini);
Index: device-core/src/lib/osw/src/osw_drv.c
===================================================================
--- /dev/null
+++ device-core/src/lib/osw/src/osw_drv.c
@@ -0,0 +1,1521 @@
+#include <memutil.h>
+#include <module.h>
+#include <os.h>
+#include <os_time.h>
+#include <ev.h>
+#include <const.h>
+#include <osw_drv.h>
+#include "osw_drv_i.h"
+#include "osw_state_i.h"
+
+/* TODO
+ * - use macros to automate value/string/list comparisons for "is changed", along with dumping to logs/traces
+ * - add counters: settle/nosettle counts, work rounds, watchdog counts, request retry counts: will make testing teasier
+ * - add global timestamp of when system last settled, for debugging purposes
+ * - 
+ */
+
+struct ds_tree g_osw_drv_tree = DS_TREE_INIT(ds_void_cmp, struct osw_drv, node);
+static ev_async g_osw_drv_work_all_async;
+static ev_timer g_osw_drv_work_watchdog;
+static bool g_osw_drv_work_done;
+static bool g_osw_drv_settled;
+
+#define OSW_DRV_WORK_ALL_WATCHDOG_SECONDS 60.0
+#define OSW_DRV_CHAN_SYNC_SECONDS 5.0
+
+#define osw_log_drv_register_ops(ops) \
+    LOGI("osw: drv: registering ops: name=%s", ops->name)
+#define osw_log_drv_unregister_ops(ops) \
+    LOGI("osw: drv: unregistering ops: name=%s", ops->name)
+#define osw_log_drv_retry_phy_request(phy) \
+    LOGI("osw: drv: retrying phy state request: drv=%s phy=%s", \
+         phy->drv->ops->name, phy->phy_name);
+#define osw_log_drv_retry_vif_request(vif) \
+    LOGI("osw: drv: retrying vif state request: drv=%s phy=%s vif=%s", \
+         vif->phy->drv->ops->name, vif->phy->phy_name, vif->vif_name);
+#define osw_log_drv_retry_sta_request(sta) \
+    LOGI("osw: drv: retrying sta state request: drv=%s phy=%s vif=%s sta=" OSW_HWADDR_FMT, \
+         sta->vif->phy->drv->ops->name, sta->vif->phy->phy_name, sta->vif->vif_name, OSW_HWADDR_ARG(&(sta)->mac_addr));
+#define osw_log_drv_watchdog() \
+    LOGW("osw: drv: watchdog trigerred: system has not settled for %.2f seconds", \
+         OSW_DRV_WORK_ALL_WATCHDOG_SECONDS);
+
+#define ARRDUP(src, dst, memb_ptr, memb_len) \
+    do { \
+        (dst)->memb_ptr = NULL; \
+        (dst)->memb_len = 0; \
+        if ((src)->memb_ptr != NULL && (src)->memb_len > 0) { \
+            size_t n = sizeof(*(dst)->memb_ptr) * (src)->memb_len; \
+            (dst)->memb_ptr = MALLOC(n); \
+            (dst)->memb_len = (src)->memb_len; \
+            memcpy((dst)->memb_ptr, (src)->memb_ptr, n); \
+        } \
+    } while (0)
+
+static void
+osw_drv_set_phy_list_valid(struct osw_drv *drv, bool valid)
+{
+    if (drv->phy_list_valid == valid) return;
+
+    drv->phy_list_valid = valid;
+    g_osw_drv_work_done = true;
+    osw_drv_work_all_schedule();
+}
+
+static void
+osw_drv_phy_set_vif_list_valid(struct osw_drv_phy *phy, bool valid)
+{
+    if (phy->vif_list_valid == valid) return;
+
+    phy->vif_list_valid = valid;
+    g_osw_drv_work_done = true;
+    osw_drv_work_all_schedule();
+}
+
+static void
+osw_drv_vif_set_sta_list_valid(struct osw_drv_vif *vif, bool valid)
+{
+    if (vif->sta_list_valid == valid) return;
+
+    vif->sta_list_valid = valid;
+    g_osw_drv_work_done = true;
+    osw_drv_work_all_schedule();
+}
+
+static void
+osw_drv_obj_set_state(struct osw_drv_obj *obj, enum osw_drv_obj_state state)
+{
+    if (obj->state == state) return;
+
+    obj->state = state;
+    g_osw_drv_work_done = true;
+    osw_drv_work_all_schedule();
+}
+
+static bool
+osw_drv_sta_is_settled(struct osw_drv_sta *sta)
+{
+    return sta->obj.state == OSW_DRV_OBJ_PROCESSED;
+}
+
+static int
+osw_drv_sta_addr_cmp(const void *a, const void *b)
+{
+    return memcmp(a, b, sizeof(struct osw_hwaddr));
+}
+
+static struct osw_drv_sta *
+osw_drv_sta_alloc(struct osw_drv_vif *vif, const struct osw_hwaddr *mac_addr)
+{
+    struct osw_drv_sta *sta = CALLOC(1, sizeof(*sta));
+
+    sta->mac_addr = *mac_addr;
+    sta->vif = vif;
+    ds_tree_insert(&vif->sta_tree, sta, &sta->mac_addr);
+    return sta;
+}
+
+static void
+osw_drv_sta_free(struct osw_drv_sta *sta)
+{
+    g_osw_drv_work_done = true;
+    ds_tree_remove(&sta->vif->sta_tree, sta);
+    FREE(sta);
+}
+
+static struct osw_drv_sta *
+osw_drv_sta_get(struct osw_drv_vif *vif, const struct osw_hwaddr *mac_addr)
+{
+    return ds_tree_find(&vif->sta_tree, mac_addr) ?: osw_drv_sta_alloc(vif, mac_addr);
+}
+
+static void
+osw_drv_sta_assign_state(struct osw_drv_sta_state *dst,
+                         const struct osw_drv_sta_state *src)
+{
+    const struct osw_drv_sta_state zero = {0};
+
+    if (src == NULL)
+        src = &zero;
+
+    *dst = *src;
+}
+
+static void
+osw_drv_sta_set_state(struct osw_drv_sta *sta,
+                      const struct osw_drv_sta_state *state)
+{
+    osw_drv_obj_set_state(&sta->obj, OSW_DRV_OBJ_VALID);
+    osw_drv_sta_assign_state(&sta->new_state, state);
+}
+
+static void
+osw_drv_sta_request_state(struct osw_drv_sta *sta)
+{
+    struct osw_drv_vif *vif = sta->vif;
+    struct osw_drv_phy *phy = vif->phy;
+    struct osw_drv *drv = phy->drv;
+
+    if (drv->unregistered == true) {
+        struct osw_drv_sta_state state = {0};
+        osw_drv_sta_set_state(sta, &state);
+        return;
+    }
+
+    assert(sta != NULL);
+    assert(drv->ops->request_sta_state_fn != NULL);
+
+    osw_drv_obj_set_state(&sta->obj, OSW_DRV_OBJ_REQUESTED);
+    drv->ops->request_sta_state_fn(drv, phy->phy_name, vif->vif_name, &sta->mac_addr);
+}
+
+static bool
+osw_drv_sta_state_is_changed(const struct osw_drv_sta *sta)
+{
+    bool changed = false;
+    bool changed_connected = sta->cur_state.connected != sta->new_state.connected;
+    bool changed_key_id = sta->cur_state.key_id != sta->new_state.key_id;
+
+    changed |= changed_connected;
+    changed |= changed_key_id;
+
+    return changed;
+}
+
+static void
+osw_drv_sta_process_state(struct osw_drv_sta *sta)
+{
+    bool added = sta->cur_state.connected == false
+              && sta->new_state.connected == true;
+    bool removed = sta->cur_state.connected == true
+                && sta->new_state.connected == false;
+    bool changed = sta->cur_state.connected == true
+                && sta->new_state.connected == true
+                && osw_drv_sta_state_is_changed(sta) == true;
+
+    if (sta->cur_state.connected == true &&
+        sta->new_state.connected == true &&
+        (sta->cur_state.connected_duration_seconds >
+         sta->new_state.connected_duration_seconds)) {
+        sta->pub.connected_at = 0;
+        added = true;
+        removed = true;
+    }
+
+    if (added == true) {
+        if (sta->vif->cur_state.exists == false) {
+            osw_drv_phy_set_vif_list_valid(sta->vif->phy, false);
+            return;
+        }
+    }
+
+    osw_drv_sta_assign_state(&sta->cur_state, &sta->new_state);
+    osw_drv_obj_set_state(&sta->obj, OSW_DRV_OBJ_PROCESSED);
+
+    sta->pub.mac_addr = &sta->mac_addr;
+    sta->pub.vif = &sta->vif->pub;
+    sta->pub.drv_state = &sta->cur_state;
+
+    if (sta->cur_state.connected_duration_seconds != 0 || sta->pub.connected_at == 0) {
+        sta->pub.connected_at = time_monotonic();
+        sta->pub.connected_at -= sta->cur_state.connected_duration_seconds;
+    }
+
+    if (removed == true) OSW_STATE_NOTIFY(sta_disconnected_fn, &sta->pub);
+    if (added == true) OSW_STATE_NOTIFY(sta_connected_fn, &sta->pub);
+    if (changed == true) OSW_STATE_NOTIFY(sta_changed_fn, &sta->pub);
+}
+
+static void
+osw_drv_sta_work(struct osw_drv_sta *sta)
+{
+    switch (sta->obj.state) {
+        case OSW_DRV_OBJ_INVALID:
+            osw_drv_sta_request_state(sta);
+            break;
+        case OSW_DRV_OBJ_REQUESTED:
+            /* Waiting for driver to call osw_drv_report_sta_state().
+             * That'll move the state to VALID.
+             */
+            break;
+        case OSW_DRV_OBJ_VALID:
+            osw_drv_sta_process_state(sta);
+            break;
+        case OSW_DRV_OBJ_PROCESSED:
+            if (sta->cur_state.connected == false) {
+                osw_drv_sta_free(sta);
+                return;
+            }
+            break;
+    }
+}
+
+static void
+osw_drv_sta_enumerate_cb(const struct osw_hwaddr *mac_addr, void *data)
+{
+    struct osw_drv_sta *sta = osw_drv_sta_get(data, mac_addr);
+    sta->obj.exists = true;
+}
+
+static void
+osw_drv_sta_enumerate(struct osw_drv_vif *vif)
+{
+    struct osw_drv_phy *phy = vif->phy;
+    struct osw_drv *drv = phy->drv;
+    struct osw_drv_sta *sta;
+    const char *phy_name = phy->phy_name;
+    const char *vif_name = vif->vif_name;
+
+    ds_tree_foreach(&vif->sta_tree, sta) {
+        sta->obj.existed = sta->obj.exists;
+        sta->obj.exists = false;
+    }
+
+    if (drv->unregistered == false) {
+        drv->ops->get_sta_list_fn(drv, phy_name, vif_name, osw_drv_sta_enumerate_cb, vif);
+    }
+
+    ds_tree_foreach(&vif->sta_tree, sta) {
+        if (sta->obj.existed != sta->obj.exists) {
+            osw_drv_obj_set_state(&sta->obj, OSW_DRV_OBJ_INVALID);
+        }
+    }
+}
+
+static bool
+osw_drv_vif_stas_are_settled(struct osw_drv_vif *vif)
+{
+    struct osw_drv_sta *sta;
+
+    ds_tree_foreach(&vif->sta_tree, sta)
+        if (osw_drv_sta_is_settled(sta) == false)
+            return false;
+
+    return true;
+}
+
+static bool
+osw_drv_vif_is_settled(struct osw_drv_vif *vif)
+{
+    if (osw_drv_vif_stas_are_settled(vif) == false)
+        return false;
+
+    return vif->obj.state == OSW_DRV_OBJ_PROCESSED;
+}
+
+static void
+osw_drv_vif_assert_unique(const char *vif_name)
+{
+    struct osw_drv_phy *phy;
+    struct osw_drv *drv;
+
+    ds_tree_foreach(&g_osw_drv_tree, drv) {
+        ds_tree_foreach(&drv->phy_tree, phy) {
+            assert(ds_tree_find(&phy->vif_tree, vif_name) == NULL);
+        }
+    }
+}
+
+static void
+osw_drv_vif_chan_sync_cb(EV_P_ ev_timer *arg, int events)
+{
+    struct osw_drv_vif *vif = container_of(arg, struct osw_drv_vif, chan_sync);
+    struct osw_drv_phy *phy = vif->phy;
+    struct osw_drv *drv = phy->drv;
+
+    LOGI("osw: drv: %s/%s: syncing channel state",
+         phy->phy_name, vif->vif_name);
+
+    osw_drv_report_vif_changed(drv, phy->phy_name, vif->vif_name);
+    osw_drv_report_phy_changed(drv, phy->phy_name);
+}
+
+void
+osw_drv_set_chan_sync(struct osw_drv *drv, const struct osw_drv_conf *conf)
+{
+    /* FIXME: Drivers should advertise capability to skip
+     * this to avoid needless work if they really can report
+     * proper channel state updates on VIFs.
+     */
+    size_t i;
+    for (i = 0; i < conf->n_phy_list; i++) {
+        const struct osw_drv_phy_config *cphy = &conf->phy_list[i];
+        struct osw_drv_phy *phy = ds_tree_find(&drv->phy_tree, cphy->phy_name);
+        if (WARN_ON(phy == NULL)) continue;
+
+        size_t j;
+        for (j = 0; j < cphy->vif_list.count; j++) {
+            const struct osw_drv_vif_config *cvif = &cphy->vif_list.list[j];
+            struct osw_drv_vif *vif = ds_tree_find(&phy->vif_tree, cvif->vif_name);
+            if (WARN_ON(vif == NULL)) continue;
+            if (cvif->vif_type != OSW_VIF_AP) continue;
+            if (cvif->u.ap.channel_changed == false) continue;
+
+            LOGI("osw: drv: %s/%s: scheduling channel state sync",
+                 phy->phy_name, vif->vif_name);
+
+            ev_timer_stop(EV_DEFAULT_ &vif->chan_sync);
+            ev_timer_set(&vif->chan_sync, OSW_DRV_CHAN_SYNC_SECONDS, 0);
+            ev_timer_start(EV_DEFAULT_ &vif->chan_sync);
+        }
+    }
+}
+
+static struct osw_drv_vif *
+osw_drv_vif_alloc(struct osw_drv_phy *phy, const char *vif_name)
+{
+    struct osw_drv_vif *vif = CALLOC(1, sizeof(*vif));
+
+    osw_drv_vif_assert_unique(vif_name);
+    vif->vif_name = STRDUP(vif_name);
+    vif->phy = phy;
+    ev_timer_init(&vif->chan_sync, osw_drv_vif_chan_sync_cb, 0, 0);
+    ds_tree_init(&vif->sta_tree, osw_drv_sta_addr_cmp, struct osw_drv_sta, node);
+    ds_tree_insert(&phy->vif_tree, vif, vif->vif_name);
+    return vif;
+}
+
+static void
+osw_drv_vif_free(struct osw_drv_vif *vif)
+{
+    g_osw_drv_work_done = true;
+    ev_timer_stop(EV_DEFAULT_ &vif->chan_sync);
+    ds_tree_remove(&vif->phy->vif_tree, vif);
+    FREE(vif->vif_name);
+    FREE(vif);
+}
+
+static struct osw_drv_vif *
+osw_drv_vif_get(struct osw_drv_phy *phy, const char *vif_name)
+{
+    return ds_tree_find(&phy->vif_tree, vif_name) ?: osw_drv_vif_alloc(phy, vif_name);
+}
+
+static void
+osw_drv_vif_assign_state(struct osw_drv_vif_state *dst,
+                         const struct osw_drv_vif_state *src)
+{
+    const struct osw_drv_vif_state zero = {0};
+    const struct osw_drv_vif_state_ap *ap_src = &src->u.ap;
+    struct osw_drv_vif_state_ap *ap_dst = &dst->u.ap;
+
+    if (src == NULL)
+       src = &zero;
+
+    switch (dst->vif_type) {
+        case OSW_VIF_UNDEFINED:
+            break;
+        case OSW_VIF_AP:
+            FREE(ap_dst->acl.list);
+            FREE(ap_dst->psk_list.list);
+            FREE(ap_dst->radius_list.list);
+            break;
+        case OSW_VIF_AP_VLAN:
+            break;
+        case OSW_VIF_STA:
+            break;
+    }
+
+    *dst = *src;
+
+    switch (dst->vif_type) {
+        case OSW_VIF_UNDEFINED:
+            break;
+        case OSW_VIF_AP:
+            ARRDUP(ap_src, ap_dst, acl.list, acl.count);
+            ARRDUP(ap_src, ap_dst, psk_list.list, psk_list.count);
+            ARRDUP(ap_src, ap_dst, radius_list.list, radius_list.count);
+            break;
+        case OSW_VIF_AP_VLAN:
+            break;
+        case OSW_VIF_STA:
+            break;
+    }
+
+}
+static void
+osw_drv_vif_set_state(struct osw_drv_vif *vif,
+                      const struct osw_drv_vif_state *state)
+{
+    osw_drv_obj_set_state(&vif->obj, OSW_DRV_OBJ_VALID);
+    osw_drv_vif_assign_state(&vif->new_state, state);
+}
+
+static void
+osw_drv_vif_request_state(struct osw_drv_vif *vif)
+{
+    struct osw_drv_phy *phy = vif->phy;
+    struct osw_drv *drv = phy->drv;
+
+    if (drv->unregistered == true) {
+        struct osw_drv_vif_state state = {0};
+        osw_drv_vif_set_state(vif, &state);
+        return;
+    }
+
+    assert(vif != NULL);
+    assert(drv->unregistered == false);
+    assert(drv->ops->request_vif_state_fn != NULL);
+
+    osw_drv_obj_set_state(&vif->obj, OSW_DRV_OBJ_REQUESTED);
+    drv->ops->request_vif_state_fn(drv, phy->phy_name, vif->vif_name);
+}
+
+static bool
+osw_drv_vif_state_is_changed_ap(const struct osw_drv_vif *vif)
+{
+    const struct osw_drv_vif_state_ap *o = &vif->cur_state.u.ap;
+    const struct osw_drv_vif_state_ap *n = &vif->new_state.u.ap;
+
+    bool changed = false;
+    bool changed_bridge = strcmp(o->bridge_if_name.buf, n->bridge_if_name.buf) != 0;
+    bool changed_isolated = o->isolated != n->isolated;
+    bool changed_ssid_hidden = o->ssid_hidden != n->ssid_hidden;
+    bool changed_mcast2ucast = o->mcast2ucast != n->mcast2ucast;
+    bool changed_beacon_interval_tu = o->beacon_interval_tu != n->beacon_interval_tu;
+    bool changed_channel = memcmp(&o->channel, &n->channel, sizeof(o->channel));
+    bool changed_mode = memcmp(&o->mode, &n->mode, sizeof(o->mode));
+    bool changed_wpa = memcmp(&o->wpa, &n->wpa, sizeof(o->wpa));
+    bool changed_ssid = memcmp(&o->ssid, &n->ssid, sizeof(o->ssid));
+    bool changed_acl_policy = o->acl_policy != n->acl_policy;
+    bool changed_acl = false;
+    bool changed_psk = false;
+
+    {
+        size_t i;
+        size_t j;
+        size_t a = 0;
+        size_t b = 0;
+
+        for (i = 0; i < o->acl.count; i++)
+            a++;
+        for (i = 0; i < n->acl.count; i++)
+            b++;
+
+        if (a == b) {
+            for (i = 0; i < o->acl.count; i++) {
+                for (j = 0; j < n->acl.count; j++) {
+                    const struct osw_hwaddr *x = &o->acl.list[i];
+                    const struct osw_hwaddr *y = &n->acl.list[j];
+                    if (memcmp(x, y, sizeof(*x)) == 0)
+                        break;
+                }
+                if (j == n->acl.count) {
+                    changed_acl = true;
+                    break;
+                }
+            }
+        }
+        else {
+            changed_acl = true;
+        }
+    }
+
+    {
+        size_t i;
+        size_t j;
+        size_t a = 0;
+        size_t b = 0;
+
+        for (i = 0; i < o->psk_list.count; i++)
+            a++;
+        for (i = 0; i < n->psk_list.count; i++)
+            b++;
+
+        if (a == b) {
+            for (i = 0; i < o->psk_list.count; i++) {
+                for (j = 0; j < n->psk_list.count; j++) {
+                    const struct osw_ap_psk *x = &o->psk_list.list[i];
+                    const struct osw_ap_psk *y = &n->psk_list.list[j];
+                    if (memcmp(x, y, sizeof(*x)) == 0)
+                        break;
+                }
+                if (j == n->psk_list.count) {
+                    changed_psk = true;
+                    break;
+                }
+            }
+        }
+        else {
+            changed_psk = true;
+        }
+    }
+
+    changed |= changed_bridge;
+    changed |= changed_isolated;
+    changed |= changed_ssid_hidden;
+    changed |= changed_mcast2ucast;
+    changed |= changed_beacon_interval_tu;
+    changed |= changed_channel;
+    changed |= changed_mode;
+    changed |= changed_wpa;
+    changed |= changed_ssid;
+    changed |= changed_acl_policy;
+    changed |= changed_acl;
+    changed |= changed_psk;
+
+    if (changed_ssid == true) {
+        LOGI("osw: drv: %s/%s/%s: ssid: "OSW_SSID_FMT" -> "OSW_SSID_FMT,
+             vif->phy->drv->ops->name,
+             vif->phy->phy_name,
+             vif->vif_name,
+             OSW_SSID_ARG(&o->ssid),
+             OSW_SSID_ARG(&n->ssid));
+    }
+
+    if (changed_channel == true) {
+        LOGI("osw: drv: %s/%s/%s: channel: "OSW_CHANNEL_FMT" -> "OSW_CHANNEL_FMT,
+             vif->phy->drv->ops->name,
+             vif->phy->phy_name,
+             vif->vif_name,
+             OSW_CHANNEL_ARG(&o->channel),
+             OSW_CHANNEL_ARG(&n->channel));
+    }
+
+    // FIXME: radius
+    return changed;
+}
+
+static bool
+osw_drv_vif_state_is_changed_ap_vlan(const struct osw_drv_vif *vif)
+{
+    bool changed = false;
+    /* TODO */
+    return changed;
+}
+
+static bool
+osw_drv_vif_state_is_changed_sta(const struct osw_drv_vif *vif)
+{
+    bool changed = false;
+    /* TODO */
+    return changed;
+}
+
+static bool
+osw_drv_vif_state_is_changed(const struct osw_drv_vif *vif)
+{
+    bool changed = false;
+    bool changed_enabled = vif->cur_state.enabled != vif->new_state.enabled;
+    bool changed_vif_type = vif->cur_state.vif_type != vif->new_state.vif_type;
+    bool changed_mac_addr = memcmp(&vif->cur_state.mac_addr,
+                                   &vif->new_state.mac_addr,
+                                   sizeof(vif->new_state.mac_addr));
+
+    changed |= changed_enabled;
+    changed |= changed_vif_type;
+    changed |= changed_mac_addr;
+
+    if (changed_vif_type == false) {
+        switch (vif->new_state.vif_type) {
+            case OSW_VIF_UNDEFINED:
+                break;
+            case OSW_VIF_AP:
+                changed |= osw_drv_vif_state_is_changed_ap(vif);
+                break;
+            case OSW_VIF_AP_VLAN:
+                changed |= osw_drv_vif_state_is_changed_ap_vlan(vif);
+                break;
+            case OSW_VIF_STA:
+                changed |= osw_drv_vif_state_is_changed_sta(vif);
+                break;
+        }
+    }
+
+    return changed;
+}
+
+static void
+osw_drv_vif_process_state(struct osw_drv_vif *vif)
+{
+    bool added = vif->cur_state.exists == false
+              && vif->new_state.exists == true;
+    bool removed = vif->cur_state.exists == true
+                && vif->new_state.exists == false;
+    bool changed = vif->cur_state.exists == true
+                && vif->new_state.exists == true
+                && osw_drv_vif_state_is_changed(vif) == true;
+
+    if (removed == true) {
+        if (osw_drv_vif_stas_are_settled(vif) == false) {
+            return;
+        }
+
+        if (ds_tree_is_empty(&vif->sta_tree) == false) {
+            osw_drv_vif_set_sta_list_valid(vif, false);
+            return;
+        }
+    }
+
+    if (added == true) {
+        if (vif->phy->cur_state.exists == false) {
+            osw_drv_set_phy_list_valid(vif->phy->drv, false);
+            return;
+        }
+    }
+
+    osw_drv_vif_assign_state(&vif->cur_state, &vif->new_state);
+    osw_drv_obj_set_state(&vif->obj, OSW_DRV_OBJ_PROCESSED);
+
+    vif->pub.vif_name = vif->vif_name;
+    vif->pub.phy = &vif->phy->pub;
+    vif->pub.drv_state = &vif->cur_state;
+
+    if (added == true) OSW_STATE_NOTIFY(vif_added_fn, &vif->pub);
+    if (changed == true) OSW_STATE_NOTIFY(vif_changed_fn, &vif->pub);
+    if (removed == true) OSW_STATE_NOTIFY(vif_removed_fn, &vif->pub);
+}
+
+static void
+osw_drv_vif_work(struct osw_drv_vif *vif)
+{
+    struct osw_drv_sta *sta;
+    struct osw_drv_sta *tmp;
+
+    switch (vif->obj.state) {
+        case OSW_DRV_OBJ_INVALID:
+            osw_drv_vif_request_state(vif);
+            break;
+        case OSW_DRV_OBJ_REQUESTED:
+            /* Waiting for driver to call osw_drv_report_vif_state().
+             * That'll move the state to VALID.
+             */
+            break;
+        case OSW_DRV_OBJ_VALID:
+            osw_drv_vif_process_state(vif);
+            break;
+        case OSW_DRV_OBJ_PROCESSED:
+            if (vif->cur_state.exists == false) {
+                osw_drv_vif_free(vif);
+                return;
+            }
+            break;
+    }
+
+    if (vif->sta_list_valid == false) {
+        osw_drv_sta_enumerate(vif);
+        osw_drv_vif_set_sta_list_valid(vif, true);
+    }
+
+    ds_tree_foreach_safe(&vif->sta_tree, sta, tmp)
+        osw_drv_sta_work(sta);
+}
+
+static void
+osw_drv_vif_enumerate_cb(const char *vif_name, void *data)
+{
+    struct osw_drv_vif *vif = osw_drv_vif_get(data, vif_name);
+    vif->obj.exists = true;
+}
+
+static void
+osw_drv_vif_enumerate(struct osw_drv_phy *phy)
+{
+    struct osw_drv *drv = phy->drv;
+    const char *phy_name = phy->phy_name;
+    struct osw_drv_vif *vif;
+
+    ds_tree_foreach(&phy->vif_tree, vif) {
+        vif->obj.existed = vif->obj.exists;
+        vif->obj.exists = false;
+    }
+
+    if (drv->unregistered == false) {
+        drv->ops->get_vif_list_fn(drv, phy_name, osw_drv_vif_enumerate_cb, phy);
+    }
+
+    ds_tree_foreach(&phy->vif_tree, vif) {
+        if (vif->obj.exists != vif->obj.existed) {
+            osw_drv_obj_set_state(&vif->obj, OSW_DRV_OBJ_INVALID);
+        }
+    }
+}
+
+static void
+osw_drv_phy_assert_unique(const char *phy_name)
+{
+    struct osw_drv *drv;
+
+    ds_tree_foreach(&g_osw_drv_tree, drv) {
+        assert(ds_tree_find(&drv->phy_tree, phy_name) == NULL);
+    }
+}
+
+static struct osw_drv_phy *
+osw_drv_phy_alloc(struct osw_drv *drv, const char *phy_name)
+{
+    struct osw_drv_phy *phy = CALLOC(1, sizeof(*phy));
+
+    osw_drv_phy_assert_unique(phy_name);
+    phy->phy_name = STRDUP(phy_name);
+    phy->drv = drv;
+    ds_tree_init(&phy->vif_tree, ds_str_cmp, struct osw_drv_vif, node);
+    ds_tree_insert(&drv->phy_tree, phy, phy->phy_name);
+    return phy;
+}
+
+static struct osw_drv_phy *
+osw_drv_phy_get(struct osw_drv *drv, const char *phy_name)
+{
+    return ds_tree_find(&drv->phy_tree, phy_name) ?: osw_drv_phy_alloc(drv, phy_name);
+}
+
+static void
+osw_drv_phy_free(struct osw_drv_phy *phy)
+{
+    g_osw_drv_work_done = true;
+    ds_tree_remove(&phy->drv->phy_tree, phy);
+    FREE(phy->phy_name);
+    FREE(phy);
+}
+
+static bool
+osw_drv_phy_vifs_are_settled(struct osw_drv_phy *phy)
+{
+    struct osw_drv_vif *vif;
+
+    ds_tree_foreach(&phy->vif_tree, vif)
+        if (osw_drv_vif_is_settled(vif) == false)
+            return false;
+
+    return true;
+}
+
+static bool
+osw_drv_phy_is_settled(struct osw_drv_phy *phy)
+{
+    if (osw_drv_phy_vifs_are_settled(phy) == false)
+        return false;
+
+    if (phy->obj.state == OSW_DRV_OBJ_PROCESSED
+    &&  phy->cur_state.exists == false)
+        return false;
+
+    return phy->obj.state == OSW_DRV_OBJ_PROCESSED;
+}
+
+static void
+osw_drv_phy_assign_state(struct osw_drv_phy_state *dst,
+                         const struct osw_drv_phy_state *src)
+{
+    const struct osw_drv_phy_state zero = {0};
+
+    if (src == NULL)
+        src = &zero;
+
+    FREE(dst->channel_states);
+    *dst = *src;
+    ARRDUP(src, dst, channel_states, n_channel_states);
+}
+
+static void
+osw_drv_phy_set_state(struct osw_drv_phy *phy,
+                      const struct osw_drv_phy_state *state)
+{
+    osw_drv_obj_set_state(&phy->obj, OSW_DRV_OBJ_VALID);
+    osw_drv_phy_assign_state(&phy->new_state, state);
+}
+
+static void
+osw_drv_phy_request_state(struct osw_drv_phy *phy)
+{
+    struct osw_drv *drv = phy->drv;
+
+    if (drv->unregistered == true) {
+        struct osw_drv_phy_state state = {0};
+        osw_drv_phy_set_state(phy, &state);
+        return;
+    }
+
+    assert(phy != NULL);
+    assert(drv->unregistered == false);
+    assert(drv->ops->request_phy_state_fn != NULL);
+
+    osw_drv_obj_set_state(&phy->obj, OSW_DRV_OBJ_REQUESTED);
+    drv->ops->request_phy_state_fn(drv, phy->phy_name);
+}
+
+static bool
+osw_drv_phy_state_is_changed(const struct osw_drv_phy *phy)
+{
+    bool changed = false;
+    bool changed_enabled = phy->cur_state.enabled != phy->new_state.enabled;
+    bool changed_tx_chainmask = phy->cur_state.tx_chainmask != phy->new_state.tx_chainmask;
+    bool changed_radar = phy->cur_state.radar != phy->new_state.radar;
+
+    changed |= changed_enabled;
+    changed |= changed_tx_chainmask;
+    changed |= changed_radar;
+
+    // FIXME: Add missing field checks
+
+    return changed;
+}
+
+static void
+osw_drv_phy_process_state(struct osw_drv_phy *phy)
+{
+    bool added = phy->cur_state.exists == false
+              && phy->new_state.exists == true;
+    bool removed = phy->cur_state.exists == true
+                && phy->new_state.exists == false;
+    bool changed = phy->cur_state.exists == true
+                && phy->new_state.exists == true
+                && osw_drv_phy_state_is_changed(phy) == true;
+
+    if (removed == true) {
+        if (osw_drv_phy_vifs_are_settled(phy) == false) {
+            return;
+        }
+
+        if (ds_tree_is_empty(&phy->vif_tree) == false) {
+            osw_drv_phy_set_vif_list_valid(phy, false);
+            return;
+        }
+    }
+
+    osw_drv_phy_assign_state(&phy->cur_state, &phy->new_state);
+    osw_drv_obj_set_state(&phy->obj, OSW_DRV_OBJ_PROCESSED);
+
+    phy->pub.phy_name = phy->phy_name;
+    phy->pub.drv_state = &phy->cur_state;
+
+    if (added == true) OSW_STATE_NOTIFY(phy_added_fn, &phy->pub);
+    if (changed == true) OSW_STATE_NOTIFY(phy_changed_fn, &phy->pub);
+    if (removed == true) OSW_STATE_NOTIFY(phy_removed_fn, &phy->pub);
+}
+
+static void
+osw_drv_phy_work(struct osw_drv_phy *phy)
+{
+    struct osw_drv_vif *vif;
+    struct osw_drv_vif *tmp;
+
+    switch (phy->obj.state) {
+        case OSW_DRV_OBJ_INVALID:
+            osw_drv_phy_request_state(phy);
+            break;
+        case OSW_DRV_OBJ_REQUESTED:
+            /* Waiting for driver to call osw_drv_report_phy_state().
+             * That'll move the state to VALID.
+             */
+            break;
+        case OSW_DRV_OBJ_VALID:
+            osw_drv_phy_process_state(phy);
+            break;
+        case OSW_DRV_OBJ_PROCESSED:
+            if (phy->cur_state.exists == false) {
+                osw_drv_phy_free(phy);
+                return;
+            }
+            break;
+    }
+
+    if (phy->vif_list_valid == false) {
+        osw_drv_vif_enumerate(phy);
+        osw_drv_phy_set_vif_list_valid(phy, true);
+    }
+
+    ds_tree_foreach_safe(&phy->vif_tree, vif, tmp)
+        osw_drv_vif_work(vif);
+}
+
+static void
+osw_drv_phy_enumerate_cb(const char *phy_name, void *data)
+{
+    struct osw_drv_phy *phy = osw_drv_phy_get(data, phy_name);
+    phy->obj.exists = true;
+}
+
+static void
+osw_drv_phy_enumerate(struct osw_drv *drv)
+{
+    struct osw_drv_phy *phy;
+
+    ds_tree_foreach(&drv->phy_tree, phy) {
+        phy->obj.existed = phy->obj.exists;
+        phy->obj.exists = false;
+    }
+
+    if (drv->unregistered == false) {
+        drv->ops->get_phy_list_fn(drv, osw_drv_phy_enumerate_cb, drv);
+    }
+
+    ds_tree_foreach(&drv->phy_tree, phy) {
+        if (phy->obj.exists != phy->obj.existed) {
+            osw_drv_obj_set_state(&phy->obj, OSW_DRV_OBJ_INVALID);
+        }
+    }
+}
+
+static void
+osw_drv_free(struct osw_drv *drv)
+{
+    g_osw_drv_work_done = true;
+    ds_tree_remove(&g_osw_drv_tree, drv);
+    FREE(drv);
+}
+
+static bool
+osw_drv_is_settled(struct osw_drv *drv)
+{
+    struct osw_drv_phy *phy;
+
+    if (drv->phy_list_valid == false)
+        return false;
+
+    if (drv->unregistered == true && ds_tree_is_empty(&drv->phy_tree) == true)
+        return false;
+
+    ds_tree_foreach(&drv->phy_tree, phy)
+        if (osw_drv_phy_is_settled(phy) == false)
+            return false;
+
+    return true;
+}
+
+bool
+osw_drv_work_is_settled(void)
+{
+    struct osw_drv *drv;
+
+    ds_tree_foreach(&g_osw_drv_tree, drv)
+        if (osw_drv_is_settled(drv) == false)
+            return false;
+
+    return true;
+}
+
+void
+osw_drv_work(struct osw_drv *drv)
+{
+    struct osw_drv_phy *phy;
+    struct osw_drv_phy *tmp;
+
+    if (drv->initialized == false) {
+        if (drv->unregistered == true)
+            goto free;
+        drv->ops->init_fn(drv);
+        drv->initialized = true;
+        g_osw_drv_work_done = true;
+    }
+
+    if (drv->phy_list_valid == false) {
+        osw_drv_phy_enumerate(drv);
+        osw_drv_set_phy_list_valid(drv, true);
+    }
+
+    ds_tree_foreach_safe(&drv->phy_tree, phy, tmp)
+        osw_drv_phy_work(phy);
+
+    /* FIXME: This should use a specialized
+     * osw_state_ helper to check if it's ready to
+     * be freed.
+     */
+free:
+    if (drv->unregistered == true && ds_tree_is_empty(&drv->phy_tree) == true)
+        osw_drv_free(drv);
+}
+
+static void
+osw_drv_work_dump_debug(void); // FIXME
+void
+osw_drv_work_all(void)
+{
+    g_osw_drv_work_done = false;
+
+    struct osw_drv *drv;
+    struct osw_drv *tmp;
+    const bool was_settled = g_osw_drv_settled;
+
+    ds_tree_foreach_safe(&g_osw_drv_tree, drv, tmp)
+        osw_drv_work(drv);
+
+    const bool is_settled = osw_drv_work_is_settled();
+
+    if (is_settled == false) {
+        /* Work processing is designed to work in passes. A
+         * single pass isn't guaranteed to be able to
+         * process everything because sometimes processing
+         * dependency is upwards or downwards in the object
+         * hierarchy.
+         *
+         * If there was no work done, and structures haven't
+         * settled it may mean a couple of things:
+         *  - driver hasn't generated some events (yet),
+         *    hopefully will do that soon. Eg. vif removal
+         *    will need sta removals to happen too first.
+         *  - driver has been requested to report a
+         *    phy/vif/sta state. This has undefined run time.
+         */
+        if (g_osw_drv_work_done == true)
+            osw_drv_work_all_schedule();
+        else if (ev_is_active(&g_osw_drv_work_watchdog) == false)
+            ev_timer_again(EV_DEFAULT_ &g_osw_drv_work_watchdog);
+    } else {
+        ev_timer_stop(EV_DEFAULT_ &g_osw_drv_work_watchdog);
+    }
+
+    if (was_settled == false && is_settled == true) OSW_STATE_NOTIFY(idle_fn);
+    if (was_settled == true && is_settled == false) OSW_STATE_NOTIFY(busy_fn);
+    g_osw_drv_settled = is_settled;
+}
+
+void
+osw_drv_work_all_cb(EV_P_ ev_async *arg, int events)
+{
+    osw_drv_work_all();
+}
+
+void
+osw_drv_work_all_schedule(void)
+{
+    ev_async_send(EV_DEFAULT_ &g_osw_drv_work_all_async);
+}
+
+static void
+osw_drv_work_all_retry_requests(void)
+{
+    struct ds_tree *drv_tree = &g_osw_drv_tree;
+    struct osw_drv *drv;
+    struct osw_drv_phy *phy;
+    struct osw_drv_vif *vif;
+    struct osw_drv_sta *sta;
+
+    ds_tree_foreach(drv_tree, drv) {
+        ds_tree_foreach(&drv->phy_tree, phy) {
+            if (phy->obj.state == OSW_DRV_OBJ_REQUESTED) {
+                osw_log_drv_retry_phy_request(phy);
+                osw_drv_obj_set_state(&phy->obj, OSW_DRV_OBJ_INVALID);
+            }
+
+            ds_tree_foreach(&phy->vif_tree, vif) {
+                if (vif->obj.state == OSW_DRV_OBJ_REQUESTED) {
+                    osw_log_drv_retry_vif_request(vif);
+                    osw_drv_obj_set_state(&vif->obj, OSW_DRV_OBJ_INVALID);
+                }
+
+                ds_tree_foreach(&vif->sta_tree, sta) {
+                    if (sta->obj.state == OSW_DRV_OBJ_REQUESTED) {
+                        osw_log_drv_retry_sta_request(sta);
+                        osw_drv_obj_set_state(&sta->obj, OSW_DRV_OBJ_INVALID);
+                    }
+                }
+            }
+        }
+    }
+}
+
+static void
+osw_drv_work_dump_debug(void)
+{
+    struct osw_drv *drv;
+    struct osw_drv_phy *phy;
+    struct osw_drv_vif *vif;
+    struct osw_drv_sta *sta;
+
+    ds_tree_foreach(&g_osw_drv_tree, drv) {
+        LOGI("osw: drv: settled debug: drv=%s list=%d unreg=%d empty=%d settled=%d",
+             drv->ops->name, drv->phy_list_valid, drv->unregistered, ds_tree_is_empty(&drv->phy_tree), osw_drv_is_settled(drv));
+        ds_tree_foreach(&drv->phy_tree, phy) {
+            LOGI("osw: drv: settled debug: phy=%s list=%d empty=%d state=%d settled=%d",
+                 phy->phy_name, phy->vif_list_valid, ds_tree_is_empty(&phy->vif_tree), phy->obj.state, osw_drv_phy_is_settled(phy));
+            ds_tree_foreach(&phy->vif_tree, vif) {
+                LOGI("osw: drv: settled debug: vif=%s list=%d empty=%d state=%d settled=%d",
+                     vif->vif_name, vif->sta_list_valid, ds_tree_is_empty(&vif->sta_tree), vif->obj.state, osw_drv_vif_is_settled(vif));
+                ds_tree_foreach(&vif->sta_tree, sta) {
+                    LOGI("osw: drv: settled debug: sta=" OSW_HWADDR_FMT " state=%d settled=%d",
+                         OSW_HWADDR_ARG(&sta->mac_addr), sta->obj.state, osw_drv_sta_is_settled(sta));
+                }
+            }
+        }
+    }
+}
+
+static void
+osw_drv_work_all_watchdog_cb(EV_P_ ev_timer *arg, int events)
+{
+    osw_log_drv_watchdog();
+    osw_drv_work_dump_debug();
+    osw_drv_work_all_retry_requests();
+    osw_drv_work_all_schedule();
+}
+
+void
+osw_drv_report_phy_state(struct osw_drv *drv,
+                         const char *phy_name,
+                         const struct osw_drv_phy_state *state)
+{
+    if (drv == NULL) return;
+    if (drv->unregistered == true) return;
+
+    struct osw_drv_phy *phy = ds_tree_find(&drv->phy_tree, phy_name);
+    if (phy == NULL) {
+        osw_drv_set_phy_list_valid(drv, false);
+        return;
+    }
+
+    if (phy->obj.state != OSW_DRV_OBJ_REQUESTED)
+        return;
+
+    osw_drv_phy_set_state(phy, state->exists ? state : NULL);
+    osw_drv_work_all_schedule();
+}
+
+void
+osw_drv_report_phy_changed(struct osw_drv *drv,
+                           const char *phy_name)
+{
+    if (drv == NULL) return;
+    if (drv->unregistered == true) return;
+
+    struct osw_drv_phy *phy = ds_tree_find(&drv->phy_tree, phy_name);
+    if (phy == NULL) {
+        osw_drv_set_phy_list_valid(drv, false);
+        return;
+    }
+
+    osw_drv_obj_set_state(&phy->obj, OSW_DRV_OBJ_INVALID);
+    osw_drv_work_all_schedule();
+}
+
+void
+osw_drv_report_vif_state(struct osw_drv *drv,
+                         const char *phy_name,
+                         const char *vif_name,
+                         const struct osw_drv_vif_state *state)
+{
+    if (drv == NULL) return;
+    if (drv->unregistered == true) return;
+
+    struct osw_drv_phy *phy = ds_tree_find(&drv->phy_tree, phy_name);
+    if (phy == NULL) {
+        osw_drv_set_phy_list_valid(drv, false);
+        return;
+    }
+
+    struct osw_drv_vif *vif = ds_tree_find(&phy->vif_tree, vif_name);
+    if (vif == NULL) {
+        osw_drv_phy_set_vif_list_valid(phy, false);
+        return;
+    }
+
+    if (vif->obj.state != OSW_DRV_OBJ_REQUESTED)
+        return;
+
+    osw_drv_vif_set_state(vif, state->exists ? state : NULL);
+    osw_drv_work_all_schedule();
+}
+
+void
+osw_drv_report_vif_changed(struct osw_drv *drv,
+                           const char *phy_name,
+                           const char *vif_name)
+{
+    if (drv == NULL) return;
+    if (drv->unregistered == true) return;
+
+    struct osw_drv_phy *phy = ds_tree_find(&drv->phy_tree, phy_name);
+    if (phy == NULL) {
+        osw_drv_set_phy_list_valid(drv, false);
+        return;
+    }
+
+    struct osw_drv_vif *vif = ds_tree_find(&phy->vif_tree, vif_name);
+    if (vif == NULL) {
+        osw_drv_phy_set_vif_list_valid(phy, false);
+        return;
+    }
+
+    osw_drv_obj_set_state(&vif->obj, OSW_DRV_OBJ_INVALID);
+    osw_drv_work_all_schedule();
+}
+
+void
+osw_drv_report_vif_channel_change_started(struct osw_drv *drv,
+                                          const char *phy_name,
+                                          const char *vif_name,
+                                          const struct osw_channel *target_channel)
+{
+    if (drv == NULL) return;
+    if (drv->unregistered == true) return;
+
+    struct osw_drv_phy *phy = ds_tree_find(&drv->phy_tree, phy_name);
+    if (phy == NULL) {
+        osw_drv_set_phy_list_valid(drv, false);
+        phy = osw_drv_phy_get(drv, phy_name);
+    }
+
+    struct osw_drv_vif *vif = ds_tree_find(&phy->vif_tree, vif_name);
+    if (vif == NULL) {
+        osw_drv_phy_set_vif_list_valid(phy, false);
+        vif = osw_drv_vif_get(phy, vif_name);
+    }
+
+    osw_drv_obj_set_state(&vif->obj, OSW_DRV_OBJ_INVALID);
+
+    if (target_channel != NULL)
+        vif->csa_channel = *target_channel;
+}
+
+void
+osw_drv_report_sta_state(struct osw_drv *drv,
+                         const char *phy_name,
+                         const char *vif_name,
+                         const struct osw_hwaddr *mac_addr,
+                         const struct osw_drv_sta_state *state)
+{
+    if (drv == NULL) return;
+    if (drv->unregistered == true) return;
+
+    struct osw_drv_phy *phy = ds_tree_find(&drv->phy_tree, phy_name);
+    if (phy == NULL) {
+        osw_drv_set_phy_list_valid(drv, false);
+        return;
+    }
+
+    struct osw_drv_vif *vif = ds_tree_find(&phy->vif_tree, vif_name);
+    if (vif == NULL) {
+        osw_drv_phy_set_vif_list_valid(phy, false);
+        return;
+    }
+
+    struct osw_drv_sta *sta = ds_tree_find(&vif->sta_tree, mac_addr);
+    if (sta == NULL) {
+        osw_drv_vif_set_sta_list_valid(vif, false);
+        return;
+    }
+
+    if (sta->obj.state != OSW_DRV_OBJ_REQUESTED)
+        return;
+
+    osw_drv_sta_set_state(sta, state->connected ? state : NULL);
+    osw_drv_work_all_schedule();
+}
+
+void
+osw_drv_report_sta_changed(struct osw_drv *drv,
+                           const char *phy_name,
+                           const char *vif_name,
+                           const struct osw_hwaddr *mac_addr)
+{
+    if (drv == NULL) return;
+    if (drv->unregistered == true) return;
+
+    struct osw_drv_phy *phy = ds_tree_find(&drv->phy_tree, phy_name);
+    if (phy == NULL) {
+        osw_drv_set_phy_list_valid(drv, false);
+        return;
+    }
+
+    struct osw_drv_vif *vif = ds_tree_find(&phy->vif_tree, vif_name);
+    if (vif == NULL) {
+        osw_drv_phy_set_vif_list_valid(phy, false);
+        return;
+    }
+
+    struct osw_drv_sta *sta = ds_tree_find(&vif->sta_tree, mac_addr);
+    if (sta == NULL) {
+        osw_drv_vif_set_sta_list_valid(vif, false);
+        return;
+    }
+
+    osw_drv_obj_set_state(&sta->obj, OSW_DRV_OBJ_INVALID);
+    osw_drv_work_all_schedule();
+}
+
+void
+osw_drv_report_sta_connected(struct osw_drv *drv,
+                             const char *phy_name,
+                             const char *vif_name,
+                             const struct osw_hwaddr *mac_addr)
+{
+    /* TODO */
+}
+
+void
+osw_drv_report_sta_disconnected(struct osw_drv *drv,
+                                const char *phy_name,
+                                const char *vif_name,
+                                const struct osw_hwaddr *mac_addr)
+{
+    /* TODO */
+}
+
+void
+osw_drv_report_sta_probe_req(struct osw_drv *drv,
+                             const char *phy_name,
+                             const char *vif_name,
+                             const struct osw_hwaddr *mac_addr,
+                             const struct osw_drv_report_sta_probe_req_arg *arg)
+{
+    /* TODO */
+}
+
+void
+osw_drv_report_sta_auth_fail(struct osw_drv *drv,
+                             const char *phy_name,
+                             const char *vif_name,
+                             const struct osw_hwaddr *mac_addr,
+                             const struct osw_drv_report_sta_auth_fail_arg *arg)
+{
+    /* TODO */
+}
+
+void
+osw_drv_report_sta_action_frame(struct osw_drv *drv,
+                                const char *phy_name,
+                                const char *vif_name,
+                                const struct osw_hwaddr *mac_addr,
+                                const struct osw_drv_report_sta_action_frame_arg *arg)
+{
+    /* TODO */
+}
+
+void
+osw_drv_register_ops(const struct osw_drv_ops *ops)
+{
+    struct osw_drv *drv;
+
+    osw_log_drv_register_ops(ops);
+
+    assert(ops != NULL);
+    assert(ops->init_fn != NULL);
+    assert(ops->get_phy_list_fn != NULL);
+    assert(ops->get_vif_list_fn != NULL);
+    assert(ops->get_sta_list_fn != NULL);
+    assert(ops->request_sta_state_fn != NULL);
+    assert(ops->request_vif_state_fn != NULL);
+    assert(ops->request_phy_state_fn != NULL);
+    assert(ds_tree_find(&g_osw_drv_tree, ops) == NULL);
+
+    drv = CALLOC(1, sizeof(*drv));
+    drv->ops = ops;
+    ds_tree_init(&drv->phy_tree, ds_str_cmp, struct osw_drv_phy, node);
+    ds_tree_insert(&g_osw_drv_tree, drv, ops);
+    osw_drv_work_all_schedule();
+}
+
+void
+osw_drv_unregister_ops(const struct osw_drv_ops *ops)
+{
+    struct osw_drv *drv = ds_tree_find(&g_osw_drv_tree, ops);
+
+    osw_log_drv_unregister_ops(ops);
+
+    osw_drv_work_all_schedule();
+
+    if (drv == NULL) return;
+    if (drv->unregistered == true) return;
+
+    drv->unregistered = true;
+    drv->phy_list_valid = false;
+}
+
+void
+osw_drv_set_priv(struct osw_drv *drv, void *priv)
+{
+    drv->priv = priv;
+}
+
+void *
+osw_drv_get_priv(struct osw_drv *drv)
+{
+    return drv->priv;
+}
+
+const struct osw_drv_ops *
+osw_drv_get_ops(struct osw_drv *drv)
+{
+    return drv->ops;
+}
+
+bool
+osw_drv_conf_changed(const struct osw_drv_conf *drv_conf)
+{
+    size_t i;
+    for (i = 0; i < drv_conf->n_phy_list; i++) {
+        const struct osw_drv_phy_config *phy = &drv_conf->phy_list[i];
+
+        if (drv_conf->phy_list[i].changed)
+            return true;
+
+        size_t j;
+        for (j = 0; j < phy->vif_list.count; j++)
+            if (phy->vif_list.list[j].changed)
+                return true;
+    }
+    return false;
+}
+
+void
+osw_drv_conf_free(struct osw_drv_conf *conf)
+{
+    size_t i;
+    size_t j;
+
+    if (conf == NULL)
+        return;
+
+    for (i = 0; i < conf->n_phy_list; i++) {
+        struct osw_drv_phy_config *phy = &conf->phy_list[i];
+
+        for (j = 0; j < phy->vif_list.count; j++) {
+            struct osw_drv_vif_config *vif = &phy->vif_list.list[j];
+
+            FREE(vif->vif_name);
+            switch (vif->vif_type) {
+                case OSW_VIF_UNDEFINED:
+                    break;
+                case OSW_VIF_AP:
+                    FREE(vif->u.ap.psk_list.list);
+                    FREE(vif->u.ap.acl.list);
+                    FREE(vif->u.ap.radius_list.list);
+                    break;
+                case OSW_VIF_AP_VLAN:
+                    break;
+                case OSW_VIF_STA:
+                    break;
+            }
+        }
+
+        FREE(phy->phy_name);
+        FREE(phy->vif_list);
+    }
+
+    FREE(conf->phy_list);
+    FREE(conf);
+    g_osw_drv_work_done = true;
+}
+
+void
+osw_drv_init(void)
+{
+    static bool initialized;
+
+    if (initialized == true) return;
+
+    ev_async_init(&g_osw_drv_work_all_async, osw_drv_work_all_cb);
+    ev_async_start(EV_DEFAULT_ &g_osw_drv_work_all_async);
+    ev_unref(EV_DEFAULT);
+
+    ev_timer_init(&g_osw_drv_work_watchdog,
+                  osw_drv_work_all_watchdog_cb,
+                  OSW_DRV_WORK_ALL_WATCHDOG_SECONDS,
+                  OSW_DRV_WORK_ALL_WATCHDOG_SECONDS);
+
+    initialized = true;
+    osw_drv_work_all_schedule();
+}
+
+void
+osw_drv_unregister_all(void)
+{
+    struct osw_drv *drv;
+
+    ds_tree_foreach(&g_osw_drv_tree, drv)
+        osw_drv_unregister_ops(drv->ops);
+}
+
+#include "osw_drv_ut.c"
Index: device-core/src/lib/osw/src/osw_drv_dummy.c
===================================================================
--- /dev/null
+++ device-core/src/lib/osw/src/osw_drv_dummy.c
@@ -0,0 +1,456 @@
+#include <util.h>
+#include <const.h>
+#include <log.h>
+#include <osw_drv_dummy.h>
+#include <osw_ut.h>
+#include <module.h>
+#include <memutil.h>
+
+/* FIXME: rename _ops_ to _op_ in function names for osw_drv_ops */
+
+struct osw_drv_dummy_phy {
+    struct ds_tree_node node;
+    struct osw_ifname phy_name;
+    struct osw_drv_phy_state state;
+};
+
+struct osw_drv_dummy_vif {
+    struct ds_tree_node node;
+    struct osw_ifname phy_name;
+    struct osw_ifname vif_name;
+    struct osw_drv_vif_state state;
+};
+
+struct osw_drv_dummy_sta {
+    struct ds_dlist_node node;
+    struct osw_ifname phy_name;
+    struct osw_ifname vif_name;
+    struct osw_hwaddr sta_addr;
+    struct osw_drv_sta_state state;
+};
+
+static struct osw_drv_dummy_phy *
+osw_drv_dummy_phy_lookup(struct osw_drv_dummy *dummy,
+                         const char *phy_name)
+{
+    return ds_tree_find(&dummy->phy_tree, phy_name);
+}
+
+static struct osw_drv_dummy_vif *
+osw_drv_dummy_vif_lookup(struct osw_drv_dummy *dummy,
+                         const char *phy_name,
+                         const char *vif_name)
+{
+    struct osw_drv_dummy_vif *vif = ds_tree_find(&dummy->vif_tree, vif_name);
+    if (vif == NULL) return NULL;
+    if (strcmp(vif->phy_name.buf, phy_name) != 0) return NULL;
+    return vif;
+}
+
+static struct osw_drv_dummy_sta *
+osw_drv_dummy_sta_lookup(struct osw_drv_dummy *dummy,
+                         const char *phy_name,
+                         const char *vif_name,
+                         const struct osw_hwaddr *sta_addr)
+{
+    struct osw_drv_dummy_sta *sta;
+
+    ds_dlist_foreach(&dummy->sta_list, sta)
+        if (strlen(sta->phy_name.buf) == 0 ||
+            phy_name == NULL ||
+            strcmp(sta->phy_name.buf, phy_name) == 0)
+            if (strcmp(sta->vif_name.buf, vif_name) == 0)
+                if (memcmp(&sta->sta_addr, sta_addr, sizeof(*sta_addr)) == 0)
+                    return sta;
+
+    return NULL;
+}
+
+static const char *
+osw_drv_dummy_vif_to_phy(struct osw_drv_dummy *dummy,
+                         const char *vif_name)
+{
+    struct osw_drv_dummy_vif *vif = ds_tree_find(&dummy->vif_tree, vif_name);
+    if (vif == NULL) return NULL;
+    return vif->phy_name.buf;
+}
+
+static void
+osw_drv_dummy_ops_init_cb(struct osw_drv *drv)
+{
+    const struct osw_drv_ops *ops = osw_drv_get_ops(drv);
+    struct osw_drv_dummy *dummy = container_of(ops, struct osw_drv_dummy, ops);
+    osw_drv_set_priv(drv, dummy);
+    dummy->drv = drv;
+    if (dummy->init_fn != NULL) dummy->init_fn(drv);
+}
+
+static void
+osw_drv_dummy_ops_get_phy_list_cb(struct osw_drv *drv,
+                                  osw_drv_report_phy_fn_t *report_phy_fn,
+                                  void *fn_priv)
+{
+    struct osw_drv_dummy *dummy = osw_drv_get_priv(drv);
+    struct osw_drv_dummy_phy *phy;
+    struct osw_drv_dummy_phy *tmp;
+
+    ds_tree_foreach_safe(&dummy->phy_tree, phy, tmp)
+        report_phy_fn(phy->phy_name.buf, fn_priv);
+}
+
+static void
+osw_drv_dummy_ops_get_vif_list_cb(struct osw_drv *drv,
+                                  const char *phy_name,
+                                  osw_drv_report_vif_fn_t *report_vif_fn,
+                                  void *fn_priv)
+{
+    struct osw_drv_dummy *dummy = osw_drv_get_priv(drv);
+    struct osw_drv_dummy_vif *vif;
+    struct osw_drv_dummy_vif *tmp;
+
+    ds_tree_foreach_safe(&dummy->vif_tree, vif, tmp)
+        if (strcmp(vif->phy_name.buf, phy_name) == 0)
+            report_vif_fn(vif->vif_name.buf, fn_priv);
+}
+
+static void
+osw_drv_dummy_ops_get_sta_list_cb(struct osw_drv *drv,
+                                  const char *phy_name,
+                                  const char *vif_name,
+                                  osw_drv_report_sta_fn_t *report_sta_fn,
+                                  void *fn_priv)
+{
+    struct osw_drv_dummy *dummy = osw_drv_get_priv(drv);
+    struct osw_drv_dummy_sta *sta;
+    struct osw_drv_dummy_sta *tmp;
+
+    ds_dlist_foreach_safe(&dummy->sta_list, sta, tmp)
+        if (strlen(sta->phy_name.buf) == 0 || strcmp(sta->phy_name.buf, phy_name) == 0)
+            if (strcmp(sta->vif_name.buf, vif_name) == 0)
+                report_sta_fn(&sta->sta_addr, fn_priv);
+}
+
+static void
+osw_drv_dummy_ops_get_phy_state_cb(struct osw_drv *drv,
+                                   const char *phy_name)
+{
+    struct osw_drv_dummy *dummy = osw_drv_get_priv(drv);
+    struct osw_drv_dummy_phy *phy = osw_drv_dummy_phy_lookup(dummy, phy_name);
+    struct osw_drv_phy_state state = { .exists = false };
+
+    if (phy != NULL)
+        state = phy->state;
+
+    osw_drv_report_phy_state(drv, phy_name, &state);
+}
+
+static void
+osw_drv_dummy_ops_get_vif_state_cb(struct osw_drv *drv,
+                                   const char *phy_name,
+                                   const char *vif_name)
+{
+    struct osw_drv_dummy *dummy = osw_drv_get_priv(drv);
+    struct osw_drv_dummy_vif *vif = osw_drv_dummy_vif_lookup(dummy, phy_name, vif_name);
+    struct osw_drv_vif_state state = { .exists = false };
+
+    if (vif != NULL)
+        state = vif->state;
+
+    osw_drv_report_vif_state(drv, phy_name, vif_name, &state);
+}
+
+static void
+osw_drv_dummy_ops_get_sta_state_cb(struct osw_drv *drv,
+                                   const char *phy_name,
+                                   const char *vif_name,
+                                   const struct osw_hwaddr *sta_addr)
+{
+    struct osw_drv_dummy *dummy = osw_drv_get_priv(drv);
+    struct osw_drv_dummy_sta *sta = osw_drv_dummy_sta_lookup(dummy, phy_name, vif_name, sta_addr);
+    struct osw_drv_sta_state state = { .connected = false };
+
+    if (sta != NULL)
+        state = sta->state;
+
+    osw_drv_report_sta_state(drv, phy_name, vif_name, sta_addr, &state);
+}
+
+static void
+osw_drv_dummy_init_struct(struct osw_drv_dummy *dummy)
+{
+    const struct osw_drv_ops ops = {
+        .name = dummy->name,
+        .init_fn = osw_drv_dummy_ops_init_cb,
+        .get_phy_list_fn = osw_drv_dummy_ops_get_phy_list_cb,
+        .get_vif_list_fn = osw_drv_dummy_ops_get_vif_list_cb,
+        .get_sta_list_fn = osw_drv_dummy_ops_get_sta_list_cb,
+        .request_phy_state_fn = osw_drv_dummy_ops_get_phy_state_cb,
+        .request_vif_state_fn = osw_drv_dummy_ops_get_vif_state_cb,
+        .request_sta_state_fn = osw_drv_dummy_ops_get_sta_state_cb,
+        .request_config_fn = dummy->request_config_fn,
+    };
+
+    ds_tree_init(&dummy->phy_tree, ds_str_cmp, struct osw_drv_dummy_phy, node);
+    ds_tree_init(&dummy->vif_tree, ds_str_cmp, struct osw_drv_dummy_vif, node);
+    ds_dlist_init(&dummy->sta_list, struct osw_drv_dummy_sta, node);
+    dummy->ops = ops;
+}
+
+void
+osw_drv_dummy_init(struct osw_drv_dummy *dummy)
+{
+    osw_drv_dummy_init_struct(dummy);
+    osw_drv_register_ops(&dummy->ops);
+}
+
+static void
+osw_drv_dummy_fini_struct(struct osw_drv_dummy *dummy)
+{
+    struct osw_drv_dummy_phy *phy;
+    struct osw_drv_dummy_vif *vif;
+    struct osw_drv_dummy_sta *sta;
+
+    while ((phy = ds_tree_head(&dummy->phy_tree)) != NULL)
+        osw_drv_dummy_set_phy(dummy, phy->phy_name.buf, NULL);
+
+    while ((vif = ds_tree_head(&dummy->vif_tree)) != NULL)
+        osw_drv_dummy_set_vif(dummy, vif->phy_name.buf, vif->vif_name.buf, NULL);
+
+    while ((sta = ds_dlist_head(&dummy->sta_list)) != NULL)
+        osw_drv_dummy_set_sta(dummy, sta->phy_name.buf, sta->vif_name.buf, &sta->sta_addr, NULL);
+}
+
+void
+osw_drv_dummy_fini(struct osw_drv_dummy *dummy)
+{
+    osw_drv_dummy_fini_struct(dummy);
+    osw_drv_unregister_ops(&dummy->ops);
+}
+
+void
+osw_drv_dummy_set_phy(struct osw_drv_dummy *dummy,
+                      const char *phy_name,
+                      struct osw_drv_phy_state *state)
+{
+    struct osw_drv_dummy_phy *phy = ds_tree_find(&dummy->phy_tree, phy_name);
+    osw_drv_report_phy_changed(dummy->drv, phy_name);
+    if (phy == NULL) {
+        phy = CALLOC(1, sizeof(*phy));
+        STRSCPY_WARN(phy->phy_name.buf, phy_name);
+        ds_tree_insert(&dummy->phy_tree, phy, phy->phy_name.buf);
+    } else {
+        if (dummy->fini_phy_fn != NULL) {
+            dummy->fini_phy_fn(dummy, &phy->state);
+        }
+    }
+    if (state != NULL)
+        phy->state = *state;
+    if (state == NULL) {
+        ds_tree_remove(&dummy->phy_tree, phy);
+        FREE(phy);
+    }
+}
+
+void
+osw_drv_dummy_set_vif(struct osw_drv_dummy *dummy,
+                      const char *phy_name,
+                      const char *vif_name,
+                      struct osw_drv_vif_state *state)
+{
+    struct osw_drv_dummy_vif *vif = ds_tree_find(&dummy->vif_tree, vif_name);
+    osw_drv_report_vif_changed(dummy->drv, phy_name, vif_name);
+    if (vif == NULL) {
+        vif = CALLOC(1, sizeof(*vif));
+        STRSCPY_WARN(vif->phy_name.buf, phy_name);
+        STRSCPY_WARN(vif->vif_name.buf, vif_name);
+        ds_tree_insert(&dummy->vif_tree, vif, vif->vif_name.buf);
+    } else {
+        if (dummy->fini_vif_fn != NULL) {
+            dummy->fini_vif_fn(dummy, &vif->state);
+        }
+    }
+    if (state != NULL)
+        vif->state = *state;
+    if (state == NULL) {
+        ds_tree_remove(&dummy->vif_tree, vif);
+        FREE(vif);
+    }
+}
+
+void
+osw_drv_dummy_set_sta(struct osw_drv_dummy *dummy,
+                      const char *phy_name,
+                      const char *vif_name,
+                      const struct osw_hwaddr *sta_addr,
+                      struct osw_drv_sta_state *state)
+{
+    struct osw_drv_dummy_sta *sta = osw_drv_dummy_sta_lookup(dummy, phy_name, vif_name, sta_addr);
+    if (phy_name == NULL)
+        phy_name = osw_drv_dummy_vif_to_phy(dummy, vif_name);
+    if (phy_name != NULL)
+        osw_drv_report_sta_changed(dummy->drv, phy_name, vif_name, sta_addr);
+    if (sta == NULL) {
+        sta = CALLOC(1, sizeof(*sta));
+        if (phy_name != NULL) STRSCPY_WARN(sta->phy_name.buf, phy_name);
+        STRSCPY_WARN(sta->vif_name.buf, vif_name);
+        sta->sta_addr = *sta_addr;
+        ds_dlist_insert_tail(&dummy->sta_list, sta);
+    } else {
+        if (dummy->fini_sta_fn != NULL) {
+            dummy->fini_sta_fn(dummy, &sta->state);
+        }
+    }
+    if (state != NULL)
+        sta->state = *state;
+    if (state == NULL) {
+        ds_dlist_remove(&dummy->sta_list, sta);
+        FREE(sta);
+    }
+}
+
+void
+osw_drv_dummy_iter_sta(struct osw_drv_dummy *dummy,
+                       osw_drv_dummy_iter_sta_fn_t *fn,
+                       void *fn_data)
+{
+    struct osw_drv_dummy_sta *sta;
+    struct osw_drv_dummy_sta *tmp;
+
+    ds_dlist_foreach_safe(&dummy->sta_list, sta, tmp)
+        fn(dummy, sta->phy_name.buf, sta->vif_name.buf, &sta->sta_addr, fn_data);
+}
+
+struct osw_drv_dummy_ut_1 {
+    struct osw_drv_dummy dummy;
+    int n_phy_fini;
+    int n_vif_fini;
+    int n_sta_fini;
+};
+
+static void
+osw_drv_dummy_ut_1_fini_phy_cb(struct osw_drv_dummy *dummy,
+                               struct osw_drv_phy_state *state)
+{
+    struct osw_drv_dummy_ut_1 *ut = container_of(dummy, struct osw_drv_dummy_ut_1, dummy);
+    ut->n_phy_fini++;
+}
+
+static void
+osw_drv_dummy_ut_1_fini_vif_cb(struct osw_drv_dummy *dummy,
+                               struct osw_drv_vif_state *state)
+{
+    struct osw_drv_dummy_ut_1 *ut = container_of(dummy, struct osw_drv_dummy_ut_1, dummy);
+    ut->n_vif_fini++;
+}
+
+static void
+osw_drv_dummy_ut_1_fini_sta_cb(struct osw_drv_dummy *dummy,
+                               struct osw_drv_sta_state *state)
+{
+    struct osw_drv_dummy_ut_1 *ut = container_of(dummy, struct osw_drv_dummy_ut_1, dummy);
+    ut->n_sta_fini++;
+}
+
+static void
+osw_drv_dummy_ut_1_cb(void *data)
+{
+    struct osw_drv_dummy_ut_1 ut = {
+        .dummy = {
+            .name = "foo",
+            .fini_phy_fn = osw_drv_dummy_ut_1_fini_phy_cb,
+            .fini_vif_fn = osw_drv_dummy_ut_1_fini_vif_cb,
+            .fini_sta_fn = osw_drv_dummy_ut_1_fini_sta_cb,
+        },
+    };
+    struct osw_drv_phy_state phy1 = {0};
+    struct osw_drv_vif_state vif1 = {0};
+    struct osw_drv_sta_state sta1 = {0};
+    struct osw_hwaddr sta1_addr = {0};
+
+    osw_drv_dummy_init_struct(&ut.dummy);
+    osw_drv_dummy_set_phy(&ut.dummy, "phy1", &phy1);
+    osw_drv_dummy_set_vif(&ut.dummy, "phy1", "vif1", &vif1);
+    osw_drv_dummy_set_sta(&ut.dummy, "phy1", "vif1", &sta1_addr, &sta1);
+    assert(osw_drv_dummy_phy_lookup(&ut.dummy, "phy1") != NULL);
+    assert(osw_drv_dummy_vif_lookup(&ut.dummy, "phy1", "vif1") != NULL);
+    assert(osw_drv_dummy_sta_lookup(&ut.dummy, "phy1", "vif1", &sta1_addr) != NULL);
+    assert(ds_tree_head(&ut.dummy.phy_tree) != NULL);
+    assert(ds_tree_head(&ut.dummy.vif_tree) != NULL);
+    assert(ds_dlist_head(&ut.dummy.sta_list) != NULL);
+    assert(ut.n_phy_fini == 0);
+    assert(ut.n_vif_fini == 0);
+    assert(ut.n_sta_fini == 0);
+    osw_drv_dummy_set_phy(&ut.dummy, "phy1", NULL);
+    osw_drv_dummy_set_vif(&ut.dummy, "phy1", "vif1", NULL);
+    osw_drv_dummy_set_sta(&ut.dummy, "phy1", "vif1", &sta1_addr, NULL);
+    assert(ds_tree_head(&ut.dummy.phy_tree) == NULL);
+    assert(ds_tree_head(&ut.dummy.vif_tree) == NULL);
+    assert(ds_dlist_head(&ut.dummy.sta_list) == NULL);
+    assert(ut.n_phy_fini == 1);
+    assert(ut.n_vif_fini == 1);
+    assert(ut.n_sta_fini == 1);
+    assert(osw_drv_dummy_phy_lookup(&ut.dummy, "phy1") == NULL);
+    assert(osw_drv_dummy_vif_lookup(&ut.dummy, "phy1", "vif1") == NULL);
+    assert(osw_drv_dummy_sta_lookup(&ut.dummy, "phy1", "vif1", &sta1_addr) == NULL);
+    osw_drv_dummy_set_phy(&ut.dummy, "phy1", &phy1);
+    osw_drv_dummy_set_vif(&ut.dummy, "phy1", "vif1", &vif1);
+    osw_drv_dummy_set_sta(&ut.dummy, "phy1", "vif1", &sta1_addr, &sta1);
+    assert(ds_tree_head(&ut.dummy.phy_tree) != NULL);
+    assert(ds_tree_head(&ut.dummy.vif_tree) != NULL);
+    assert(ds_dlist_head(&ut.dummy.sta_list) != NULL);
+    assert(ut.n_phy_fini == 1);
+    assert(ut.n_vif_fini == 1);
+    assert(ut.n_sta_fini == 1);
+    osw_drv_dummy_fini_struct(&ut.dummy);
+    assert(ds_tree_head(&ut.dummy.phy_tree) == NULL);
+    assert(ds_tree_head(&ut.dummy.vif_tree) == NULL);
+    assert(ds_dlist_head(&ut.dummy.sta_list) == NULL);
+    assert(ut.n_phy_fini == 2);
+    assert(ut.n_vif_fini == 2);
+    assert(ut.n_sta_fini == 2);
+    assert(osw_drv_dummy_phy_lookup(&ut.dummy, "phy1") == NULL);
+    assert(osw_drv_dummy_vif_lookup(&ut.dummy, "phy1", "vif1") == NULL);
+    assert(osw_drv_dummy_sta_lookup(&ut.dummy, "phy1", "vif1", &sta1_addr) == NULL);
+    osw_drv_dummy_set_phy(&ut.dummy, "phy1", &phy1);
+    osw_drv_dummy_set_vif(&ut.dummy, "phy1", "vif1", &vif1);
+    osw_drv_dummy_set_sta(&ut.dummy, "phy1", "vif1", &sta1_addr, &sta1);
+    assert(ds_tree_head(&ut.dummy.phy_tree) != NULL);
+    assert(ds_tree_head(&ut.dummy.vif_tree) != NULL);
+    assert(ds_dlist_head(&ut.dummy.sta_list) != NULL);
+    assert(ut.n_phy_fini == 2);
+    assert(ut.n_vif_fini == 2);
+    assert(ut.n_sta_fini == 2);
+    osw_drv_dummy_set_phy(&ut.dummy, "phy1", NULL);
+    osw_drv_dummy_set_vif(&ut.dummy, "phy1", "vif1", NULL);
+    osw_drv_dummy_set_sta(&ut.dummy, "phy1", "vif1", &sta1_addr, NULL);
+    assert(ds_tree_head(&ut.dummy.phy_tree) == NULL);
+    assert(ds_tree_head(&ut.dummy.vif_tree) == NULL);
+    assert(ds_dlist_head(&ut.dummy.sta_list) == NULL);
+    assert(ut.n_phy_fini == 3);
+    assert(ut.n_vif_fini == 3);
+    assert(ut.n_sta_fini == 3);
+    osw_drv_dummy_set_phy(&ut.dummy, "phy1", NULL);
+    osw_drv_dummy_set_vif(&ut.dummy, "phy1", "vif1", NULL);
+    osw_drv_dummy_set_sta(&ut.dummy, "phy1", "vif1", &sta1_addr, NULL);
+    assert(ds_tree_head(&ut.dummy.phy_tree) == NULL);
+    assert(ds_tree_head(&ut.dummy.vif_tree) == NULL);
+    assert(ds_dlist_head(&ut.dummy.sta_list) == NULL);
+    assert(ut.n_phy_fini == 3);
+    assert(ut.n_vif_fini == 3);
+    assert(ut.n_sta_fini == 3);
+}
+
+static void
+osw_drv_dummy_ut_module_init(void *data)
+{
+    osw_ut_register("osw_drv_dummy_ut_1", osw_drv_dummy_ut_1_cb, NULL);
+}
+
+static void
+osw_drv_dummy_ut_module_fini(void *data)
+{
+}
+
+MODULE(osw_drv_dummy_ut_module,
+       osw_drv_dummy_ut_module_init,
+       osw_drv_dummy_ut_module_fini);
Index: device-core/src/lib/osw/src/osw_drv_i.h
===================================================================
--- /dev/null
+++ device-core/src/lib/osw/src/osw_drv_i.h
@@ -0,0 +1,92 @@
+#ifndef OSW_DRV_I_H
+#define OSW_DRV_I_H
+
+#include <ds_dlist.h>
+#include <ds_tree.h>
+#include <ev.h>
+#include <osw_drv.h>
+#include "osw_state_i.h"
+
+enum osw_drv_obj_state {
+    OSW_DRV_OBJ_INVALID,
+    OSW_DRV_OBJ_REQUESTED,
+    OSW_DRV_OBJ_VALID,
+    OSW_DRV_OBJ_PROCESSED,
+};
+
+struct osw_drv_obj {
+    enum osw_drv_obj_state state;
+    bool existed;
+    bool exists;
+};
+
+struct osw_drv {
+    const struct osw_drv_ops *ops;
+    void *priv;
+
+    bool initialized;
+    bool unregistered;
+
+    struct ds_tree_node node;
+    struct ds_tree phy_tree;
+    ev_async work_async;
+    bool phy_list_valid; // FIXME
+};
+
+struct osw_drv_phy {
+    char *phy_name;
+    struct osw_drv *drv;
+    struct ds_tree_node node;
+    struct ds_tree vif_tree;
+    struct osw_state_phy_info pub; // FIXME
+    struct osw_drv_obj obj;
+    struct osw_drv_phy_state cur_state;
+    struct osw_drv_phy_state new_state;
+    bool vif_list_valid;
+};
+
+struct osw_drv_vif {
+    char *vif_name;
+    struct osw_drv_phy *phy;
+    struct ds_tree_node node;
+    struct ds_tree sta_tree;
+    struct osw_state_vif_info pub; // FIXME
+    struct osw_drv_obj obj;
+    struct osw_drv_vif_state cur_state;
+    struct osw_drv_vif_state new_state;
+    struct osw_channel csa_channel;
+    bool sta_list_valid;
+    ev_timer chan_sync; /* used for CSA state invalidation */
+};
+
+struct osw_drv_sta {
+    struct osw_hwaddr mac_addr;
+    struct osw_drv_vif *vif;
+    struct ds_tree_node node;
+    struct osw_state_sta_info pub; // FIXME
+    struct osw_drv_obj obj;
+    struct osw_drv_sta_state cur_state;
+    struct osw_drv_sta_state new_state;
+};
+
+extern struct ds_tree g_osw_drv_tree;
+
+void
+osw_drv_work_all_schedule(void);
+
+bool
+osw_drv_work_is_settled(void);
+
+void
+osw_drv_init(void);
+
+void
+osw_drv_unregister_all(void);
+
+void
+osw_drv_set_chan_sync(struct osw_drv *drv, const struct osw_drv_conf *conf);
+
+bool
+osw_drv_conf_changed(const struct osw_drv_conf *drv_conf);
+
+#endif
Index: device-core/src/lib/osw/src/osw_drv_target.c
===================================================================
--- /dev/null
+++ device-core/src/lib/osw/src/osw_drv_target.c
@@ -0,0 +1,1816 @@
+#include <libgen.h>
+#include <osw_drv.h>
+#include <osw_drv_dummy.h>
+#include <osw_state.h>
+#include <osw_ut.h>
+#include <target.h>
+#include <module.h>
+#include <memutil.h>
+#include <ovsdb_table.h>
+#include <ovsdb_cache.h>
+
+static ovsdb_table_t table_Wifi_Radio_Config;
+static ovsdb_table_t table_Wifi_Radio_State;
+static ovsdb_table_t table_Wifi_VIF_Config;
+
+struct osw_drv_target;
+
+struct osw_drv_target_phy {
+    struct ds_tree_node node;
+    struct schema_Wifi_Radio_State rstate;
+};
+
+struct osw_drv_target_vif {
+    struct ds_tree_node node;
+    struct osw_drv_target *target;
+    struct schema_Wifi_VIF_Config config;
+    struct schema_Wifi_VIF_State state;
+    char *vif_name;
+    char *phy_name;
+    bool exists;
+    ev_timer work;
+};
+
+struct osw_drv_target {
+    struct osw_drv_dummy dummy;
+    struct osw_drv *drv;
+    struct ds_tree phy_tree;
+    struct ds_tree vif_tree;
+    struct osw_drv_conf *conf;
+    size_t conf_phy;
+    size_t conf_vif;
+    bool conf_phy_done;
+    ev_timer conf_timer;
+    ev_timer ovsdb_retry;
+};
+
+static void
+osw_drv_target_init_cb(struct osw_drv *drv);
+static void
+osw_drv_target_request_config_cb(struct osw_drv *drv,
+                                 struct osw_drv_conf *conf);
+
+static bool
+osw_drv_target_enabled(void)
+{
+    if (getenv("OSW_DRV_TARGET_DISABLED") == NULL)
+        return true;
+    else
+        return false;
+}
+
+static void
+osw_drv_target_fini_phy_cb(struct osw_drv_dummy *dummy,
+                           struct osw_drv_phy_state *phy)
+{
+    FREE(phy->channel_states);
+    phy->channel_states = NULL;
+    phy->n_channel_states = 0;
+}
+
+static void
+osw_drv_target_fini_vif_cb(struct osw_drv_dummy *dummy,
+                           struct osw_drv_vif_state *vif)
+{
+    FREE(vif->u.ap.acl.list);
+    FREE(vif->u.ap.psk_list.list);
+    vif->u.ap.acl.list = NULL;
+    vif->u.ap.acl.count = 0;
+    vif->u.ap.psk_list.list = NULL;
+    vif->u.ap.psk_list.count = 0;
+}
+
+
+static struct osw_drv_target g_osw_drv_target = {
+    .dummy = {
+        .name = "target (legacy)",
+        .init_fn = osw_drv_target_init_cb,
+        .fini_phy_fn = osw_drv_target_fini_phy_cb,
+        .fini_vif_fn = osw_drv_target_fini_vif_cb,
+        .request_config_fn = osw_drv_target_request_config_cb,
+    },
+    .phy_tree = DS_TREE_INIT(ds_str_cmp, struct osw_drv_target_phy, node),
+    .vif_tree = DS_TREE_INIT(ds_str_cmp, struct osw_drv_target_vif, node),
+};
+
+static int
+osw_drv_target_ch2freq(int band_num, int chan)
+{
+    switch (band_num) {
+        case 2: return 2407 + (chan * 5);
+        case 5: return 5000 + (chan * 5);
+        case 6: if (chan == 2) return 5935;
+                else return 5950 + (chan * 5);
+    }
+    return 0;
+}
+
+static int
+osw_drv_target_band2num(const char *freq_band)
+{
+    return strcmp(freq_band, "5G") == 0 ? 5 :
+           strcmp(freq_band, "5GL") == 0 ? 5 :
+           strcmp(freq_band, "5GU") == 0 ? 5 :
+           strcmp(freq_band, "6G") == 0 ? 6 :
+           2;
+}
+
+static enum osw_acl_policy
+osw_drv_target_type2policy(const char *type)
+{
+    return strcmp(type, "none") == 0 ? OSW_ACL_NONE :
+           strcmp(type, "whitelist") == 0 ? OSW_ACL_ALLOW_LIST :
+           strcmp(type, "blacklist") == 0 ? OSW_ACL_DENY_LIST :
+           OSW_ACL_NONE;
+}
+
+static enum osw_channel_width
+osw_drv_target_htmode2width(const char *ht_mode)
+{
+    return strcmp(ht_mode, "HT20") == 0 ? OSW_CHANNEL_20MHZ :
+           strcmp(ht_mode, "HT40") == 0 ? OSW_CHANNEL_40MHZ :
+           strcmp(ht_mode, "HT80") == 0 ? OSW_CHANNEL_80MHZ :
+           strcmp(ht_mode, "HT160") == 0 ? OSW_CHANNEL_160MHZ :
+           OSW_CHANNEL_20MHZ;
+}
+
+static int
+osw_drv_target_str2keyid(const char *key_id)
+{
+    int i;
+    if (strcmp(key_id, "key") == 0)
+        return 0;
+    if (sscanf(key_id, "key-%d", &i) == 1)
+        return i;
+    return -1;
+}
+
+static void
+osw_drv_target_keyid2str(char *buf, const size_t len, const int key_id)
+{
+    if (key_id == 0)
+        snprintf(buf, len, "key");
+    else
+        snprintf(buf, len, "key-%d", key_id);
+}
+
+static void
+osw_drv_target_phyconf2schema(const struct osw_drv_phy_config *phy,
+                              const struct osw_state_phy_info *info,
+                              const struct schema_Wifi_Radio_Config *base_rconf,
+                              struct schema_Wifi_Radio_Config *rconf,
+                              struct schema_Wifi_Radio_Config_flags *rchanged)
+{
+    const struct osw_channel *c = NULL;
+    const int *beacon_interval_tu = NULL;
+    size_t i;
+    bool channel_changed = false;
+    bool mode_changed = false;
+    bool beacon_interval_tu_changed = false;
+    bool ht = false;
+    bool vht = false;
+    bool he = false;
+
+    SCHEMA_SET_STR(rconf->if_name, phy->phy_name);
+    SCHEMA_SET_BOOL(rconf->enabled, phy->enabled);
+    SCHEMA_SET_INT(rconf->tx_chainmask, phy->tx_chainmask);
+
+    switch (phy->radar) {
+        case OSW_RADAR_UNSUPPORTED: break;
+        case OSW_RADAR_DETECT_ENABLED: SCHEMA_SET_BOOL(rconf->dfs_demo, false); break;
+        case OSW_RADAR_DETECT_DISABLED: SCHEMA_SET_BOOL(rconf->dfs_demo, true); break;
+    }
+
+    for (i = 0; i < phy->vif_list.count; i++) {
+        struct osw_drv_vif_config *vif = &phy->vif_list.list[i];
+        if (vif->vif_type != OSW_VIF_AP) continue;
+        if (vif->enabled == false) continue;
+        channel_changed |= vif->u.ap.channel_changed;
+        if (c == NULL) c = &vif->u.ap.channel;
+        if (memcmp(c, &vif->u.ap.channel, sizeof(*c)) == 0) continue;
+        c = NULL;
+        break;
+    }
+
+    if (c != NULL) {
+        const int b2ch1 = 2412;
+        const int b2ch13 = 2472;
+        const int b2ch14 = 2484;
+        const int b5ch36 = 5180;
+        const int b5ch177 = 5885;
+        const int b6ch1 = 5955;
+        const int b6ch2 = 5935;
+        const int b6ch233 = 7115;
+
+        switch (c->width) {
+            case OSW_CHANNEL_20MHZ: SCHEMA_SET_STR(rconf->ht_mode, "HT20"); break;
+            case OSW_CHANNEL_40MHZ: SCHEMA_SET_STR(rconf->ht_mode, "HT40"); break;
+            case OSW_CHANNEL_80MHZ: SCHEMA_SET_STR(rconf->ht_mode, "HT80"); break;
+            case OSW_CHANNEL_160MHZ: SCHEMA_SET_STR(rconf->ht_mode, "HT160"); break;
+            case OSW_CHANNEL_80P80MHZ: break;
+        }
+        if (c->control_freq_mhz >= b2ch1 && c->control_freq_mhz <= b2ch13) {
+            SCHEMA_SET_INT(rconf->channel, (c->control_freq_mhz - 2407) / 5);
+            SCHEMA_SET_STR(rconf->freq_band, "2.4G");
+        }
+        else if (c->control_freq_mhz == b2ch14) {
+            SCHEMA_SET_INT(rconf->channel, 14);
+            SCHEMA_SET_STR(rconf->freq_band, "2.4G");
+        }
+        else if (c->control_freq_mhz >= b5ch36 && c->control_freq_mhz <= b5ch177) {
+            SCHEMA_SET_INT(rconf->channel, (c->control_freq_mhz - 5000) / 5);
+            SCHEMA_SET_STR(rconf->freq_band, "5G");
+
+            /* FIXME: This is a hack. Driver should not be reading it's own
+             * states like this. This is a compatibility layer so this is
+             * acceptable.
+             */
+            if (info != NULL) {
+                const struct osw_channel_state *cs = info->drv_state->channel_states;
+                const size_t n = info->drv_state->n_channel_states;
+                const int high_5gl = 5000 + (5 * 64);
+                const int low_5gu = 5000 + (5 * 100);
+                bool has_5gl = false;
+                bool has_5gu = false;
+                for (i = 0; i < n; i++) {
+                    if (cs[i].channel.control_freq_mhz <= high_5gl)
+                        has_5gl = true;
+                    if (cs[i].channel.control_freq_mhz >= low_5gu)
+                        has_5gu = true;
+                }
+                if (has_5gl != has_5gu)
+                    SCHEMA_SET_STR(rconf->freq_band, has_5gl ? "5GL" : "5GU");
+            }
+        }
+        else if (c->control_freq_mhz == b6ch2) {
+            SCHEMA_SET_INT(rconf->channel, 2);
+            SCHEMA_SET_STR(rconf->freq_band, "6G");
+        }
+        else if (c->control_freq_mhz >= b6ch1 && c->control_freq_mhz <= b6ch233) {
+            SCHEMA_SET_INT(rconf->channel, (c->control_freq_mhz - 5950) / 5);
+            SCHEMA_SET_STR(rconf->freq_band, "6G");
+        }
+    }
+
+    for (i = 0; i < phy->vif_list.count; i++) {
+        struct osw_drv_vif_config *vif = &phy->vif_list.list[i];
+        if (vif->vif_type != OSW_VIF_AP) continue;
+        mode_changed |= vif->u.ap.mode_changed;
+        ht |= vif->u.ap.mode.ht_enabled;
+        vht |= vif->u.ap.mode.vht_enabled;
+        he |= vif->u.ap.mode.he_enabled;
+    }
+
+    if (he == true)
+        SCHEMA_SET_STR(rconf->hw_mode, "11ax");
+    else if (vht == true)
+        SCHEMA_SET_STR(rconf->hw_mode, "11ac");
+    else if (ht == true)
+        SCHEMA_SET_STR(rconf->hw_mode, "11n");
+    else if (strcmp(rconf->freq_band, "2.4G") == 0)
+        SCHEMA_SET_STR(rconf->hw_mode, "11g");
+    else if (strcmp(rconf->freq_band, "5G") == 0)
+        SCHEMA_SET_STR(rconf->hw_mode, "11a");
+    else if (strcmp(rconf->freq_band, "5GU") == 0)
+        SCHEMA_SET_STR(rconf->hw_mode, "11a");
+    else if (strcmp(rconf->freq_band, "5GL") == 0)
+        SCHEMA_SET_STR(rconf->hw_mode, "11a");
+    else if (strcmp(rconf->freq_band, "6G") == 0)
+        SCHEMA_SET_STR(rconf->hw_mode, "11a");
+
+    for (i = 0; i < phy->vif_list.count; i++) {
+        struct osw_drv_vif_config *vif = &phy->vif_list.list[i];
+        if (vif->vif_type != OSW_VIF_AP) continue;
+        if (vif->enabled == false) continue;
+        beacon_interval_tu_changed |= vif->u.ap.beacon_interval_tu_changed;
+        if (beacon_interval_tu == NULL) beacon_interval_tu = &vif->u.ap.beacon_interval_tu;
+        if (vif->u.ap.beacon_interval_tu == *beacon_interval_tu) continue;
+        beacon_interval_tu = NULL;
+        break;
+    }
+
+    if (beacon_interval_tu != NULL && *beacon_interval_tu > 0) {
+        SCHEMA_SET_INT(rconf->bcn_int, *beacon_interval_tu);
+    }
+
+    rchanged->enabled = phy->enabled_changed;
+    rchanged->tx_chainmask = phy->tx_chainmask_changed;
+    rchanged->dfs_demo = phy->radar_changed;
+    rchanged->channel = channel_changed;
+    rchanged->freq_band = channel_changed;
+    rchanged->ht_mode = channel_changed;
+    rchanged->hw_mode = mode_changed;
+    rchanged->bcn_int = beacon_interval_tu_changed;
+
+    if (base_rconf != NULL) {
+        SCHEMA_CPY_STR(rconf->hw_type, base_rconf->hw_type);
+        SCHEMA_CPY_MAP(rconf->hw_config, base_rconf->hw_config);
+        /* FIXME: No way to know whether it has changed or not */
+    }
+
+
+    /* FIXME
+       tx_power
+       country
+       zero_wait_dfs
+
+       channel_sync
+       vif_configs
+       thermal_shutdown
+       thermal_downgrade_temp
+       thermal_upgrade_temp
+       thermal_integration
+       temperature_control
+       thermal_tx_chainmask
+       fallback_parents
+     */
+}
+
+static void
+osw_drv_target_vifconf2schema(struct osw_drv_vif_config *vif,
+                              const struct schema_Wifi_VIF_Config *base_vconf,
+                              struct schema_Wifi_VIF_Config *vconf,
+                              struct schema_Wifi_VIF_Config_flags *vchanged,
+                              struct schema_Wifi_Credential_Config *cconfs,
+                              int *n_cconfs)
+{
+    struct osw_drv_vif_config_ap *ap = &vif->u.ap;
+    struct osw_hwaddr_str mac_str;
+    size_t i;
+
+    SCHEMA_SET_STR(vconf->if_name, vif->vif_name);
+    SCHEMA_SET_BOOL(vconf->enabled, vif->enabled);
+
+    vchanged->enabled = vif->enabled_changed;
+
+    /* FIXME: vif_radio_idx needs to be taken from real
+     * ovsdb, it is nowhere to be found, and will nowhere to
+     * be found in OSW.
+     */
+
+    switch (vif->vif_type) {
+        case OSW_VIF_UNDEFINED:
+            break;
+        case OSW_VIF_AP:
+            ap->ssid.buf[ap->ssid.len] = 0; /* sanity */
+            SCHEMA_SET_STR(vconf->mode, "ap");
+            SCHEMA_SET_STR(vconf->ssid, ap->ssid.buf);
+            SCHEMA_SET_STR(vconf->bridge, ap->bridge_if_name.buf);
+            SCHEMA_SET_STR(vconf->ssid_broadcast, ap->ssid_hidden ? "disabled" : "enabled");
+            switch (ap->acl_policy) {
+                case OSW_ACL_NONE: SCHEMA_SET_STR(vconf->mac_list_type, "none"); break;
+                case OSW_ACL_ALLOW_LIST: SCHEMA_SET_STR(vconf->mac_list_type, "whitelist"); break;
+                case OSW_ACL_DENY_LIST: SCHEMA_SET_STR(vconf->mac_list_type, "blacklist"); break;
+            }
+            SCHEMA_SET_BOOL(vconf->ap_bridge, ap->isolated ? false : true);
+            SCHEMA_SET_BOOL(vconf->mcast2ucast, ap->mcast2ucast);
+            for (i = 0; i < ap->acl.count; i++) {
+                SCHEMA_VAL_APPEND(vconf->mac_list,
+                                  osw_hwaddr2str(&ap->acl.list[i], &mac_str));
+            }
+            for (i = 0; i < ap->psk_list.count; i++) {
+                const struct osw_ap_psk *psk = &ap->psk_list.list[i];
+                char key_id[64];
+                osw_drv_target_keyid2str(key_id, sizeof(key_id), psk->key_id);
+                SCHEMA_KEY_VAL_SET(vconf->wpa_psks, key_id, psk->psk.str);
+            }
+            SCHEMA_SET_BOOL(vconf->btm, ap->mode.wnm_bss_trans);
+            SCHEMA_SET_BOOL(vconf->rrm, ap->mode.rrm_neighbor_report);
+            SCHEMA_SET_BOOL(vconf->uapsd_enable, ap->mode.wmm_uapsd_enabled);
+            SCHEMA_SET_BOOL(vconf->wps, ap->mode.wps);
+            SCHEMA_SET_BOOL(vconf->wpa, ap->wpa.wpa || ap->wpa.rsn);
+            SCHEMA_SET_INT(vconf->ft_mobility_domain, ap->wpa.ft_mobility_domain);
+            if (ap->wpa.group_rekey_seconds >= 0) {
+                SCHEMA_SET_INT(vconf->group_rekey, ap->wpa.group_rekey_seconds);
+            }
+            if (ap->wpa.wpa) {
+                if (ap->wpa.akm_psk) SCHEMA_VAL_APPEND(vconf->wpa_key_mgmt, "wpa-psk");
+                WARN_ON(ap->wpa.akm_sae == true);
+            }
+            if (ap->wpa.rsn) {
+                if (ap->wpa.akm_psk) SCHEMA_VAL_APPEND(vconf->wpa_key_mgmt, "wpa2-psk");
+                if (ap->wpa.akm_sae) SCHEMA_VAL_APPEND(vconf->wpa_key_mgmt, "sae");
+            }
+
+            // FIXME: pairwise_tkip/ccmp, pmf, ft, 802.1x, dpp
+
+            vchanged->mode = vif->vif_type_changed;
+            vchanged->ssid = ap->ssid_changed;
+            vchanged->bridge = ap->bridge_if_name_changed;
+            vchanged->ssid_broadcast = ap->ssid_hidden_changed;
+            vchanged->ap_bridge = ap->isolated_changed;
+            vchanged->mac_list_type = ap->acl_policy_changed;
+            vchanged->mcast2ucast = ap->mcast2ucast_changed;
+            vchanged->mac_list = ap->acl_changed;
+            vchanged->wpa_psks = ap->psk_list_changed;
+            vchanged->btm = ap->mode_changed;
+            vchanged->rrm = ap->mode_changed;
+            vchanged->uapsd_enable = ap->mode_changed;
+            vchanged->wps = ap->mode_changed;
+            vchanged->wpa = ap->wpa_changed;
+            vchanged->wpa_key_mgmt = ap->wpa_changed;
+            vchanged->ft_mobility_domain = ap->wpa_changed;
+            vchanged->group_rekey = ap->wpa_changed;
+
+            if (base_vconf != NULL) {
+                if (base_vconf->vif_radio_idx_exists == true) {
+                    SCHEMA_SET_INT(vconf->vif_radio_idx, base_vconf->vif_radio_idx);
+                    /* FIXME: Unfortunately it's impossible to tell whether
+                     * vif_radio_idx has been applied or not, so it's
+                     * impossible to tell if it has changed or not.
+                     */
+                }
+            }
+
+            /* FIXME
+               parent
+               vif_dbg_lvl
+               wds
+               security
+               credential_configs
+               vlan_id
+               min_hw_mode
+               ft_psk
+               dynamic_beacon
+               multi_ap
+               wps_pbc
+               wps_pbc_key_id
+               wpa_oftags
+               radius_srv_addr
+               radius_srv_port
+               radius_srv_secret
+               default_oftag
+               dpp_connector
+               dpp_csign_hex
+               dpp_netaccesskey_hex
+               dpp_cc
+               min_rssi
+               max_sta
+               passpoint_hessid
+               airtime_precedence
+             */
+            break;
+        case OSW_VIF_AP_VLAN:
+            SCHEMA_SET_STR(vconf->mode, "ap_vlan");
+            /* XXX: This isn't expected to be supported any
+             * time soon. These interfaces are expected to
+             * be only spawned by the underlying driver via
+             * state reports for Multi AP purposes.
+             */
+            break;
+        case OSW_VIF_STA:
+            SCHEMA_SET_STR(vconf->mode, "sta");
+            /* FIXME: First phase is getting GW/AP-only
+             * working. STA operation needs to wait.
+             */
+            break;
+    }
+}
+
+static void
+osw_drv_target_cs_append(struct osw_channel_state **cs,
+                         size_t *n_cs,
+                         const int freq,
+                         const enum osw_channel_state_dfs dfs_state)
+{
+    int last = *n_cs;
+    (*n_cs)++;
+    *cs = REALLOC(*cs, *n_cs * sizeof(**cs));
+    memset(&(*cs)[last], 0, sizeof(**cs));
+    (*cs)[last].channel.control_freq_mhz = freq;
+    (*cs)[last].dfs_state = dfs_state;
+}
+
+static struct osw_channel_state *
+osw_drv_target_cs_lookup(struct osw_channel_state *base,
+                         size_t n,
+                         int freq)
+{
+    while (n--) {
+        if (base->channel.control_freq_mhz == freq)
+            return base;
+        base++;
+    }
+    return NULL;
+}
+
+static enum osw_channel_state_dfs
+osw_drv_target_str_to_dfs_state(const char *str)
+{
+    if (strstr(str, "allowed") != NULL) return OSW_CHANNEL_NON_DFS;
+    if (strstr(str, "nop_finished") != NULL) return OSW_CHANNEL_DFS_CAC_POSSIBLE;
+    if (strstr(str, "nop_started") != NULL) return OSW_CHANNEL_DFS_NOL;
+    if (strstr(str, "cac_started") != NULL) return OSW_CHANNEL_DFS_CAC_IN_PROGRESS;
+    if (strstr(str, "cac_completed") != NULL) return OSW_CHANNEL_DFS_CAC_COMPLETED;
+    return OSW_CHANNEL_NON_DFS;
+}
+
+static void
+osw_drv_target_schema2phystate(const struct schema_Wifi_Radio_State *rstate,
+                               struct osw_drv_phy_state *info)
+{
+    int band_num = osw_drv_target_band2num(rstate->freq_band);
+    int i;
+
+    info->exists = true;
+    info->enabled = rstate->enabled;
+    info->tx_chainmask = rstate->tx_chainmask;
+    if (rstate->dfs_demo_exists) {
+        info->radar = rstate->dfs_demo == true
+                    ? OSW_RADAR_DETECT_DISABLED
+                    : OSW_RADAR_DETECT_ENABLED;
+    }
+    sscanf(rstate->mac, "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
+           &info->mac_addr.octet[0],
+           &info->mac_addr.octet[1],
+           &info->mac_addr.octet[2],
+           &info->mac_addr.octet[3],
+           &info->mac_addr.octet[4],
+           &info->mac_addr.octet[5]);
+
+    for (i = 0; i < rstate->channels_len; i++) {
+        const int ch = atoi(rstate->channels_keys[i]);
+        const int freq = osw_drv_target_ch2freq(band_num, ch);
+        const char *str = rstate->channels[i];
+        const enum osw_channel_state_dfs dfs_state = osw_drv_target_str_to_dfs_state(str);
+
+        osw_drv_target_cs_append(&info->channel_states,
+                                 &info->n_channel_states,
+                                 freq,
+                                 dfs_state);
+    }
+
+    for (i = 0; i < rstate->allowed_channels_len; i++) {
+        const int ch = rstate->allowed_channels[i];
+        const int freq = osw_drv_target_ch2freq(band_num, ch);
+        const enum osw_channel_state_dfs dfs_state = OSW_CHANNEL_NON_DFS;
+
+        if (osw_drv_target_cs_lookup(info->channel_states,
+                                     info->n_channel_states,
+                                     freq) != NULL) continue;
+
+        osw_drv_target_cs_append(&info->channel_states,
+                                 &info->n_channel_states,
+                                 freq,
+                                 dfs_state);
+    }
+}
+
+static void
+osw_drv_target_schema2vifstate(const struct schema_Wifi_VIF_State *vstate,
+                               const struct schema_Wifi_Radio_State *rstate,
+                               struct osw_drv_vif_state *info)
+{
+    info->enabled = vstate->enabled;
+    info->vif_type = strcmp(vstate->mode, "ap") == 0 ? OSW_VIF_AP :
+                     strcmp(vstate->mode, "ap_vlan") == 0 ? OSW_VIF_AP_VLAN :
+                     strcmp(vstate->mode, "sta") == 0 ? OSW_VIF_STA :
+                     OSW_VIF_UNDEFINED;
+    sscanf(vstate->mac, "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
+           &info->mac_addr.octet[0],
+           &info->mac_addr.octet[1],
+           &info->mac_addr.octet[2],
+           &info->mac_addr.octet[3],
+           &info->mac_addr.octet[4],
+           &info->mac_addr.octet[5]);
+
+    switch (info->vif_type) {
+        case OSW_VIF_UNDEFINED:
+            break;
+        case OSW_VIF_AP:
+            STRSCPY_WARN(info->u.ap.bridge_if_name.buf, vstate->bridge);
+            STRSCPY_WARN(info->u.ap.ssid.buf, vstate->ssid);
+            info->u.ap.ssid.len = strlen(vstate->ssid);
+            info->u.ap.beacon_interval_tu = rstate->bcn_int;
+            info->u.ap.isolated = vstate->ap_bridge == true ? false : true;
+            info->u.ap.mcast2ucast = vstate->mcast2ucast;
+            info->u.ap.acl_policy = osw_drv_target_type2policy(vstate->mac_list_type);
+            info->u.ap.ssid_hidden = strcmp(vstate->ssid_broadcast, "enabled") == 0 ? false :
+                                     strcmp(vstate->ssid_broadcast, "disabled") == 0 ? true :
+                                     false;
+            info->u.ap.mode.wnm_bss_trans = vstate->btm;
+            info->u.ap.mode.rrm_neighbor_report = vstate->rrm;
+            info->u.ap.mode.wmm_enabled = true;
+            info->u.ap.mode.wmm_uapsd_enabled = vstate->uapsd_enable;
+            info->u.ap.mode.wps = vstate->wps;
+            if (strcmp(rstate->hw_mode, "11ax") == 0) {
+                info->u.ap.mode.ht_enabled = true;
+                info->u.ap.mode.vht_enabled = true;
+                info->u.ap.mode.he_enabled = true;
+            }
+            else if (strcmp(rstate->hw_mode, "11ac") == 0) {
+                info->u.ap.mode.ht_enabled = true;
+                info->u.ap.mode.vht_enabled = true;
+            }
+            else if (strcmp(rstate->hw_mode, "11n") == 0) {
+                info->u.ap.mode.ht_enabled = true;
+            }
+            if (strcmp(rstate->freq_band, "6G") == 0) {
+                info->u.ap.mode.ht_enabled = false;
+                info->u.ap.mode.vht_enabled = false;
+            }
+            if (vstate->channel_exists) {
+                int band_num = osw_drv_target_band2num(rstate->freq_band);
+                info->u.ap.channel.control_freq_mhz = osw_drv_target_ch2freq(band_num, vstate->channel);
+                info->u.ap.channel.width = osw_drv_target_htmode2width(rstate->ht_mode);
+                /* FIXME: derive center_freq0_mhz */
+            }
+            info->u.ap.wpa.group_rekey_seconds = vstate->group_rekey_exists == true
+                                               ? vstate->group_rekey
+                                               : OSW_WPA_GROUP_REKEY_UNDEFINED;
+            info->u.ap.wpa.ft_mobility_domain = vstate->ft_mobility_domain;
+            if (vstate->wpa) {
+                int i;
+                for (i = 0; i < vstate->wpa_key_mgmt_len; i++) {
+                    if (strcmp(vstate->wpa_key_mgmt[i], "wpa-psk") == 0) {
+                        info->u.ap.wpa.wpa = true;
+                        info->u.ap.wpa.akm_psk = true;
+                        info->u.ap.wpa.pairwise_tkip = true;
+                    }
+                    if (strcmp(vstate->wpa_key_mgmt[i], "wpa2-psk") == 0) {
+                        info->u.ap.wpa.rsn = true;
+                        info->u.ap.wpa.akm_psk = true;
+                        info->u.ap.wpa.pairwise_ccmp = true;
+                    }
+                    if (strcmp(vstate->wpa_key_mgmt[i], "sae") == 0) {
+                        info->u.ap.wpa.rsn = true;
+                        info->u.ap.wpa.akm_sae = true;
+                        info->u.ap.wpa.pairwise_ccmp = true;
+                    }
+                    if (strstr(vstate->wpa_key_mgmt[i], "ft-wpa") != NULL) {
+                        info->u.ap.wpa.akm_ft_psk = true;
+                    }
+                    if (strcmp(vstate->wpa_key_mgmt[i], "ft-sae") == 0) {
+                        info->u.ap.wpa.akm_ft_sae = true;
+                    }
+                }
+
+                /* FIXME: This will need to change eventually because PMF will
+                 * be configurable explicitly in the future.  Also for 802.1X /
+                 * WPA3-Enterprise. That'll come later though.
+                 */
+                bool need_11w = info->u.ap.wpa.akm_sae ||
+                                info->u.ap.wpa.akm_ft_sae;
+                bool non_11w = info->u.ap.wpa.akm_psk ||
+                               info->u.ap.wpa.akm_ft_psk;
+
+               if (need_11w == false)
+                    info->u.ap.wpa.pmf = OSW_PMF_DISABLED;
+               else if (non_11w == true) /* wpa3 transition */
+                    info->u.ap.wpa.pmf = OSW_PMF_OPTIONAL;
+               else /* wpa3 only */
+                    info->u.ap.wpa.pmf = OSW_PMF_REQUIRED;
+            }
+            if (vstate->mac_list_len > 0) {
+                int i;
+                info->u.ap.acl.count = vstate->mac_list_len;
+                info->u.ap.acl.list = CALLOC(vstate->mac_list_len, sizeof(*info->u.ap.acl.list));
+                for (i = 0; i < vstate->mac_list_len; i++) {
+                    sscanf(vstate->mac_list[i], "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
+                           &info->u.ap.acl.list[i].octet[0],
+                           &info->u.ap.acl.list[i].octet[1],
+                           &info->u.ap.acl.list[i].octet[2],
+                           &info->u.ap.acl.list[i].octet[3],
+                           &info->u.ap.acl.list[i].octet[4],
+                           &info->u.ap.acl.list[i].octet[5]);
+                }
+            }
+            if (vstate->wpa_psks_len > 0) {
+                struct osw_ap_psk_list *psks = &info->u.ap.psk_list;
+                int i;
+                psks->count = vstate->wpa_psks_len;
+                psks->list = CALLOC(psks->count, sizeof(*psks->list));
+                for (i = 0; i < vstate->wpa_psks_len; i++) {
+                    const char *key_id = vstate->wpa_psks_keys[i];
+                    psks->list[i].key_id = osw_drv_target_str2keyid(key_id);
+                    STRSCPY_WARN(psks->list[i].psk.str, vstate->wpa_psks[i]);
+                }
+            }
+            /* FIXME: use schema_consts */
+
+            // radius_list
+            #if 0
+            if (strcmp(rstate->min_hw_mode, "11n") == 0) {
+                info->u.ap.mode.ht_required = true;
+            else if (strcmp(rstate->min_hw_mode, "11ac") == 0) {
+                info->u.ap.mode.ht_required = true;
+                info->u.ap.mode.vht_required = true;
+            }
+            #endif
+            break;
+        case OSW_VIF_AP_VLAN:
+            break;
+        case OSW_VIF_STA:
+            break;
+    }
+}
+
+static void
+osw_drv_target_phy_set(struct osw_drv_target *priv,
+                       struct osw_drv_phy_config *phy)
+{
+    struct schema_Wifi_Radio_Config base_rconf = {0};
+    struct schema_Wifi_Radio_Config rconf = {0};
+    struct schema_Wifi_Radio_Config_flags rchanged = {0};
+    const struct osw_state_phy_info *info = osw_state_phy_lookup(phy->phy_name);
+
+    ovsdb_table_select_one(&table_Wifi_Radio_Config,
+                           SCHEMA_COLUMN(Wifi_Radio_Config, if_name),
+                           phy->phy_name,
+                           &base_rconf);
+
+    osw_drv_target_phyconf2schema(phy, info, &base_rconf, &rconf, &rchanged);
+    target_radio_config_set2(&rconf, &rchanged);
+}
+
+static void
+osw_drv_target_vif_set(struct osw_drv_target *priv,
+                       struct osw_drv_phy_config *phy,
+                       struct osw_drv_vif_config *vif)
+{
+    struct schema_Wifi_VIF_Config base_vconf = {0};
+    struct schema_Wifi_VIF_Config vconf = {0};
+    struct schema_Wifi_VIF_Config_flags vchanged = {0};
+    struct schema_Wifi_Radio_Config base_rconf = {0};
+    struct schema_Wifi_Radio_Config rconf = {0};
+    struct schema_Wifi_Radio_Config_flags rchanged = {0};
+    struct schema_Wifi_Credential_Config cconfs[8] = {0};
+    int n_cconfs = ARRAY_SIZE(cconfs);
+    const struct osw_state_phy_info *info = osw_state_phy_lookup(phy->phy_name);
+
+    ovsdb_table_select_one(&table_Wifi_Radio_Config,
+                           SCHEMA_COLUMN(Wifi_Radio_Config, if_name),
+                           phy->phy_name,
+                           &base_rconf);
+
+    ovsdb_table_select_one(&table_Wifi_VIF_Config,
+                           SCHEMA_COLUMN(Wifi_VIF_Config, if_name),
+                           vif->vif_name,
+                           &base_vconf);
+
+    osw_drv_target_phyconf2schema(phy, info, &base_rconf, &rconf, &rchanged);
+    osw_drv_target_vifconf2schema(vif, &base_vconf, &vconf, &vchanged, cconfs, &n_cconfs);
+    target_vif_config_set2(&vconf, &rconf, cconfs, &vchanged, n_cconfs);
+}
+
+static const char *
+osw_drv_target_vconf_lookup_phy(const ovs_uuid_t *uuid)
+{
+    ovsdb_cache_row_t *row;
+    int i;
+
+    ds_tree_foreach(&table_Wifi_Radio_Config.rows, row) {
+        const struct schema_Wifi_Radio_Config *rconf = (const void *)row->record;
+        for (i = 0; i < rconf->vif_configs_len; i++) {
+            if (strcmp(rconf->vif_configs[i].uuid, uuid->uuid) == 0)
+                return rconf->if_name;
+        }
+    }
+
+    return NULL;
+}
+
+static bool
+osw_drv_target_vif_get_exists(const struct osw_drv_target_vif *vif)
+{
+    return vif->exists == true || vif->state.enabled == true;
+}
+
+static const char *
+osw_drv_target_vif_get_phy_name(const struct osw_drv_target_vif *vif)
+{
+    if (vif->phy_name != NULL) return vif->phy_name;
+    return osw_drv_target_vconf_lookup_phy(&vif->config._uuid);
+}
+
+static void
+osw_drv_target_vif_gc(struct osw_drv_target_vif *vif)
+{
+    struct ds_tree *tree = &vif->target->vif_tree;
+
+    if (osw_drv_target_vif_get_exists(vif) == true) return;
+
+    ds_tree_remove(tree, vif);
+    FREE(vif->vif_name);
+    FREE(vif->phy_name);
+    FREE(vif);
+}
+
+static bool
+osw_drv_target_vif_sync(struct osw_drv_target_vif *vif)
+{
+    struct osw_drv_dummy *dummy = &vif->target->dummy;
+    struct ds_tree *phy_tree = &vif->target->phy_tree;
+    const char *phy_name = osw_drv_target_vif_get_phy_name(vif);
+    const char *vif_name = vif->vif_name;
+    struct schema_Wifi_Radio_State rzero = {0};
+    const struct schema_Wifi_Radio_State *rstate = &rzero;
+    struct osw_drv_vif_state state = {0};
+
+    if (phy_name == NULL)
+        return false;
+
+    struct osw_drv_target_phy *phy = ds_tree_find(phy_tree, phy_name);
+    if (phy != NULL)
+        rstate = &phy->rstate;
+
+    if (strlen(vif->state.mode) == 0)
+        SCHEMA_CPY_STR(vif->state.mode, vif->config.mode);
+
+    osw_drv_target_schema2vifstate(&vif->state, rstate, &state);
+    state.exists = osw_drv_target_vif_get_exists(vif);
+
+    if (state.exists == true)
+        osw_drv_dummy_set_vif(dummy, phy_name, vif_name, &state);
+    else
+        osw_drv_dummy_set_vif(dummy, phy_name, vif_name, NULL);
+
+    return true;
+}
+
+static void
+osw_drv_target_vif_work_cb(EV_P_ ev_timer *arg, int events)
+{
+    struct osw_drv_target_vif *vif = container_of(arg, struct osw_drv_target_vif, work);
+    if (osw_drv_target_vif_sync(vif) == false) return;
+    ev_timer_stop(EV_A_ arg);
+    osw_drv_target_vif_gc(vif);
+}
+
+static struct osw_drv_target_vif *
+osw_drv_target_vif_get(struct osw_drv_target *target,
+                       const char *vif_name)
+{
+    struct ds_tree *tree = &target->vif_tree;
+    struct osw_drv_target_vif *vif = ds_tree_find(tree, vif_name);
+    if (vif == NULL) {
+        vif = CALLOC(1, sizeof(*vif));
+        vif->target = target;
+        vif->vif_name = STRDUP(vif_name);
+        ev_timer_init(&vif->work, osw_drv_target_vif_work_cb, 0, 0);
+        ds_tree_insert(tree, vif, vif->vif_name);
+    }
+    return vif;
+}
+
+static void
+osw_drv_target_vif_sched(struct osw_drv_target_vif *vif)
+{
+    ev_timer_stop(EV_DEFAULT_ &vif->work);
+    ev_timer_set(&vif->work, 0, 5);
+    ev_timer_start(EV_DEFAULT_ &vif->work);
+}
+
+static void
+osw_drv_target_vif_set_config(struct osw_drv_target *target,
+                              const char *vif_name,
+                              const struct schema_Wifi_VIF_Config *config)
+{
+    struct osw_drv_target_vif *vif = osw_drv_target_vif_get(target, vif_name);
+    vif->config = *config;
+    osw_drv_target_vif_sched(vif);
+}
+
+static void
+osw_drv_target_vif_set_state(struct osw_drv_target *target,
+                             const char *vif_name,
+                             const struct schema_Wifi_VIF_State *state)
+{
+    struct osw_drv_target_vif *vif = osw_drv_target_vif_get(target, vif_name);
+    vif->state = *state;
+    osw_drv_target_vif_sched(vif);
+}
+
+static void
+osw_drv_target_vif_set_phy(struct osw_drv_target *target,
+                           const char *vif_name,
+                           const char *phy_name)
+{
+    struct osw_drv_target_vif *vif = osw_drv_target_vif_get(target, vif_name);
+    FREE(vif->phy_name);
+    vif->phy_name = STRDUP(phy_name);
+    osw_drv_target_vif_sched(vif);
+}
+
+static void
+osw_drv_target_vif_set_exists(struct osw_drv_target *target,
+                              const char *vif_name,
+                              bool exists)
+{
+    struct osw_drv_target_vif *vif = osw_drv_target_vif_get(target, vif_name);
+    vif->exists = exists;
+    osw_drv_target_vif_sched(vif);
+}
+
+static void
+osw_drv_target_op_vstate_cb(const struct schema_Wifi_VIF_State *vstate,
+                            const char *phy)
+{
+    struct osw_drv_target *target = &g_osw_drv_target;
+    LOGI("osw: drv: target: vstate report: %s: %s", phy ?: "?", vstate->if_name);
+    if (phy != NULL && strlen(phy) > 0)
+        osw_drv_target_vif_set_phy(target, vstate->if_name, phy);
+    osw_drv_target_vif_set_state(target, vstate->if_name, vstate);
+}
+
+static void
+osw_drv_target_op_rstate_cb(const struct schema_Wifi_Radio_State *rstate)
+{
+    struct osw_drv_target *target = &g_osw_drv_target;
+    struct osw_drv_dummy *dummy = &target->dummy;
+    struct osw_drv_phy_state info = {0};
+    struct osw_drv_target_phy *tphy = ds_tree_find(&target->phy_tree, rstate->if_name);
+    struct osw_drv_target_vif *tvif;
+
+    LOGI("osw: drv: target: rstate report: %s", rstate->if_name);
+    osw_drv_target_schema2phystate(rstate, &info);
+
+    if (info.exists == true) {
+        if (tphy == NULL) {
+            tphy = CALLOC(1, sizeof(*tphy));
+            tphy->rstate = *rstate;
+            ds_tree_insert(&target->phy_tree, tphy, tphy->rstate.if_name);
+        }
+        else {
+            tphy->rstate = *rstate;
+        }
+        osw_drv_dummy_set_phy(dummy, rstate->if_name, &info);
+    }
+    else {
+        if (tphy != NULL) {
+            ds_tree_remove(&target->phy_tree, tphy);
+            FREE(tphy);
+            tphy = NULL;
+        }
+        osw_drv_dummy_set_phy(dummy, rstate->if_name, NULL);
+    }
+
+    /* Some rstate values are used to derive osw_drv_vif_state. Therefore any
+     * change to rstate needs to generate a vif state re-report. The system
+     * will debounce it and won't generate any actions if the state doesn't
+     * deviate from the desired configuration though.
+     */
+    ds_tree_foreach(&target->vif_tree, tvif) {
+        const char *phy_name = osw_drv_target_vif_get_phy_name(tvif);
+        if (phy_name == NULL) continue;
+        if (strcmp(phy_name, rstate->if_name) != 0) continue;
+
+        osw_drv_target_op_vstate_cb(&tvif->state, rstate->if_name);
+    }
+}
+
+static void
+osw_drv_target_op_client_cb(const struct schema_Wifi_Associated_Clients *client,
+                            const char *vif,
+                            bool associated)
+{
+    struct osw_drv_target *target = &g_osw_drv_target;
+    struct osw_drv_dummy *dummy = &target->dummy;
+    struct osw_drv_sta_state info = {0};
+    struct osw_hwaddr addr;
+
+    info.key_id = osw_drv_target_str2keyid(client->key_id);
+    info.connected = associated;
+
+    sscanf(client->mac, "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
+            &addr.octet[0],
+            &addr.octet[1],
+            &addr.octet[2],
+            &addr.octet[3],
+            &addr.octet[4],
+            &addr.octet[5]);
+
+    osw_drv_dummy_set_sta(dummy, NULL, vif, &addr, &info);
+
+    LOGI("osw: drv: target: %s: %s: %sconnected: key_id=%s/%d",
+         vif, client->mac, associated ? "" : "dis",
+         client->key_id, info.key_id);
+}
+
+static void
+osw_drv_target_flush_sta_iter_cb(struct osw_drv_dummy *dummy,
+                                 const char *phy_name,
+                                 const char *vif_name,
+                                 const struct osw_hwaddr *sta_addr,
+                                 void *fn_data)
+{
+    const char *vif = fn_data;
+    if (strcmp(vif_name, vif) != 0) return;
+    osw_drv_dummy_set_sta(dummy, phy_name, vif_name, sta_addr, NULL);
+}
+
+static void
+osw_drv_target_flush_sta(const char *vif)
+{
+    struct osw_drv_target *target = &g_osw_drv_target;
+    struct osw_drv_dummy *dummy = &target->dummy;
+    char *vifp = STRDUP(vif);
+
+    osw_drv_dummy_iter_sta(dummy, osw_drv_target_flush_sta_iter_cb, vifp);
+    FREE(vifp);
+}
+
+static void
+osw_drv_target_op_clients_cb(const struct schema_Wifi_Associated_Clients *clients,
+                             int num,
+                             const char *vif)
+{
+    osw_drv_target_flush_sta(vif);
+    while (num--) {
+        osw_drv_target_op_client_cb(clients, vif, true);
+        clients++;
+    }
+}
+
+static void
+osw_drv_target_op_flush_clients_cb(const char *vif)
+{
+    osw_drv_target_flush_sta(vif);
+}
+
+static const struct target_radio_ops g_rops = {
+    .op_vstate = osw_drv_target_op_vstate_cb,
+    .op_rstate = osw_drv_target_op_rstate_cb,
+    .op_client = osw_drv_target_op_client_cb,
+    .op_clients = osw_drv_target_op_clients_cb,
+    .op_flush_clients = osw_drv_target_op_flush_clients_cb,
+};
+
+static void
+callback_Wifi_Radio_Config(ovsdb_update_monitor_t *mon,
+                           struct schema_Wifi_Radio_Config *old,
+                           struct schema_Wifi_Radio_Config *rconf,
+                           ovsdb_cache_row_t *row)
+{
+}
+
+static void
+callback_Wifi_VIF_Config(ovsdb_update_monitor_t *mon,
+                         struct schema_Wifi_VIF_Config *old,
+                         struct schema_Wifi_VIF_Config *vconf,
+                         ovsdb_cache_row_t *row)
+{
+    struct osw_drv_target *target = &g_osw_drv_target;
+
+    switch (mon->mon_type) {
+        case OVSDB_UPDATE_NEW:
+        case OVSDB_UPDATE_MODIFY:
+            osw_drv_target_vif_set_config(target, vconf->if_name, vconf);
+            osw_drv_target_vif_set_exists(target, vconf->if_name, true);
+            break;
+        case OVSDB_UPDATE_DEL:
+            osw_drv_target_vif_set_exists(target, vconf->if_name, false);
+            break;
+        case OVSDB_UPDATE_ERROR:
+            break;
+    }
+}
+
+static void
+osw_drv_target_conf_sched(struct osw_drv_target *target)
+{
+    ev_timer_stop(EV_DEFAULT_ &target->conf_timer);
+    ev_timer_set(&target->conf_timer, 0, 0);
+    ev_timer_start(EV_DEFAULT_ &target->conf_timer);
+}
+
+static void
+osw_drv_target_conf_timer_cb(EV_P_ ev_timer *arg, int events)
+{
+    struct osw_drv_target *target = container_of(arg, struct osw_drv_target, conf_timer);
+    struct osw_drv_conf *conf = target->conf;
+
+    while (target->conf_phy < target->conf->n_phy_list) {
+        struct osw_drv_phy_config *phy = &conf->phy_list[target->conf_phy];
+
+        if (target->conf_phy_done == false) {
+            size_t i;
+            bool phy_changed = phy->changed;
+
+            /* Target API configures some attributes per PHY, not per VIF. OSW
+             * itself isn't aware.
+             */
+            for (i = 0; i < phy->vif_list.count; i++) {
+                struct osw_drv_vif_config *vif = &phy->vif_list.list[i];
+                if (vif->vif_type != OSW_VIF_AP) continue;
+                phy_changed |= vif->u.ap.channel_changed;
+                phy_changed |= vif->u.ap.beacon_interval_tu_changed;
+            }
+
+            if (phy_changed == true) {
+                osw_drv_target_phy_set(target, phy);
+                target->conf_phy_done = true;
+                osw_drv_target_conf_sched(target);
+                return;
+            }
+        }
+
+        while (target->conf_vif < phy->vif_list.count) {
+            struct osw_drv_vif_config *vif = &phy->vif_list.list[target->conf_vif];
+
+            target->conf_vif++;
+            if (vif->changed) {
+                osw_drv_target_vif_set(target, phy, vif);
+                osw_drv_target_conf_sched(target);
+                return;
+            }
+        }
+
+        target->conf_phy++;
+        target->conf_vif = 0;
+        target->conf_phy_done = false;
+    }
+
+    osw_drv_conf_free(conf);
+    target->conf = NULL;
+}
+
+static void
+osw_drv_target_ovsdb_retry_cb(EV_P_ ev_timer *t, int events)
+{
+    if (ovsdb_init_loop(EV_A_ NULL) == false) {
+        LOGI("osw: drv: target: failed to connect to ovsdb, will retry later");
+        return;
+    }
+
+    OVSDB_CACHE_MONITOR(Wifi_Radio_Config, true);
+    OVSDB_CACHE_MONITOR(Wifi_VIF_Config, true);
+
+    ev_timer_stop(EV_A_ t);
+    LOGI("osw: drv: target: ovsdb ready");
+}
+
+void
+osw_drv_target_init_cb(struct osw_drv *drv)
+{
+    struct osw_drv_target *target = &g_osw_drv_target;
+    struct osw_drv_dummy *dummy = &target->dummy;
+
+    if (target_init(TARGET_INIT_MGR_WM, EV_DEFAULT) == false) {
+        LOGI("osw: drv: target: failed to initialize");
+        return;
+    }
+
+    ev_timer_init(&target->conf_timer, osw_drv_target_conf_timer_cb, 0, 0);
+    ev_timer_init(&target->ovsdb_retry, osw_drv_target_ovsdb_retry_cb, 0, 1);
+    ev_timer_start(EV_DEFAULT_ &target->ovsdb_retry);
+
+    target_radio_init(&g_rops);
+    target->drv = drv;
+    osw_drv_set_priv(drv, dummy);
+}
+
+void
+osw_drv_target_request_config_cb(struct osw_drv *drv,
+                                 struct osw_drv_conf *conf)
+{
+    struct osw_drv_dummy *dummy = osw_drv_get_priv(drv);
+    struct osw_drv_target *target = container_of(dummy, struct osw_drv_target, dummy);
+
+    osw_drv_conf_free(target->conf);
+    target->conf = conf;
+    target->conf_phy_done = false;
+    target->conf_phy = 0;
+    target->conf_vif = 0;
+
+    osw_drv_target_conf_sched(target);
+
+}
+
+/*
+FIXME: dummy doesnt support it yet
+static void
+osw_drv_target_request_sta_deauth_cb(struct osw_drv *drv,
+                                     const char *phy_name,
+                                     const char *vif_name,
+                                     const struct osw_hwaddr *mac_addr,
+                                     int dot11_reason_code)
+{
+}
+*/
+
+static void
+osw_drv_target_module_init(void *data)
+{
+    struct osw_drv_dummy *dummy = &g_osw_drv_target.dummy;
+
+    if (osw_drv_target_enabled() == false) {
+        LOGI("osw: drv: target: disabled");
+        return;
+    }
+
+    osw_drv_dummy_init(dummy);
+
+    /* FIXME: This could use ovsdb_cache to avoid explicit
+     * selects. It might be more efficient.
+     */
+    OVSDB_TABLE_INIT(Wifi_Radio_Config, if_name);
+    OVSDB_TABLE_INIT(Wifi_Radio_State, if_name);
+    OVSDB_TABLE_INIT(Wifi_VIF_Config, if_name);
+}
+
+static void
+osw_drv_target_module_fini(void *data)
+{
+}
+
+MODULE(osw_drv_target_module,
+       osw_drv_target_module_init,
+       osw_drv_target_module_fini);
+
+static void
+osw_drv_target_ut_phyconf2schema_cb(void *data)
+{
+    struct schema_Wifi_Radio_Config base_rconf = {0};
+    struct schema_Wifi_Radio_Config rconf = {0};
+    struct schema_Wifi_Radio_Config_flags rchanged = {0};
+    struct osw_channel_state cstates[] = {
+        { .channel = { .control_freq_mhz = 5180 } },
+        { .channel = { .control_freq_mhz = 5745 } },
+    };
+    const struct osw_drv_phy_state dstate_5g = {
+        .n_channel_states = 2,
+        .channel_states = cstates,
+    };
+    const struct osw_drv_phy_state dstate_5gl = {
+        .n_channel_states = 1,
+        .channel_states = &cstates[0],
+    };
+    const struct osw_drv_phy_state dstate_5gu = {
+        .n_channel_states = 1,
+        .channel_states = &cstates[1],
+    };
+    struct osw_state_phy_info info = {
+        .phy_name = "phy1",
+        .drv_state = &dstate_5g,
+    };
+    struct osw_drv_vif_config vifs[] = {
+        {
+            .vif_name = "vif1",
+            .vif_type = OSW_VIF_AP,
+            .enabled = true,
+            .u.ap = {
+                .beacon_interval_tu = 100,
+                .beacon_interval_tu_changed = true,
+                .channel_changed = true,
+                .channel = {
+                    .control_freq_mhz = 2412,
+                    .width = OSW_CHANNEL_20MHZ,
+                },
+                .mode_changed = true,
+                .mode = {
+                    .vht_enabled = true,
+                },
+            },
+        },
+        {
+            .vif_name = "vif2",
+            .vif_type = OSW_VIF_AP,
+            .enabled = true,
+            .u.ap = {
+                .beacon_interval_tu = 100,
+                .channel = {
+                    .control_freq_mhz = 2412,
+                    .width = OSW_CHANNEL_20MHZ,
+                },
+            },
+        },
+        {
+            .vif_name = "vif3",
+            .vif_type = OSW_VIF_STA,
+            .enabled = true,
+            .u.ap = {
+                .channel = {
+                    .control_freq_mhz = 2417,
+                    .width = OSW_CHANNEL_20MHZ,
+                },
+                .mode = {
+                    .he_enabled = true,
+                },
+            },
+        },
+    };
+    struct osw_drv_phy_config phy = {
+        .phy_name = "phy1",
+        .enabled = true,
+        .enabled_changed = true,
+        .tx_chainmask = 0x0f,
+        .tx_chainmask_changed = true,
+        .radar = OSW_RADAR_DETECT_DISABLED,
+        .radar_changed = true,
+        .vif_list = {
+            .list = vifs,
+            .count = ARRAY_SIZE(vifs),
+        },
+    };
+
+    SCHEMA_SET_STR(base_rconf.hw_type, "hello");
+    SCHEMA_KEY_VAL_SET(base_rconf.hw_config, "a", "1");
+    SCHEMA_KEY_VAL_SET(base_rconf.hw_config, "b", "2");
+    osw_drv_target_phyconf2schema(&phy, &info, &base_rconf, &rconf, &rchanged);
+
+    assert(strcmp(rconf.if_name, phy.phy_name) == 0);
+    assert(rchanged.enabled);
+    assert(rchanged.tx_chainmask);
+    assert(rchanged.dfs_demo);
+    assert(rchanged.channel);
+    assert(rchanged.ht_mode);
+    assert(rchanged.freq_band);
+    assert(rchanged.hw_mode);
+    assert(rchanged.bcn_int);
+    assert(rconf.enabled == phy.enabled);
+    assert(rconf.enabled_exists == true);
+    assert(rconf.tx_chainmask == phy.tx_chainmask);
+    assert(rconf.tx_chainmask_exists == true);
+    assert(rconf.dfs_demo == true);
+    assert(rconf.dfs_demo_exists == true);
+    assert(rconf.channel == 1);
+    assert(rconf.channel_exists == true);
+    assert(strcmp(rconf.ht_mode, "HT20") == 0);
+    assert(rconf.ht_mode_exists == true);
+    assert(strcmp(rconf.freq_band, "2.4G") == 0);
+    assert(rconf.freq_band_exists == true);
+    assert(strcmp(rconf.hw_mode, "11ac") == 0);
+    assert(rconf.hw_mode_exists == true);
+    assert(rconf.bcn_int == 100);
+    assert(rconf.bcn_int_exists == true);
+    assert(rconf.hw_config_len == 2);
+    assert(strcmp(rconf.hw_type, "hello") == 0);
+    assert(SCHEMA_KEY_VAL_NULL(rconf.hw_config, "a") != NULL);
+    assert(SCHEMA_KEY_VAL_NULL(rconf.hw_config, "b") != NULL);
+    assert(strcmp(SCHEMA_KEY_VAL(rconf.hw_config, "a"), "1") == 0);
+    assert(strcmp(SCHEMA_KEY_VAL(rconf.hw_config, "b"), "2") == 0);
+
+    memset(&rconf, 0, sizeof(rconf));
+    memset(&rchanged, 0, sizeof(rchanged));
+    vifs[0].u.ap.beacon_interval_tu = 200;
+    osw_drv_target_phyconf2schema(&phy, &info, &base_rconf, &rconf, &rchanged);
+    assert(rconf.bcn_int_exists == false);
+
+    memset(&rconf, 0, sizeof(rconf));
+    memset(&rchanged, 0, sizeof(rchanged));
+    phy.radar = OSW_RADAR_UNSUPPORTED;
+    osw_drv_target_phyconf2schema(&phy, &info, &base_rconf, &rconf, &rchanged);
+    assert(rconf.dfs_demo_exists == false);
+
+    memset(&rconf, 0, sizeof(rconf));
+    memset(&rchanged, 0, sizeof(rchanged));
+    vifs[0].u.ap.channel_changed = false;
+    osw_drv_target_phyconf2schema(&phy, &info, &base_rconf, &rconf, &rchanged);
+    assert(rchanged.channel == false);
+    assert(rchanged.ht_mode == false);
+    assert(rchanged.freq_band == false);
+
+    memset(&rconf, 0, sizeof(rconf));
+    memset(&rchanged, 0, sizeof(rchanged));
+    vifs[0].u.ap.channel.control_freq_mhz = 2417;
+    osw_drv_target_phyconf2schema(&phy, &info, &base_rconf, &rconf, &rchanged);
+    assert(rconf.channel_exists == false);
+    assert(rconf.ht_mode_exists == false);
+    assert(rconf.freq_band_exists == false);
+
+    memset(&rconf, 0, sizeof(rconf));
+    memset(&rchanged, 0, sizeof(rchanged));
+    vifs[0].u.ap.channel.control_freq_mhz = 5180;
+    vifs[1].u.ap.channel.control_freq_mhz = 5180;
+    osw_drv_target_phyconf2schema(&phy, &info, &base_rconf, &rconf, &rchanged);
+    assert(rconf.channel == 36);
+    assert(strcmp(rconf.freq_band, "5G") == 0);
+
+    memset(&rconf, 0, sizeof(rconf));
+    memset(&rchanged, 0, sizeof(rchanged));
+    info.drv_state = &dstate_5gl;
+    osw_drv_target_phyconf2schema(&phy, &info, &base_rconf, &rconf, &rchanged);
+    assert(strcmp(rconf.freq_band, "5GL") == 0);
+
+    memset(&rconf, 0, sizeof(rconf));
+    memset(&rchanged, 0, sizeof(rchanged));
+    info.drv_state = &dstate_5g;
+    vifs[0].u.ap.channel.control_freq_mhz = 5745;
+    vifs[1].u.ap.channel.control_freq_mhz = 5745;
+    osw_drv_target_phyconf2schema(&phy, &info, &base_rconf, &rconf, &rchanged);
+    assert(rconf.channel == 149);
+    assert(strcmp(rconf.freq_band, "5G") == 0);
+
+    memset(&rconf, 0, sizeof(rconf));
+    memset(&rchanged, 0, sizeof(rchanged));
+    info.drv_state = &dstate_5gu;
+    osw_drv_target_phyconf2schema(&phy, &info, &base_rconf, &rconf, &rchanged);
+    assert(strcmp(rconf.freq_band, "5GU") == 0);
+    info.drv_state = &dstate_5g;
+
+    memset(&rconf, 0, sizeof(rconf));
+    memset(&rchanged, 0, sizeof(rchanged));
+    vifs[0].u.ap.channel.control_freq_mhz = 5955;
+    vifs[1].u.ap.channel.control_freq_mhz = 5955;
+    osw_drv_target_phyconf2schema(&phy, &info, &base_rconf, &rconf, &rchanged);
+    assert(rconf.channel == 1);
+    assert(strcmp(rconf.freq_band, "6G") == 0);
+
+    memset(&rconf, 0, sizeof(rconf));
+    memset(&rchanged, 0, sizeof(rchanged));
+    vifs[0].u.ap.channel.control_freq_mhz = 5935;
+    vifs[1].u.ap.channel.control_freq_mhz = 5935;
+    osw_drv_target_phyconf2schema(&phy, &info, &base_rconf, &rconf, &rchanged);
+    assert(rconf.channel == 2);
+    assert(strcmp(rconf.freq_band, "6G") == 0); /* FIXME 5GL/5GU */
+
+    memset(&rconf, 0, sizeof(rconf));
+    memset(&rchanged, 0, sizeof(rchanged));
+    vifs[0].u.ap.channel.width = OSW_CHANNEL_40MHZ;
+    osw_drv_target_phyconf2schema(&phy, &info, &base_rconf, &rconf, &rchanged);
+    assert(rconf.channel_exists == false);
+
+    memset(&rconf, 0, sizeof(rconf));
+    memset(&rchanged, 0, sizeof(rchanged));
+    vifs[0].u.ap.channel.width = OSW_CHANNEL_40MHZ;
+    vifs[1].u.ap.channel.width = OSW_CHANNEL_40MHZ;
+    osw_drv_target_phyconf2schema(&phy, &info, &base_rconf, &rconf, &rchanged);
+    assert(strcmp(rconf.ht_mode, "HT40") == 0);
+
+    memset(&rconf, 0, sizeof(rconf));
+    memset(&rchanged, 0, sizeof(rchanged));
+    vifs[0].u.ap.channel.width = OSW_CHANNEL_80MHZ;
+    vifs[1].u.ap.channel.width = OSW_CHANNEL_80MHZ;
+    osw_drv_target_phyconf2schema(&phy, &info, &base_rconf, &rconf, &rchanged);
+    assert(strcmp(rconf.ht_mode, "HT80") == 0);
+
+    memset(&rconf, 0, sizeof(rconf));
+    memset(&rchanged, 0, sizeof(rchanged));
+    vifs[0].u.ap.channel.width = OSW_CHANNEL_160MHZ;
+    vifs[1].u.ap.channel.width = OSW_CHANNEL_160MHZ;
+    osw_drv_target_phyconf2schema(&phy, &info, &base_rconf, &rconf, &rchanged);
+    assert(strcmp(rconf.ht_mode, "HT160") == 0);
+
+    memset(&rconf, 0, sizeof(rconf));
+    memset(&rchanged, 0, sizeof(rchanged));
+    vifs[1].u.ap.mode.he_enabled = true;
+    osw_drv_target_phyconf2schema(&phy, &info, &base_rconf, &rconf, &rchanged);
+    assert(strcmp(rconf.hw_mode, "11ax") == 0);
+
+    memset(&rconf, 0, sizeof(rconf));
+    memset(&rchanged, 0, sizeof(rchanged));
+    vifs[0].u.ap.mode.vht_enabled = false;
+    vifs[1].u.ap.mode.he_enabled = false;
+    osw_drv_target_phyconf2schema(&phy, &info, &base_rconf, &rconf, &rchanged);
+    assert(strcmp(rconf.hw_mode, "11a") == 0);
+
+    memset(&rconf, 0, sizeof(rconf));
+    memset(&rchanged, 0, sizeof(rchanged));
+    vifs[0].u.ap.channel.control_freq_mhz = 2412;
+    vifs[1].u.ap.channel.control_freq_mhz = 2412;
+    osw_drv_target_phyconf2schema(&phy, &info, &base_rconf, &rconf, &rchanged);
+    assert(strcmp(rconf.hw_mode, "11g") == 0);
+
+    memset(&rconf, 0, sizeof(rconf));
+    memset(&rchanged, 0, sizeof(rchanged));
+    vifs[0].u.ap.mode.ht_enabled = true;
+    osw_drv_target_phyconf2schema(&phy, &info, &base_rconf, &rconf, &rchanged);
+    assert(strcmp(rconf.hw_mode, "11n") == 0);
+}
+
+static void
+osw_drv_target_ut_vifconf2schema_ap_cb(void *data)
+{
+    struct schema_Wifi_VIF_Config base_vconf = {0};
+    struct schema_Wifi_VIF_Config vconf = {0};
+    struct schema_Wifi_VIF_Config_flags vchanged = {0};
+    struct osw_hwaddr acl[] = {
+        { .octet = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06} },
+        { .octet = {0x11, 0x12, 0x13, 0x14, 0x15, 0x16} },
+    };
+    struct osw_ap_psk psks[] = {
+        { .key_id = 1, .psk.str = "12345678" },
+        { .key_id = 2, .psk.str = "87654321" },
+        { .key_id = 3, .psk.str = "00000000" },
+    };
+    struct osw_drv_vif_config vif = {
+        .vif_name = "vif1",
+        .vif_type = OSW_VIF_AP,
+        .enabled = true,
+        .enabled_changed = true,
+        .u.ap = {
+            .bridge_if_name = { .buf = "br0" },
+            .bridge_if_name_changed = true,
+            .ssid = { .buf = "ssid1", .len = 5 },
+            .ssid_changed = true,
+            .ssid_hidden = true,
+            .ssid_hidden_changed = true,
+            .acl_policy = OSW_ACL_ALLOW_LIST,
+            .acl_policy_changed = true,
+            .isolated = true,
+            .isolated_changed = true,
+            .mcast2ucast = true,
+            .mcast2ucast_changed = true,
+            .mode_changed = true,
+            .mode = {
+                .wnm_bss_trans = true,
+                .rrm_neighbor_report = true,
+                .wmm_uapsd_enabled = true,
+                .wps = true,
+            },
+            .wpa_changed = true,
+            .wpa = {
+                .wpa = true,
+                .rsn = true,
+                .akm_psk = true,
+                .akm_sae = true,
+                .group_rekey_seconds = 60,
+                .ft_mobility_domain = 0xff00,
+            },
+            .acl_changed = true,
+            .acl = {
+                .list = acl,
+                .count = ARRAY_SIZE(acl),
+            },
+            .psk_list_changed = true,
+            .psk_list = {
+                .list = psks,
+                .count = ARRAY_SIZE(psks),
+            },
+        },
+    };
+
+    SCHEMA_SET_INT(base_vconf.vif_radio_idx, 4);
+    osw_drv_target_vifconf2schema(&vif, &base_vconf, &vconf, &vchanged, NULL, 0);
+    assert(strcmp(vconf.if_name, vif.vif_name) == 0);
+    assert(strcmp(vconf.mode, "ap") == 0);
+    assert(strcmp(vconf.bridge, vif.u.ap.bridge_if_name.buf) == 0);
+    assert(strcmp(vconf.ssid, vif.u.ap.ssid.buf) == 0);
+    assert(strcmp(vconf.ssid_broadcast, "disabled") == 0);
+    assert(strcmp(vconf.mac_list_type, "whitelist") == 0);
+    assert(vconf.enabled == true);
+    assert(vconf.ap_bridge == false);
+    assert(vconf.mcast2ucast == true);
+    assert(vconf.rrm == true);
+    assert(vconf.btm == true);
+    assert(vconf.uapsd_enable == true);
+    assert(vconf.wps == true);
+    assert(vconf.wpa == true);
+    assert(vconf.ft_mobility_domain == 0xff00);
+    assert(vconf.group_rekey == vif.u.ap.wpa.group_rekey_seconds);
+    assert(vconf.vif_radio_idx == 4);
+    {
+        bool has_wpa1 = false;
+        bool has_wpa2 = false;
+        bool has_sae = false;
+        int i;
+        for (i = 0; i < vconf.wpa_key_mgmt_len; i++) {
+            if (strcmp(vconf.wpa_key_mgmt[i], "wpa-psk") == 0) has_wpa1 = true;
+            if (strcmp(vconf.wpa_key_mgmt[i], "wpa2-psk") == 0) has_wpa2 = true;
+            if (strcmp(vconf.wpa_key_mgmt[i], "sae") == 0) has_sae = true;
+        }
+        assert(has_wpa1 == true);
+        assert(has_wpa2 == true);
+        assert(has_sae == true);
+    }
+    {
+        bool found[ARRAY_SIZE(acl)] = {0};
+        int i;
+        size_t j;
+        for (i = 0; i < vconf.mac_list_len; i++) {
+            struct osw_hwaddr addr;
+            sscanf(vconf.mac_list[i], "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
+                   &addr.octet[0],
+                   &addr.octet[1],
+                   &addr.octet[2],
+                   &addr.octet[3],
+                   &addr.octet[4],
+                   &addr.octet[5]);
+            for (j = 0; j < ARRAY_SIZE(acl); j++) {
+                if (memcmp(&addr, &acl[j], sizeof(addr)) == 0)
+                    found[j] = true;
+            }
+        }
+        int n = 0;
+        for (j = 0; j < ARRAY_SIZE(acl); j++)
+            if (found[j]) n++;
+        assert(n == ARRAY_SIZE(acl));
+    }
+    {
+        bool found[ARRAY_SIZE(psks)] = {0};
+        int i;
+        size_t j;
+        for (i = 0; i < vconf.wpa_psks_len; i++) {
+            int key_id = osw_drv_target_str2keyid(vconf.wpa_psks_keys[i]);
+            for (j = 0; j < ARRAY_SIZE(psks); j++)
+                if (psks[j].key_id == key_id)
+                    found[j] = true;
+        }
+        int n = 0;
+        for (j = 0; j < ARRAY_SIZE(psks); j++)
+            if (found[j]) n++;
+        assert(n == ARRAY_SIZE(psks));
+    }
+
+    assert(vconf.enabled_exists == true);
+    assert(vconf.mode_exists == true);
+    assert(vconf.bridge_exists == true);
+    assert(vconf.ssid_exists == true);
+    assert(vconf.ssid_broadcast_exists == true);
+    assert(vconf.mac_list_type_exists == true);
+    assert(vconf.ap_bridge_exists == true);
+    assert(vconf.mcast2ucast_exists == true);
+    assert(vconf.rrm_exists == true);
+    assert(vconf.btm_exists == true);
+    assert(vconf.uapsd_enable_exists == true);
+    assert(vconf.wps_exists == true);
+    assert(vconf.wpa_exists == true);
+    assert(vconf.ft_mobility_domain_exists == true);
+    assert(vconf.group_rekey_exists == true);
+    assert(vconf.wpa_key_mgmt_len == 3);
+    assert(vconf.mac_list_len == 2);
+    assert(vconf.wpa_psks_len == 3);
+    assert(vconf.vif_radio_idx_exists == true);
+
+    assert(vchanged.enabled == true);
+    assert(vchanged.bridge == true);
+    assert(vchanged.ssid == true);
+    assert(vchanged.ssid_broadcast == true);
+    assert(vchanged.mac_list_type == true);
+    assert(vchanged.ap_bridge == true);
+    assert(vchanged.mcast2ucast == true);
+    assert(vchanged.rrm == true);
+    assert(vchanged.btm == true);
+    assert(vchanged.uapsd_enable == true);
+    assert(vchanged.wps == true);
+    assert(vchanged.wpa == true);
+    assert(vchanged.ft_mobility_domain == true);
+    assert(vchanged.group_rekey == true);
+    assert(vchanged.wpa_key_mgmt == true);
+    assert(vchanged.mac_list == true);
+    assert(vchanged.wpa_psks == true);
+
+    memset(&vconf, 0, sizeof(vconf));
+    memset(&vchanged, 0, sizeof(vchanged));
+    vif.u.ap.acl_policy = OSW_ACL_DENY_LIST;
+    osw_drv_target_vifconf2schema(&vif, &base_vconf, &vconf, &vchanged, NULL, 0);
+    assert(strcmp(vconf.mac_list_type, "blacklist") == 0);
+
+    memset(&vconf, 0, sizeof(vconf));
+    memset(&vchanged, 0, sizeof(vchanged));
+    vif.u.ap.acl_policy = OSW_ACL_NONE;
+    osw_drv_target_vifconf2schema(&vif, &base_vconf, &vconf, &vchanged, NULL, 0);
+    assert(strcmp(vconf.mac_list_type, "none") == 0);
+
+    memset(&vconf, 0, sizeof(vconf));
+    memset(&vchanged, 0, sizeof(vchanged));
+    vif.u.ap.acl_policy = OSW_ACL_DENY_LIST + 1;
+    osw_drv_target_vifconf2schema(&vif, &base_vconf, &vconf, &vchanged, NULL, 0);
+    assert(vconf.mac_list_type_exists == false);
+
+    memset(&vconf, 0, sizeof(vconf));
+    memset(&vchanged, 0, sizeof(vchanged));
+    vif.u.ap.wpa.rsn = false;
+    osw_drv_target_vifconf2schema(&vif, &base_vconf, &vconf, &vchanged, NULL, 0);
+    {
+        bool has_wpa1 = false;
+        bool has_wpa2 = false;
+        bool has_sae = false;
+        int i;
+        for (i = 0; i < vconf.wpa_key_mgmt_len; i++) {
+            if (strcmp(vconf.wpa_key_mgmt[i], "wpa-psk") == 0) has_wpa1 = true;
+            if (strcmp(vconf.wpa_key_mgmt[i], "wpa2-psk") == 0) has_wpa2 = true;
+            if (strcmp(vconf.wpa_key_mgmt[i], "sae") == 0) has_sae = true;
+        }
+        assert(has_wpa1 == true);
+        assert(has_wpa2 == false);
+        assert(has_sae == false);
+    }
+
+    memset(&vconf, 0, sizeof(vconf));
+    memset(&vchanged, 0, sizeof(vchanged));
+    vif.u.ap.wpa.wpa = false;
+    vif.u.ap.wpa.rsn = true;
+    osw_drv_target_vifconf2schema(&vif, &base_vconf, &vconf, &vchanged, NULL, 0);
+    {
+        bool has_wpa1 = false;
+        bool has_wpa2 = false;
+        bool has_sae = false;
+        int i;
+        for (i = 0; i < vconf.wpa_key_mgmt_len; i++) {
+            if (strcmp(vconf.wpa_key_mgmt[i], "wpa-psk") == 0) has_wpa1 = true;
+            if (strcmp(vconf.wpa_key_mgmt[i], "wpa2-psk") == 0) has_wpa2 = true;
+            if (strcmp(vconf.wpa_key_mgmt[i], "sae") == 0) has_sae = true;
+        }
+        assert(has_wpa1 == false);
+        assert(has_wpa2 == true);
+        assert(has_sae == true);
+    }
+
+    memset(&vconf, 0, sizeof(vconf));
+    memset(&vchanged, 0, sizeof(vchanged));
+    vif.u.ap.wpa.akm_psk = false;
+    osw_drv_target_vifconf2schema(&vif, &base_vconf, &vconf, &vchanged, NULL, 0);
+    {
+        bool has_wpa1 = false;
+        bool has_wpa2 = false;
+        bool has_sae = false;
+        int i;
+        for (i = 0; i < vconf.wpa_key_mgmt_len; i++) {
+            if (strcmp(vconf.wpa_key_mgmt[i], "wpa-psk") == 0) has_wpa1 = true;
+            if (strcmp(vconf.wpa_key_mgmt[i], "wpa2-psk") == 0) has_wpa2 = true;
+            if (strcmp(vconf.wpa_key_mgmt[i], "sae") == 0) has_sae = true;
+        }
+        assert(has_wpa1 == false);
+        assert(has_wpa2 == false);
+        assert(has_sae == true);
+    }
+
+    memset(&vconf, 0, sizeof(vconf));
+    memset(&vchanged, 0, sizeof(vchanged));
+    vif.u.ap.wpa.group_rekey_seconds = 0;
+    osw_drv_target_vifconf2schema(&vif, &base_vconf, &vconf, &vchanged, NULL, 0);
+    assert(vconf.group_rekey_exists == true);
+    assert(vconf.group_rekey == vif.u.ap.wpa.group_rekey_seconds);
+
+    memset(&vconf, 0, sizeof(vconf));
+    memset(&vchanged, 0, sizeof(vchanged));
+    vif.u.ap.wpa.group_rekey_seconds = OSW_WPA_GROUP_REKEY_UNDEFINED;
+    osw_drv_target_vifconf2schema(&vif, &base_vconf, &vconf, &vchanged, NULL, 0);
+    assert(vconf.group_rekey_exists == false);
+
+    memset(&vconf, 0, sizeof(vconf));
+    memset(&vchanged, 0, sizeof(vchanged));
+    psks[ARRAY_SIZE(psks) - 1].key_id = psks[0].key_id;
+    osw_drv_target_vifconf2schema(&vif, &base_vconf, &vconf, &vchanged, NULL, 0);
+    assert(vconf.wpa_psks_len == 2);
+
+    memset(&base_vconf, 0, sizeof(base_vconf));
+    memset(&vconf, 0, sizeof(vconf));
+    memset(&vchanged, 0, sizeof(vchanged));
+    osw_drv_target_vifconf2schema(&vif, &base_vconf, &vconf, &vchanged, NULL, 0);
+    assert(vconf.vif_radio_idx_exists == false);
+}
+
+static void
+osw_drv_target_ut_schema2phystate_cb(void *data)
+{
+}
+
+static void
+osw_drv_target_ut_schema2vifstate_cb(void *data)
+{
+}
+
+static void
+osw_drv_target_ut_cs_cb(void *data)
+{
+    struct osw_drv_phy_state info = {0};
+    const enum osw_channel_state_dfs s = OSW_CHANNEL_NON_DFS;
+
+    osw_drv_target_cs_append(&info.channel_states, &info.n_channel_states, 2000, s);
+    osw_drv_target_cs_append(&info.channel_states, &info.n_channel_states, 3000, s);
+    osw_drv_target_cs_append(&info.channel_states, &info.n_channel_states, 4000, s);
+    assert(info.n_channel_states == 3);
+    assert(info.channel_states[0].channel.control_freq_mhz == 2000);
+    assert(info.channel_states[1].channel.control_freq_mhz == 3000);
+    assert(info.channel_states[2].channel.control_freq_mhz == 4000);
+    assert(osw_drv_target_cs_lookup(info.channel_states, info.n_channel_states, 2000) == &info.channel_states[0]);
+    assert(osw_drv_target_cs_lookup(info.channel_states, info.n_channel_states, 3000) == &info.channel_states[1]);
+    assert(osw_drv_target_cs_lookup(info.channel_states, info.n_channel_states, 4000) == &info.channel_states[2]);
+}
+
+static void
+osw_drv_target_ut_ch2freq_cb(void *data)
+{
+    assert(osw_drv_target_ch2freq(1, 1) == 0);
+    assert(osw_drv_target_ch2freq(2, 1) == 2412);
+    assert(osw_drv_target_ch2freq(5, 36) == 5180);
+    assert(osw_drv_target_ch2freq(6, 1) == 5955);
+    assert(osw_drv_target_ch2freq(6, 2) == 5935);
+}
+
+static void
+osw_drv_target_ut_keyid_cb(void *data)
+{
+    char buf[64];
+
+    assert(osw_drv_target_str2keyid("key") == 0);
+    assert(osw_drv_target_str2keyid("key-4") == 4);
+    assert(osw_drv_target_str2keyid("key--3") == -3);
+    osw_drv_target_keyid2str(buf, sizeof(buf), 0); assert(strcmp(buf, "key") == 0);
+    osw_drv_target_keyid2str(buf, sizeof(buf), 10); assert(strcmp(buf, "key-10") == 0);
+    osw_drv_target_keyid2str(buf, sizeof(buf), -2); assert(strcmp(buf, "key--2") == 0);
+}
+
+static void
+osw_drv_target_ut_module_init(void *data)
+{
+    osw_ut_register("ow_drv_target_ut_keyid", osw_drv_target_ut_keyid_cb, NULL);
+    osw_ut_register("ow_drv_target_ut_cs", osw_drv_target_ut_cs_cb, NULL);
+    osw_ut_register("ow_drv_target_ut_cs", osw_drv_target_ut_ch2freq_cb, NULL);
+    osw_ut_register("ow_drv_target_ut_phyconf2schema", osw_drv_target_ut_phyconf2schema_cb, NULL);
+    osw_ut_register("ow_drv_target_ut_vifconf2schema_ap", osw_drv_target_ut_vifconf2schema_ap_cb, NULL);
+    osw_ut_register("ow_drv_target_ut_schema2phystate", osw_drv_target_ut_schema2phystate_cb, NULL);
+    osw_ut_register("ow_drv_target_ut_schema2vifstate", osw_drv_target_ut_schema2vifstate_cb, NULL);
+}
+
+static void
+osw_drv_target_ut_module_fini(void *data)
+{
+}
+
+MODULE(osw_drv_target_ut_module,
+       osw_drv_target_ut_module_init,
+       osw_drv_target_ut_module_fini);
Index: device-core/src/lib/osw/src/osw_drv_ut.c
===================================================================
--- /dev/null
+++ device-core/src/lib/osw/src/osw_drv_ut.c
@@ -0,0 +1,551 @@
+#include "osw_ut.h"
+#include <osw_req.h>
+
+struct osw_drv_ut_state_obs {
+    struct osw_state_observer obs;
+    bool busy;
+};
+
+struct osw_drv_ut_sta {
+    const char *vif_name;
+    struct osw_hwaddr mac_addr;
+    int duration;
+};
+
+struct osw_drv_ut_drv_priv {
+    const char *phy_name;
+    const char *vif_names[16];
+    struct osw_drv_ut_sta stas[16];
+    struct osw_drv *drv;
+};
+
+struct osw_drv_ut_vif {
+    const char *vif_name;
+    struct osw_drv_vif_state state;
+};
+
+static struct osw_drv_ut_vif vifs[] = {
+    {
+        .vif_name = "vif1",
+        .state = {
+            .exists = true,
+            .enabled = true,
+            .vif_type = OSW_VIF_AP,
+            .u.ap = {
+                .psk_list = {
+                    .list = (struct osw_ap_psk[]){
+                        { .key_id = 1, .psk.str = "hello" },
+                        { .key_id = 2, .psk.str = "world" },
+                    },
+                    .count = 2,
+                },
+                .acl = {
+                    .list = (struct osw_hwaddr[]) {
+                        { .octet = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55 } },
+                        { .octet = { 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb } },
+                        { .octet = { 0xcc, 0xdd, 0xee, 0xff, 0x10, 0x20 } },
+                    },
+                    .count = 3,
+                },
+            },
+        },
+    },
+};
+
+static struct osw_drv_ut_drv_priv drv1_priv[] = {
+    { "phy1", { "vif1", "vif2" }, {}, NULL},
+    { "phy2", { "vif3" }, {}, NULL },
+    { NULL, {}, {}, NULL }
+};
+static struct osw_drv_ut_drv_priv drv2_priv[] = {
+    { "phy3", { "vif4" }, {}, NULL },
+    { NULL, {}, {}, NULL }
+};
+
+static bool
+osw_drv_ut_drv_phy_exists(const struct osw_drv_ut_drv_priv *priv,
+                          const char *phy_name)
+{
+    for (; priv->phy_name; priv++)
+        if (strcmp(priv->phy_name, phy_name) == 0)
+            return true;
+
+    return false;
+}
+
+static bool
+osw_drv_ut_drv_vif_exists(const struct osw_drv_ut_drv_priv *priv,
+                          const char *phy_name,
+                          const char *vif_name)
+{
+    size_t i;
+    for (; priv->phy_name; priv++)
+        if (strcmp(priv->phy_name, phy_name) == 0)
+            for (i = 0; i < ARRAY_SIZE(priv->vif_names) && priv->vif_names[i] != NULL; i++)
+                if (strcmp(priv->vif_names[i], vif_name) == 0)
+                    return true;
+
+    return false;
+}
+
+static bool
+osw_drv_ut_drv_sta_connected(const struct osw_drv_ut_drv_priv *priv,
+                             const char *phy_name,
+                             const char *vif_name,
+                             const struct osw_hwaddr *mac_addr)
+{
+    size_t i;
+    for (; priv->phy_name; priv++)
+        if (strcmp(priv->phy_name, phy_name) == 0)
+            for (i = 0; i < ARRAY_SIZE(priv->stas); i++)
+                if (priv->stas[i].vif_name != NULL)
+                    if (strcmp(priv->stas[i].vif_name, vif_name) == 0)
+                        if (memcmp(&priv->stas[i].mac_addr, mac_addr, sizeof(*mac_addr)) == 0)
+                            return true;
+
+    return false;
+}
+
+static int
+osw_drv_ut_drv_sta_duration(const struct osw_drv_ut_drv_priv *priv,
+                            const char *phy_name,
+                            const char *vif_name,
+                            const struct osw_hwaddr *mac_addr)
+{
+    size_t i;
+    for (; priv->phy_name; priv++)
+        if (strcmp(priv->phy_name, phy_name) == 0)
+            for (i = 0; i < ARRAY_SIZE(priv->stas); i++)
+                if (priv->stas[i].vif_name != NULL)
+                    if (strcmp(priv->stas[i].vif_name, vif_name) == 0)
+                        if (memcmp(&priv->stas[i].mac_addr, mac_addr, sizeof(*mac_addr)) == 0)
+                            return priv->stas[i].duration;
+
+    return 0;
+}
+
+static void
+osw_drv_ut_drv_init_1_cb(struct osw_drv *drv)
+{
+    drv1_priv[0].drv = drv;
+    osw_drv_set_priv(drv, drv1_priv);
+}
+
+static void
+osw_drv_ut_drv_init_2_cb(struct osw_drv *drv)
+{
+    drv2_priv[0].drv = drv;
+    osw_drv_set_priv(drv, drv2_priv);
+}
+
+static void
+osw_drv_ut_drv_get_phy_list_cb(struct osw_drv *drv,
+                               osw_drv_report_phy_fn_t *report_phy_fn,
+                               void *fn_priv)
+{
+    const struct osw_drv_ut_drv_priv *priv = osw_drv_get_priv(drv);
+    for (; priv->phy_name != NULL; priv++)
+        if (strlen(priv->phy_name) > 0)
+            report_phy_fn(priv->phy_name, fn_priv);
+}
+
+static void
+osw_drv_ut_drv_get_vif_list_cb(struct osw_drv *drv,
+                               const char *phy_name,
+                               osw_drv_report_vif_fn_t *report_vif_fn,
+                               void *fn_priv)
+{
+    const struct osw_drv_ut_drv_priv *priv = osw_drv_get_priv(drv);
+    const char *const*vif_name;
+    for (; priv->phy_name; priv++)
+        if (strcmp(priv->phy_name, phy_name) == 0)
+            for (vif_name = priv->vif_names; *vif_name != NULL; vif_name++)
+                report_vif_fn(*vif_name, fn_priv);
+}
+
+static void
+osw_drv_ut_drv_get_sta_list_cb(struct osw_drv *drv,
+                               const char *phy_name,
+                               const char *vif_name,
+                               osw_drv_report_sta_fn_t *report_sta_fn,
+                               void *fn_priv)
+{
+    const struct osw_drv_ut_drv_priv *priv = osw_drv_get_priv(drv);
+    size_t i;
+    for (; priv->phy_name; priv++)
+        if (strcmp(priv->phy_name, phy_name) == 0)
+            for (i = 0; i < ARRAY_SIZE(priv->stas); i++)
+                if (priv->stas[i].vif_name != NULL)
+                    if (strcmp(priv->stas[i].vif_name, vif_name) == 0)
+                        report_sta_fn(&priv->stas[i].mac_addr, fn_priv);
+}
+
+static void
+osw_drv_ut_drv_request_phy_state_cb(struct osw_drv *drv,
+                                    const char *phy_name)
+{
+    const struct osw_drv_ut_drv_priv *priv = osw_drv_get_priv(drv);
+    const struct osw_drv_phy_state info = {
+        .exists = osw_drv_ut_drv_phy_exists(priv, phy_name),
+    };
+    printf("%s: phy_name=%s exists=%d\n", __func__, phy_name, info.exists);
+    osw_drv_report_phy_state(priv->drv, phy_name, &info);
+}
+
+static void
+osw_drv_ut_drv_request_vif_state_cb(struct osw_drv *drv,
+                                    const char *phy_name,
+                                    const char *vif_name)
+{
+    const struct osw_drv_ut_drv_priv *priv = osw_drv_get_priv(drv);
+    struct osw_drv_vif_state info = {0};
+    size_t i;
+
+    for (i = 0; i < ARRAY_SIZE(vifs); i++)
+        if (strcmp(vifs[i].vif_name, vif_name) == 0)
+            break;
+
+    info.exists = osw_drv_ut_drv_vif_exists(priv, phy_name, vif_name),
+    info.vif_type = OSW_VIF_AP;
+
+    if (i != ARRAY_SIZE(vifs))
+        memcpy(&info, &vifs[i].state, sizeof(info));
+
+
+    printf("%s: vif_name=%s exists=%d\n", __func__, vif_name, info.exists);
+    osw_drv_report_vif_state(priv->drv, phy_name, vif_name, &info);
+}
+
+static void
+osw_drv_ut_drv_request_sta_state_cb(struct osw_drv *drv,
+                                    const char *phy_name,
+                                    const char *vif_name,
+                                    const struct osw_hwaddr *mac_addr)
+{
+    const struct osw_drv_ut_drv_priv *priv = osw_drv_get_priv(drv);
+    const struct osw_drv_sta_state info = {
+        .connected = osw_drv_ut_drv_sta_connected(priv, phy_name, vif_name, mac_addr),
+        .connected_duration_seconds = osw_drv_ut_drv_sta_duration(priv, phy_name, vif_name, mac_addr),
+    };
+    printf("%s: sta_addr=" OSW_HWADDR_FMT " connected=%d\n", __func__, OSW_HWADDR_ARG(mac_addr), info.connected);
+    osw_drv_report_sta_state(priv->drv, phy_name, vif_name, mac_addr, &info);
+}
+
+static void
+osw_drv_ut_drv_request_config_cb(struct osw_drv *drv,
+                                 struct osw_drv_conf *conf)
+{
+    const struct osw_drv_ut_drv_priv *priv = osw_drv_get_priv(drv);
+    const struct osw_drv_phy_config *phy = conf->phy_list;
+    size_t n_phy = conf->n_phy_list;
+
+    printf("%s: priv=%p, n_phy=%zd begin\n", __func__, priv, n_phy);
+    for (; n_phy > 0; n_phy--, phy++)
+        printf("%s: phy_name=%s\n", __func__, phy->phy_name);
+
+    printf("%s: priv=%p, n_phy=%zd end\n", __func__, priv, n_phy);
+    osw_drv_conf_free(conf);
+}
+
+// FIXME rename
+static void
+osw_drv_ut_core1_op_phy_added_cb(struct osw_state_observer *observer, const struct osw_state_phy_info *info)
+{
+    printf("%s: %s\n", __func__, info->phy_name);
+}
+
+static void
+osw_drv_ut_core1_op_phy_removed_cb(struct osw_state_observer *observer, const struct osw_state_phy_info *info)
+{
+    printf("%s: %s\n", __func__, info->phy_name);
+}
+
+static void
+osw_drv_ut_core1_op_phy_changed_cb(struct osw_state_observer *observer, const struct osw_state_phy_info *info)
+{
+    printf("%s: %s\n", __func__, info->phy_name);
+}
+
+static void
+osw_drv_ut_core1_op_vif_added_cb(struct osw_state_observer *observer, const struct osw_state_vif_info *info)
+{
+    printf("%s: %s/%s\n", __func__, info->phy->phy_name, info->vif_name);
+}
+
+static void
+osw_drv_ut_core1_op_vif_removed_cb(struct osw_state_observer *observer, const struct osw_state_vif_info *info)
+{
+    printf("%s: %s/%s\n", __func__, info->phy->phy_name, info->vif_name);
+}
+
+static void
+osw_drv_ut_core1_op_vif_changed_cb(struct osw_state_observer *observer, const struct osw_state_vif_info *info)
+{
+    printf("%s: %s/%s\n", __func__, info->phy->phy_name, info->vif_name);
+}
+
+static void
+osw_drv_ut_core1_op_sta_connected_cb(struct osw_state_observer *observer, const struct osw_state_sta_info *info)
+{
+    printf("%s: %s/%s/" OSW_HWADDR_FMT "\n", __func__, info->vif->phy->phy_name, info->vif->vif_name, OSW_HWADDR_ARG(info->mac_addr));
+}
+
+static void
+osw_drv_ut_core1_op_sta_disconnected_cb(struct osw_state_observer *observer, const struct osw_state_sta_info *info)
+{
+    printf("%s: %s/%s/" OSW_HWADDR_FMT "\n", __func__, info->vif->phy->phy_name, info->vif->vif_name, OSW_HWADDR_ARG(info->mac_addr));
+}
+
+static void
+osw_drv_ut_core1_op_sta_changed_cb(struct osw_state_observer *observer, const struct osw_state_sta_info *info)
+{
+    printf("%s: %s/%s/" OSW_HWADDR_FMT "\n", __func__, info->vif->phy->phy_name, info->vif->vif_name, OSW_HWADDR_ARG(info->mac_addr));
+}
+
+static void
+osw_drv_ut_state_idle_cb(struct osw_state_observer *observer)
+{
+    struct osw_drv_ut_state_obs *obj = container_of(observer, struct osw_drv_ut_state_obs, obs);
+    printf("%s: was busy = %d\n", __func__, obj->busy);
+    obj->busy = false;
+}
+
+static void
+osw_drv_ut_state_busy_cb(struct osw_state_observer *observer)
+{
+    struct osw_drv_ut_state_obs *obj = container_of(observer, struct osw_drv_ut_state_obs, obs);
+    printf("%s: was busy = %d\n", __func__, obj->busy);
+    obj->busy = true;
+}
+
+static void
+osw_drv_ut_work(struct osw_drv_ut_state_obs *obs)
+{
+    int n = 50;
+    do {
+        printf("%s: work %d\n", __func__,  n);
+        ev_run(EV_DEFAULT_ EVRUN_ONCE);
+    } while (n-- > 0 && obs->busy == true);
+    printf("%s: work done\n", __func__);
+    assert(n > 0);
+}
+
+static void
+osw_drv_ut_1_fn(void *data)
+{
+    static const struct osw_drv_ops drv1 = {
+        .name = "drv1",
+        .init_fn = osw_drv_ut_drv_init_1_cb,
+        .get_phy_list_fn = osw_drv_ut_drv_get_phy_list_cb,
+        .get_vif_list_fn = osw_drv_ut_drv_get_vif_list_cb,
+        .get_sta_list_fn = osw_drv_ut_drv_get_sta_list_cb,
+        .request_phy_state_fn = osw_drv_ut_drv_request_phy_state_cb,
+        .request_vif_state_fn = osw_drv_ut_drv_request_vif_state_cb,
+        .request_sta_state_fn = osw_drv_ut_drv_request_sta_state_cb,
+        .request_config_fn = osw_drv_ut_drv_request_config_cb,
+    };
+    static const struct osw_drv_ops drv2 = {
+        .name = "drv2",
+        .init_fn = osw_drv_ut_drv_init_2_cb,
+        .get_phy_list_fn = osw_drv_ut_drv_get_phy_list_cb,
+        .get_vif_list_fn = osw_drv_ut_drv_get_vif_list_cb,
+        .get_sta_list_fn = osw_drv_ut_drv_get_sta_list_cb,
+        .request_phy_state_fn = osw_drv_ut_drv_request_phy_state_cb,
+        .request_vif_state_fn = osw_drv_ut_drv_request_vif_state_cb,
+        .request_sta_state_fn = osw_drv_ut_drv_request_sta_state_cb,
+        .request_config_fn = osw_drv_ut_drv_request_config_cb,
+    };
+    static struct osw_drv_ut_state_obs obs1 = {
+        .busy = false,
+        .obs = {
+            .name = "drv ut 1 state",
+            .idle_fn = osw_drv_ut_state_idle_cb,
+            .busy_fn = osw_drv_ut_state_busy_cb,
+            .phy_added_fn = osw_drv_ut_core1_op_phy_added_cb,
+            .phy_removed_fn = osw_drv_ut_core1_op_phy_removed_cb,
+            .phy_changed_fn = osw_drv_ut_core1_op_phy_changed_cb,
+            .vif_added_fn = osw_drv_ut_core1_op_vif_added_cb,
+            .vif_removed_fn = osw_drv_ut_core1_op_vif_removed_cb,
+            .vif_changed_fn = osw_drv_ut_core1_op_vif_changed_cb,
+            .sta_connected_fn = osw_drv_ut_core1_op_sta_connected_cb,
+            .sta_disconnected_fn = osw_drv_ut_core1_op_sta_disconnected_cb,
+            .sta_changed_fn = osw_drv_ut_core1_op_sta_changed_cb,
+        },
+    };
+
+    osw_drv_init();
+    osw_drv_register_ops(&drv1);
+    osw_drv_register_ops(&drv2);
+    osw_state_register_observer(&obs1.obs);
+    osw_drv_ut_work(&obs1);
+    assert(drv1_priv[0].drv != NULL);
+    assert(drv2_priv[0].drv != NULL);
+    assert(osw_state_phy_lookup("phy1") != NULL);
+    assert(osw_state_phy_lookup("phy2") != NULL);
+    assert(osw_state_phy_lookup("phy3") != NULL);
+
+    {
+        printf("checking conf from state\n");
+
+        struct osw_conf *conf = osw_conf_build_from_state();
+        struct osw_conf_phy *phy;
+        struct osw_conf_vif *vif;
+        struct osw_conf_psk *psk;
+        struct osw_conf_acl *acl;
+        size_t n_phy = 0;
+        size_t n_vif;
+        size_t n_psk;
+        size_t n_acl;
+        int key_id;
+
+        ds_tree_foreach(&conf->phy_tree, phy) n_phy++;
+        assert(n_phy == 3);
+
+        phy = ds_tree_find(&conf->phy_tree, "phy1"); assert(phy != NULL);
+        vif = ds_tree_find(&phy->vif_tree, "vif1"); assert(vif != NULL); assert(vif->phy == phy);
+        key_id = 1; psk = ds_tree_find(&vif->u.ap.psk_tree, &key_id);
+        assert(psk != NULL);
+        assert(strcmp(psk->ap_psk.psk.str, vifs[0].state.u.ap.psk_list.list[0].psk.str) == 0);
+        assert(strcmp(psk->ap_psk.psk.str, vifs[0].state.u.ap.psk_list.list[1].psk.str) != 0);
+        key_id = 2; psk = ds_tree_find(&vif->u.ap.psk_tree, &key_id);
+        assert(psk != NULL);
+        assert(strcmp(psk->ap_psk.psk.str, vifs[0].state.u.ap.psk_list.list[0].psk.str) != 0);
+        assert(strcmp(psk->ap_psk.psk.str, vifs[0].state.u.ap.psk_list.list[1].psk.str) == 0);
+        acl = ds_tree_find(&vif->u.ap.acl_tree, vifs[0].state.u.ap.acl.list[0].octet); assert(acl != NULL);
+        acl = ds_tree_find(&vif->u.ap.acl_tree, vifs[0].state.u.ap.acl.list[1].octet); assert(acl != NULL);
+        acl = ds_tree_find(&vif->u.ap.acl_tree, vifs[0].state.u.ap.acl.list[2].octet); assert(acl != NULL);
+        n_psk = 0; ds_tree_foreach(&vif->u.ap.psk_tree, psk) n_psk++; assert(n_psk == 2);
+        n_acl = 0; ds_tree_foreach(&vif->u.ap.acl_tree, acl) n_acl++; assert(n_acl == 3);
+        vif = ds_tree_find(&phy->vif_tree, "vif2"); assert(vif != NULL); assert(vif->phy == phy);
+        acl = ds_tree_find(&vif->u.ap.acl_tree, vifs[0].state.u.ap.acl.list[0].octet); assert(acl == NULL);
+        n_psk = 0; ds_tree_foreach(&vif->u.ap.psk_tree, psk) n_psk++; assert(n_psk == 0);
+        n_acl = 0; ds_tree_foreach(&vif->u.ap.acl_tree, acl) n_acl++; assert(n_acl == 0);
+        n_vif = 0; ds_tree_foreach(&phy->vif_tree, vif) n_vif++; assert(n_vif == 2);
+
+        phy = ds_tree_find(&conf->phy_tree, "phy2"); assert(phy != NULL);
+        vif = ds_tree_find(&phy->vif_tree, "vif3"); assert(vif != NULL); assert(vif->phy == phy);
+        n_psk = 0; ds_tree_foreach(&vif->u.ap.psk_tree, psk) n_psk++; assert(n_psk == 0);
+        n_acl = 0; ds_tree_foreach(&vif->u.ap.acl_tree, acl) n_acl++; assert(n_acl == 0);
+        n_vif = 0; ds_tree_foreach(&phy->vif_tree, vif) n_vif++; assert(n_vif == 1);
+
+        phy = ds_tree_find(&conf->phy_tree, "phy3"); assert(phy != NULL);
+        vif = ds_tree_find(&phy->vif_tree, "vif4"); assert(vif != NULL); assert(vif->phy == phy);
+        n_psk = 0; ds_tree_foreach(&vif->u.ap.psk_tree, psk) n_psk++; assert(n_psk == 0);
+        n_acl = 0; ds_tree_foreach(&vif->u.ap.acl_tree, acl) n_acl++; assert(n_acl == 0);
+        n_vif = 0; ds_tree_foreach(&phy->vif_tree, vif) n_vif++; assert(n_vif == 1);
+    }
+
+    #if 0
+    {
+        struct osw_drv_phy_config phy[4] = {0};
+        struct osw_drv_conf conf = {
+            .phy_list = phy,
+            .n_phy_list = ARRAY_SIZE(phy),
+        };
+        phy[0].phy_name = "phy1";
+        phy[1].phy_name = "phy3";
+        phy[2].phy_name = "phy2";
+        phy[3].phy_name = "phy4";
+        osw_req_config(&conf);
+        //osw_core_request_config(&conf);
+    }
+    #endif
+
+    printf("remove phy2\n");
+    drv1_priv[1].phy_name = "";
+    osw_drv_report_phy_changed(drv1_priv[0].drv, "phy2");
+    osw_drv_ut_work(&obs1);
+    assert(osw_state_phy_lookup("phy2") == NULL);
+    assert(osw_state_vif_lookup("phy2", "vif3") == NULL);
+
+    printf("add phy4\n");
+    drv1_priv[1].phy_name = "phy4";
+    osw_drv_report_phy_changed(drv1_priv[0].drv, "phy4");
+    osw_drv_ut_work(&obs1);
+    assert(osw_state_phy_lookup("phy4") != NULL);
+    assert(osw_state_vif_lookup("phy4", "vif3") != NULL);
+
+    printf("blip phy5\n");
+    drv1_priv[1].phy_name = "";
+    osw_drv_report_phy_changed(drv1_priv[0].drv, "phy5");
+    osw_drv_ut_work(&obs1);
+    assert(osw_state_phy_lookup("phy4") == NULL);
+    assert(osw_state_phy_lookup("phy5") == NULL);
+    assert(osw_state_vif_lookup("phy4", "vif3") == NULL);
+
+    printf("inject bad csa event\n");
+    osw_drv_report_vif_channel_change_started(drv1_priv[0].drv, "phy10", "vif10", NULL);
+    osw_drv_ut_work(&obs1);
+    assert(osw_state_phy_lookup("phy10") == NULL);
+    assert(osw_state_vif_lookup("phy10", "vif10") == NULL);
+
+    printf("inject sta\n");
+    drv1_priv[0].stas[0].vif_name = "vif1";
+    drv1_priv[0].stas[0].mac_addr.octet[0] = 0x00;
+    drv1_priv[0].stas[0].mac_addr.octet[1] = 0x11;
+    drv1_priv[0].stas[0].mac_addr.octet[2] = 0x22;
+    drv1_priv[0].stas[0].mac_addr.octet[3] = 0x33;
+    drv1_priv[0].stas[0].mac_addr.octet[4] = 0x44;
+    drv1_priv[0].stas[0].mac_addr.octet[5] = 0x55;
+    drv1_priv[0].stas[0].duration = 2; /* simulates connection happened 2 seconds ago */
+    osw_drv_report_sta_changed(drv1_priv[0].drv, "phy1", "vif1", &drv1_priv[0].stas[0].mac_addr);
+    osw_drv_ut_work(&obs1);
+    assert(osw_state_sta_lookup("phy1", "vif1", &drv1_priv[0].stas[0].mac_addr) != NULL);
+
+    printf("inject 2nd sta, other vif\n");
+    drv2_priv[0].stas[0].vif_name = "vif4";
+    drv2_priv[0].stas[0].mac_addr.octet[0] = 0x00;
+    drv2_priv[0].stas[0].mac_addr.octet[1] = 0x11;
+    drv2_priv[0].stas[0].mac_addr.octet[2] = 0x22;
+    drv2_priv[0].stas[0].mac_addr.octet[3] = 0x33;
+    drv2_priv[0].stas[0].mac_addr.octet[4] = 0x44;
+    drv2_priv[0].stas[0].mac_addr.octet[5] = 0x55;
+    drv2_priv[0].stas[0].duration = 1; /* simulates connection happened 1 seconds ago */
+    osw_drv_report_sta_changed(drv2_priv[0].drv, "phy3", "vif4", &drv2_priv[0].stas[0].mac_addr);
+    osw_drv_ut_work(&obs1);
+    assert(osw_state_sta_lookup("phy1", "vif1", &drv1_priv[0].stas[0].mac_addr) != NULL);
+    assert(osw_state_sta_lookup("phy3", "vif4", &drv2_priv[0].stas[0].mac_addr) != NULL);
+    assert(osw_state_sta_lookup_newest(&drv2_priv[0].stas[0].mac_addr) != NULL);
+    assert(osw_state_sta_lookup("phy3", "vif4", &drv2_priv[0].stas[0].mac_addr) ==
+           osw_state_sta_lookup_newest(&drv2_priv[0].stas[0].mac_addr));
+
+    printf("flip 2nd sta\n");
+    drv2_priv[0].stas[0].duration = 5; /* simulates connection happened 5 seconds ago */
+    osw_drv_report_sta_changed(drv2_priv[0].drv, "phy3", "vif4", &drv2_priv[0].stas[0].mac_addr);
+    osw_drv_ut_work(&obs1);
+    assert(osw_state_sta_lookup("phy1", "vif1", &drv1_priv[0].stas[0].mac_addr) != NULL);
+    assert(osw_state_sta_lookup("phy3", "vif4", &drv2_priv[0].stas[0].mac_addr) != NULL);
+    assert(osw_state_sta_lookup_newest(&drv2_priv[0].stas[0].mac_addr) != NULL);
+    assert(osw_state_sta_lookup("phy1", "vif1", &drv2_priv[0].stas[0].mac_addr) ==
+           osw_state_sta_lookup_newest(&drv2_priv[0].stas[0].mac_addr));
+
+    printf("reconnect 2nd sta\n");
+    drv2_priv[0].stas[0].duration = 1; /* simulates connection happened 1 seconds ago */
+    osw_drv_report_sta_changed(drv2_priv[0].drv, "phy3", "vif4", &drv2_priv[0].stas[0].mac_addr);
+    osw_drv_ut_work(&obs1);
+
+    printf("unregister\n");
+    osw_drv_unregister_ops(&drv1);
+    osw_drv_unregister_ops(&drv2);
+    osw_drv_unregister_ops(&drv2); /* intentional double unregister */
+    osw_drv_ut_work(&obs1);
+    assert(osw_state_phy_lookup("phy1") == NULL);
+    assert(osw_state_phy_lookup("phy3") == NULL);
+
+    printf("unregister2\n");
+    osw_drv_unregister_ops(&drv2); /* intentional triple unregister */
+    osw_drv_ut_work(&obs1);
+}
+
+static void
+osw_drv_ut_init(void *data)
+{
+    osw_ut_register("osw_drv_ut_1", osw_drv_ut_1_fn, NULL);
+}
+
+static void
+osw_drv_ut_fini(void *data)
+{
+}
+
+MODULE(osw_drv_ut, osw_drv_ut_init, osw_drv_ut_fini);
Index: device-core/src/lib/osw/src/osw_drv_wifihal_3_0.c
===================================================================
--- /dev/null
+++ device-core/src/lib/osw/src/osw_drv_wifihal_3_0.c
@@ -0,0 +1,1925 @@
+/* libc */
+#include <pthread.h>
+#include <string.h>
+#include <inttypes.h>
+#include <dlfcn.h>
+
+/* opensync */
+#include <const.h>
+#include <ds_tree.h>
+#include <log.h>
+#include <util.h>
+#include <memutil.h>
+#include <os_time.h>
+#include <osw_drv.h>
+#include <osw_conf.h>
+
+/* 3rd party */
+#include <ev.h>
+
+#ifndef __WIFI_HAL_H__
+#include "ccsp/wifi_hal.h"
+#endif
+
+#define MAC_LEN 6
+#define DRV_NAME "wifihal_3_0"
+
+/* FIXME: Measure all WifiHAL call timings and report if they take too long. */
+#define MEASURE_MAX 500
+#define MEASURE(fn, args) \
+({ \
+    int64_t a = clock_mono_ms(); \
+    LOGT("%sL%d@%s: [%s] begin %"PRIu64" msec", __FILE__, __LINE__, __func__, #fn, a); \
+    typeof(fn args) __x = fn args; \
+    int64_t b = clock_mono_ms(); \
+    LOGT("%sL%d@%s: [%s] end %"PRIu64" msec", __FILE__, __LINE__, __func__, #fn, b); \
+    int64_t c = b - a; \
+    LOGD("%sL%d@%s: [%s] took %"PRIu64" msec", __FILE__, __LINE__, __func__, #fn, c); \
+    if (c >= MEASURE_MAX) \
+        LOGW("%sL%d@%s: [%s] took too long, %"PRIu64" > %d", __FILE__, __LINE__, __func__, #fn, c, MEASURE_MAX); \
+    __x; \
+})
+
+
+INT wifihal_stub() /* () means any argument list is valid */
+{
+    return RETURN_ERR;
+}
+
+struct wifihal_3_0_sta_id {
+    UINT ap_index;
+    struct osw_hwaddr addr;
+};
+
+struct wifihal_3_0_sta {
+    struct ds_tree_node node;
+    struct wifihal_3_0_sta_id id;
+};
+
+struct wifihal_3_0_priv {
+    struct ev_loop *loop;
+    struct osw_drv *drv;
+    struct osw_conf_mutator conf_mut;
+    pthread_mutex_t lock;
+    ev_async async;
+    struct ds_tree sta_tree;
+    int n_events;
+
+    INT (*wifi_getRadioIfName)(INT radioIndex, CHAR *output_string);
+    INT (*wifi_getApName)(INT apIndex, CHAR *output_string);
+    INT (*wifi_getApAssociatedDeviceDiagnosticResult)(INT apIndex, wifi_associated_dev_t **associated_dev_array, UINT *output_array_size);
+    INT (*wifi_getRadioDfsSupport)(INT radioIndex, BOOL *output_bool);
+    INT (*wifi_getRadioDfsEnable)(INT radioIndex, BOOL *output_bool);
+    INT (*wifi_getRadioChannels)(INT radioIndex, wifi_channelMap_t *output_map, INT output_map_size);
+    INT (*wifi_getApAclDeviceNum)(INT apIndex, UINT *output_uint);
+    //INT (*wifi_getApAclDevices)(INT apIndex, mac_address_t *macArray, UINT maxArraySize, UINT* output_numEntries);
+    INT (*wifi_getApAclDevices)(INT apIndex, CHAR *macArray, UINT buf_size);
+    // INT (*wifi_addApAclDevice)(INT apIndex, mac_address_t DeviceMacAddress);         // adds the mac address to the filter list
+    INT (*wifi_addApAclDevice)(INT apIndex, CHAR *DeviceMacAddress);         // adds the mac address to the filter list
+    INT (*wifi_delApAclDevices)(INT apINdex);
+    INT (*wifi_steering_clientDisconnect)(UINT steeringgroupIndex, INT apIndex, mac_address_t client_mac, wifi_disconnectType_t type, UINT reason);
+    INT (*wifi_pushRadioChannel2)(INT radioIndex, UINT channel, UINT channel_width_MHz, UINT csa_beacon_count);
+    INT (*wifi_createVAP)(wifi_radio_index_t index, wifi_vap_info_map_t *map);
+    INT (*wifi_setRadioOperatingParameters)(wifi_radio_index_t index, wifi_radio_operationParam_t *operationParam);
+    INT (*wifi_setRadioDfsEnable)(INT radioIndex, BOOL enabled);
+    INT (*wifi_getRadioOperatingParameters)(wifi_radio_index_t index, wifi_radio_operationParam_t *operationParam);
+    INT (*wifi_getRadioVapInfoMap)(wifi_radio_index_t index, wifi_vap_info_map_t *map);
+    INT (*wifi_pushMultiPskKeys)(INT apIndex, wifi_key_multi_psk_t *keys, INT keysNumber);
+    INT (*wifi_getMultiPskKeys)(INT apIndex, wifi_key_multi_psk_t *keys, INT keysNumber);
+    INT (*wifi_getMultiPskClientKey)(INT apIndex, mac_address_t mac, wifi_key_multi_psk_t *key);
+    INT (*wifi_getHalVersion)(CHAR *output_string);
+    void (*wifi_newApAssociatedDevice_callback_register)(wifi_newApAssociatedDevice_callback callback_proc);
+    void (*wifi_apDisassociatedDevice_callback_register)(wifi_apDisassociatedDevice_callback callback_proc);
+    void (*wifi_apDeAuthEvent_callback_register)(wifi_apDeAuthEvent_callback callback_proc);
+
+    /* FIXME: This structure could be used to keep a local
+     * working copy of vap map for easier lookups as well as
+     * more robust and async reconfig arch.
+     */
+};
+
+#define DLSYM(fn, stub) \
+    do { \
+        priv->wifi_##fn = dlsym(NULL, "wifi_hal_"#fn) ?: (dlsym(NULL, "wifi_"#fn) ?: stub); \
+        LOGI("%s: %s = %p (%s)", __func__, \
+             #fn, \
+             priv->wifi_##fn, \
+             (priv->wifi_##fn == NULL \
+              ? "null" \
+              : ((void *)priv->wifi_##fn == (void *)stub ? "stub" : "real"))); \
+    } while (0)
+
+typedef void sta_walk_fn_t(struct wifihal_3_0_sta *sta, void *fn_priv);
+typedef bool vap_walk_fn_t(wifi_vap_info_t *vap, void *fn_priv);
+
+static int
+sta_id_cmp(const void *a, const void *b)
+{
+    const struct wifihal_3_0_sta_id *x = a;
+    const struct wifihal_3_0_sta_id *y = b;
+    return memcmp(x, y, sizeof(*x));
+}
+
+static bool
+drv_is_enabled(void)
+{
+    if (getenv("OSW_DRV_WIFIHAL_3_0_DISABLED") == NULL)
+        return true;
+    else
+        return false;
+}
+
+static bool
+phy_name_to_radio_index(const char *phy_name,
+                        wifi_radio_index_t *radio_index);
+
+static void
+osw_conf_mutate_errata_beacon_interval(struct wifihal_3_0_priv *priv,
+                                       struct osw_conf *conf)
+{
+    /* FIXME: This should only be applied conditionally on
+     * platforms where Wifi HAL implementation isn't
+     * properly respecting setting beacon interval.
+     */
+
+    struct osw_conf_phy *phy;
+    ds_tree_foreach(&conf->phy_tree, phy) {
+        wifi_radio_index_t rix;
+
+        if (phy_name_to_radio_index(phy->phy_name, &rix) == false)
+            continue;
+
+        wifi_radio_operationParam_t params = {0};
+        if (MEASURE(priv->wifi_getRadioOperatingParameters, (rix, &params)) != RETURN_OK)
+            continue;
+
+        struct osw_conf_vif *vif;
+        ds_tree_foreach(&phy->vif_tree, vif) {
+            if (vif->vif_type != OSW_VIF_AP)
+                continue;
+            if (vif->u.ap.beacon_interval_tu == (int)params.beaconInterval)
+                continue;
+
+            LOGI("osw: drv: wifihal: %s/%s: overriding beacon interval %d -> %u, errata",
+                    phy->phy_name, vif->vif_name,
+                    vif->u.ap.beacon_interval_tu,
+                    params.beaconInterval);
+
+            vif->u.ap.beacon_interval_tu = params.beaconInterval;
+        }
+    }
+}
+
+static void
+osw_conf_mutate_errata_2ghz_vht(struct wifihal_3_0_priv *priv,
+                                struct osw_conf *conf)
+{
+    struct osw_conf_phy *phy;
+    ds_tree_foreach(&conf->phy_tree, phy) {
+        wifi_radio_index_t rix;
+
+        if (phy_name_to_radio_index(phy->phy_name, &rix) == false)
+            continue;
+
+        /* rix isn't used. The check is only to verify
+         * the phy in question belongs to Wifi HAL.
+         */
+
+        struct osw_conf_vif *vif;
+        ds_tree_foreach(&phy->vif_tree, vif) {
+            if (vif->vif_type != OSW_VIF_AP)
+                continue;
+
+            struct osw_conf_vif_ap *ap = &vif->u.ap;
+            const int freq = ap->channel.control_freq_mhz;
+            const enum osw_band band = osw_freq_to_band(freq);
+
+            /* FIXME: 11ac is not allowed on 2.4G by the
+             * vanilla spec but vendors have extenstions to do that
+             * anyway. Setting 11ac alone (without 11ax) variant to
+             * Wifi HAL works as expected, but setting both 11ax and
+             * 11ac flags ends up with 11ax being reported back, but
+             * not the 11ac one. OSW provides setting of these
+             * independently and currently, eg. ow_ovsdb will set 11ac
+             * always if 11ax is set (since it doesn't know any
+             * better, and assumes 11ac on 2.4G implies vendor
+             * specific 11ac mode).
+             *
+             * This should be addressed by allowing OSW drivers to
+             * advertise capabilites so that osw_confsync can make an
+             * educated decision on what to do with a setup like this.
+             *
+             * This override makes sure that only a valid config will
+             * be generated as far as Wifi HAL goes.
+             */
+
+            if (ap->mode.vht_enabled == true &&
+                ap->mode.he_enabled == true &&
+                band == OSW_BAND_2GHZ) {
+                LOGI("osw: drv: wifihal: %s/%s: overriding vht_enabled to false, errata",
+                     phy->phy_name, vif->vif_name);
+                ap->mode.vht_enabled = false;
+            }
+        }
+    }
+}
+
+static void
+osw_conf_mutate_cb(struct osw_conf_mutator *mut,
+                   struct osw_conf *conf)
+{
+    struct wifihal_3_0_priv *priv;
+    priv = container_of(mut, struct wifihal_3_0_priv, conf_mut);
+
+    osw_conf_mutate_errata_beacon_interval(priv, conf);
+    osw_conf_mutate_errata_2ghz_vht(priv, conf);
+}
+
+static struct wifihal_3_0_priv g_priv = {
+    .sta_tree = DS_TREE_INIT(sta_id_cmp, struct wifihal_3_0_sta, node),
+    .conf_mut = {
+        .name = DRV_NAME,
+        .mutate_fn = osw_conf_mutate_cb,
+    },
+};
+
+static struct wifihal_3_0_sta *
+sta_get(struct ds_tree *tree, UINT ap_index, const struct osw_hwaddr *addr)
+{
+    struct wifihal_3_0_sta_id id = {0};
+    id.ap_index = ap_index;
+    id.addr = *addr;
+
+    struct wifihal_3_0_sta *sta = ds_tree_find(tree, &id);
+    if (sta == NULL) {
+        sta = CALLOC(1, sizeof(*sta));
+        sta->id = id;
+        ds_tree_insert(tree, sta, &sta->id);
+    }
+
+    return sta;
+}
+
+static bool
+sta_touch(struct wifihal_3_0_priv *priv,
+          UINT ap_index,
+          const struct osw_hwaddr *addr)
+{
+    struct ds_tree *tree = &priv->sta_tree;
+    struct ev_loop *loop = priv->loop;
+    ev_async *async = &priv->async;
+    pthread_mutex_t *lock = &priv->lock;
+
+    pthread_mutex_lock(lock);
+    struct wifihal_3_0_sta *sta = sta_get(tree, ap_index, addr);
+    pthread_mutex_unlock(lock);
+
+    if (sta == NULL)
+        return false;
+
+    ev_async_send(loop, async);
+    return true;
+}
+
+static void
+sta_walk(struct wifihal_3_0_priv *priv, sta_walk_fn_t *fn, void *fn_priv)
+{
+    struct ds_tree *tree = &priv->sta_tree;
+    pthread_mutex_t *lock = &priv->lock;
+
+    for (;;) {
+        pthread_mutex_lock(lock);
+        struct wifihal_3_0_sta *sta = ds_tree_head(tree);
+        if (sta != NULL)
+            ds_tree_remove(tree, sta);
+        pthread_mutex_unlock(lock);
+
+        if (sta != NULL)
+            fn(sta, fn_priv);
+
+        FREE(sta);
+        if (sta == NULL)
+            break;
+    }
+}
+
+static void
+vap_walk_buf(wifi_vap_info_map_t *map,
+             vap_walk_fn_t *fn,
+             void *fn_priv)
+{
+    if (WARN_ON(map->num_vaps > ARRAY_SIZE(map->vap_array))) return;
+
+    unsigned int i;
+    for (i = 0; i < map->num_vaps; i++) {
+        wifi_vap_info_t *vap = &map->vap_array[i];
+        size_t max = sizeof(vap->vap_name);
+
+        if (WARN_ON(strnlen(vap->vap_name, max) >= max)) continue;
+        if (WARN_ON(strnlen(vap->vap_name, max) == 0)) continue;
+
+        bool done = fn(vap, fn_priv);
+        if (done == true)
+            return;
+    }
+}
+
+static void
+vap_walk_radio(const struct wifihal_3_0_priv *priv,
+               int radio_index,
+               vap_walk_fn_t *fn,
+               void *fn_priv)
+{
+    wifi_vap_info_map_t map = {0};
+    if (MEASURE(priv->wifi_getRadioVapInfoMap, (radio_index, &map)) != RETURN_OK) return;
+    vap_walk_buf(&map, fn, fn_priv);
+}
+
+static void
+vap_walk(const struct wifihal_3_0_priv *priv,
+         vap_walk_fn_t *fn,
+         void *fn_priv)
+{
+    unsigned int i;
+    for (i = 0; i < MAX_NUM_RADIOS; i++)
+        vap_walk_radio(priv, i, fn, fn_priv);
+}
+
+static bool
+vap_walk_index_to_info_cb(wifi_vap_info_t *vap, void *fn_priv)
+{
+    void **p = fn_priv;
+    const wifi_vap_index_t *ap_index = p[0];
+    if (vap->vap_index != *ap_index) return false;
+    p[1] = vap;
+    return true;
+}
+
+static bool
+vap_walk_name_to_info_cb(wifi_vap_info_t *vap, void *fn_priv)
+{
+    void **p = fn_priv;
+    const char *vif_name = p[0];
+    if (strcmp(vap->vap_name, vif_name) != 0) return false;
+    p[1] = vap;
+    return true;
+}
+
+static char *
+ap_index_to_phy_name(const struct wifihal_3_0_priv *priv,
+                     UINT ap_index)
+{
+    void *p[2] = { &ap_index, NULL };
+    vap_walk(priv, vap_walk_index_to_info_cb, p);
+
+    const wifi_vap_info_t *vap = p[1];
+    if (vap == NULL) return NULL;
+
+    char buf[MAXIFACENAMESIZE];
+    if (MEASURE(priv->wifi_getRadioIfName, (vap->radio_index, buf)) != RETURN_OK)
+        return NULL;
+
+    buf[MAXIFACENAMESIZE - 1] = 0;
+    if (WARN_ON(strlen(buf) == 0))
+        return NULL;
+
+    return STRDUP(buf);
+}
+
+static char *
+ap_index_to_vif_name(const struct wifihal_3_0_priv *priv,
+                     UINT ap_index)
+{
+    char vif_name[16 + 1] = {0};
+    if (MEASURE(priv->wifi_getApName, (ap_index, vif_name)) != RETURN_OK) return NULL;
+    vif_name[16] = 0;
+    return STRDUP(vif_name);
+}
+
+int
+vif_name_to_ap_index(const struct wifihal_3_0_priv *priv,
+                     const char *vif_name)
+{
+    const void *p[2] = { vif_name, NULL };
+    vap_walk(priv, vap_walk_name_to_info_cb, p);
+    const wifi_vap_info_t *vap = p[1];
+    if (vap == NULL) return -1;
+    return vap->vap_index;
+}
+
+static bool
+vap_walk_rix_name_to_info(const struct wifihal_3_0_priv *priv,
+                          int rix,
+                          const char *vif_name,
+                          wifi_vap_info_t *vap)
+{
+    const void *p[2] = { vif_name, NULL };
+    vap_walk_radio(priv, rix, vap_walk_name_to_info_cb, p);
+    if (p[1] == NULL) return false;
+    memcpy(vap, p[1], sizeof(*vap));
+    return true;
+}
+
+static void
+sta_report_cb(struct wifihal_3_0_sta *sta, void *fn_priv)
+{
+    struct wifihal_3_0_priv *priv = fn_priv;
+    struct osw_drv *drv = priv->drv;
+    const int ap_index = sta->id.ap_index;
+    char *phy_name = ap_index_to_phy_name(priv, ap_index);
+    char *vif_name = ap_index_to_vif_name(priv, ap_index);
+
+    if (phy_name == NULL) {
+        LOGW("%s: failed to get phy_name for ap_index = %d",
+             __func__, ap_index);
+    }
+
+    if (vif_name == NULL) {
+        LOGW("%s: failed to get vif_name for ap_index = %d",
+             __func__, ap_index);
+    }
+
+    if (phy_name != NULL && vif_name != NULL) {
+        osw_drv_report_sta_changed(drv, phy_name, vif_name, &sta->id.addr);
+    }
+
+    FREE(phy_name);
+    FREE(vif_name);
+}
+
+
+static bool
+radio_index_is_phy_name(int radio_index, const char *phy_name)
+{
+    const struct wifihal_3_0_priv *priv = &g_priv;
+    char buf[MAXIFACENAMESIZE] = {0};
+    if (MEASURE(priv->wifi_getRadioIfName, (radio_index, buf)) != RETURN_OK)
+        return false;
+    if (strncmp(phy_name, buf, sizeof(buf)) != 0)
+        return false;
+    return true;
+}
+
+static bool
+phy_name_to_radio_index(const char *phy_name,
+                        wifi_radio_index_t *radio_index)
+{
+    const struct wifihal_3_0_priv *priv = &g_priv;
+    int i;
+
+    for (i = 0; i < MAX_NUM_RADIOS; i++) {
+        char radio_ifname[MAXIFACENAMESIZE] = {0};
+        const size_t max = sizeof(radio_ifname);
+
+        if (MEASURE(priv->wifi_getRadioIfName, (i, radio_ifname)) != RETURN_OK)
+            return false;
+
+        if (strncmp(phy_name, radio_ifname, max) == 0) {
+            *radio_index = (wifi_radio_index_t)i;
+            return true;
+        }
+    }
+
+    return false;
+}
+
+static INT
+sta_connect_cb(INT ap_index, wifi_associated_dev_t *dev)
+{
+    const struct osw_hwaddr *addr = (const void *)dev->cli_MACAddress;
+    LOGI("osw: drv: wifihal: " OSW_HWADDR_FMT ": connected: rssi=%d snr=%d",
+         OSW_HWADDR_ARG(addr), dev->cli_RSSI, dev->cli_SNR);
+    return sta_touch(&g_priv, ap_index, addr);
+}
+
+static INT
+sta_disconnect_cb(INT ap_index, char *mac, INT event_type)
+{
+    struct osw_hwaddr addr = {0};
+    sscanf(mac, OSW_HWADDR_FMT, OSW_HWADDR_SARG(&addr));
+    /* FIXME: Store event_type */
+    LOGI("osw: drv: wifihal: " OSW_HWADDR_FMT ": disconnected: type=%d",
+         OSW_HWADDR_ARG(&addr), event_type);
+    return sta_touch(&g_priv, ap_index, &addr);
+}
+
+static INT
+sta_deauth_cb(int ap_index, char *mac, int reason)
+{
+    struct osw_hwaddr addr = {0};
+    sscanf(mac, OSW_HWADDR_FMT, OSW_HWADDR_SARG(&addr));
+    LOGI("osw: drv: wifihal: " OSW_HWADDR_FMT ": deauthenticated: reason=%d",
+         OSW_HWADDR_ARG(&addr), reason);
+    /* FIXME: Store reason */
+    return sta_touch(&g_priv, ap_index, &addr);
+}
+
+static void
+sta_async_cb(EV_P_ ev_async *arg, int events)
+{
+    struct wifihal_3_0_priv *priv;
+    priv = container_of(arg, struct wifihal_3_0_priv, async);
+    sta_walk(priv, sta_report_cb, priv);
+}
+
+static void
+osw_drv_init_cb(struct osw_drv *drv)
+{
+    struct wifihal_3_0_priv *priv = &g_priv;
+
+    if (drv_is_enabled() == false) return;
+
+    priv->loop = EV_DEFAULT;
+    priv->drv = drv;
+    pthread_mutex_init(&priv->lock, NULL);
+    osw_drv_set_priv(drv, priv);
+
+    ev_async_init(&priv->async, sta_async_cb);
+    ev_async_start(priv->loop, &priv->async);
+    ev_unref(EV_DEFAULT);
+
+    DLSYM(getRadioIfName, wifihal_stub);
+    DLSYM(getApName, wifihal_stub);
+    DLSYM(getApAssociatedDeviceDiagnosticResult, wifihal_stub);
+    DLSYM(getRadioDfsSupport, wifihal_stub);
+    DLSYM(getRadioDfsEnable, wifihal_stub);
+    DLSYM(getRadioChannels, wifihal_stub);
+    DLSYM(getApAclDeviceNum, wifihal_stub);
+    DLSYM(getApAclDevices, wifihal_stub);
+    DLSYM(addApAclDevice, wifihal_stub);
+    DLSYM(delApAclDevices, wifihal_stub);
+    DLSYM(steering_clientDisconnect, wifihal_stub);
+    DLSYM(pushRadioChannel2, wifihal_stub);
+    DLSYM(createVAP, wifihal_stub);
+    DLSYM(setRadioOperatingParameters, wifihal_stub);
+    DLSYM(setRadioDfsEnable, wifihal_stub);
+    DLSYM(getRadioOperatingParameters, wifihal_stub);
+    DLSYM(getRadioVapInfoMap, wifihal_stub);
+    DLSYM(pushMultiPskKeys, NULL);
+    DLSYM(getMultiPskKeys, NULL);
+    DLSYM(getMultiPskClientKey, NULL);
+    DLSYM(newApAssociatedDevice_callback_register, wifihal_stub);
+    DLSYM(apDisassociatedDevice_callback_register, wifihal_stub);
+    DLSYM(apDeAuthEvent_callback_register, wifihal_stub);
+    DLSYM(getHalVersion, wifihal_stub);
+
+    priv->wifi_newApAssociatedDevice_callback_register(sta_connect_cb);
+    priv->wifi_apDisassociatedDevice_callback_register(sta_disconnect_cb);
+    priv->wifi_apDeAuthEvent_callback_register(sta_deauth_cb);
+
+    char ver[64] = {0};
+    priv->wifi_getHalVersion(ver);
+    LOGI("osw: drv: wifihal: version '%s' advertised", ver);
+    if (strstr(ver, "3.0") != ver)
+        LOGI("osw: drv: wifihal: only API 3.0.x is supported");
+
+    osw_conf_register_mutator(&priv->conf_mut);
+}
+
+static void
+osw_drv_get_phy_list_cb(struct osw_drv *drv,
+                        osw_drv_report_phy_fn_t *report_phy_fn,
+                        void *fn_priv)
+{
+    if (drv_is_enabled() == false) return;
+
+    const struct wifihal_3_0_priv *priv = osw_drv_get_priv(drv);
+    int i;
+    char radio_ifname[MAXIFACENAMESIZE] = {0};
+
+    for (i = 0; i < MAX_NUM_RADIOS; i++) {
+        if (MEASURE(priv->wifi_getRadioIfName, (i, radio_ifname)) != RETURN_OK)
+            continue;
+
+        report_phy_fn(radio_ifname, fn_priv);
+    }
+}
+
+static void
+osw_drv_get_vif_list_cb(struct osw_drv *drv,
+                        const char *phy_name,
+                        osw_drv_report_vif_fn_t *report_vif_fn,
+                        void *fn_priv)
+{
+    if (drv_is_enabled() == false) return;
+
+    const struct wifihal_3_0_priv *priv = osw_drv_get_priv(drv);
+    unsigned int i;
+
+    for (i = 0; i < MAX_NUM_RADIOS; i++) {
+        wifi_vap_info_map_t map = {0};
+        if (MEASURE(priv->wifi_getRadioVapInfoMap, (i, &map)) != RETURN_OK) continue;
+        if (WARN_ON(map.num_vaps > ARRAY_SIZE(map.vap_array))) continue;
+
+        unsigned int j;
+        for (j = 0; j < map.num_vaps; j++) {
+            const wifi_vap_info_t *vap = &map.vap_array[j];
+
+            if (WARN_ON(i != vap->radio_index)) continue;
+            if (radio_index_is_phy_name(i, phy_name) == false) continue;
+
+            const char *vif_name = vap->vap_name;
+            size_t max = sizeof(vap->vap_name);
+            if (WARN_ON(strnlen(vif_name, max) >= max)) continue;
+
+            report_vif_fn(vif_name, fn_priv);
+        }
+    }
+}
+
+static void
+osw_drv_get_sta_list_cb(struct osw_drv *drv,
+                        const char *phy_name,
+                        const char *vif_name,
+                        osw_drv_report_sta_fn_t *report_sta_fn,
+                        void *fn_priv)
+{
+    if (drv_is_enabled() == false) return;
+
+    const struct wifihal_3_0_priv *priv = osw_drv_get_priv(drv);
+    int ap_index = vif_name_to_ap_index(priv, vif_name);
+    wifi_associated_dev_t *sta = NULL;
+    UINT n_sta = 0;
+    UINT i;
+
+    if (WARN_ON(ap_index < 0)) return;
+
+    if (MEASURE(priv->wifi_getApAssociatedDeviceDiagnosticResult, (ap_index, &sta, &n_sta)) != RETURN_OK) {
+        LOGE("%s: cannot get associated device diagnostic result for vap_index: %d",
+             __func__, ap_index);
+        return;
+    }
+
+    for (i = 0; i < n_sta; i++) {
+        struct osw_hwaddr addr;
+        memcpy(addr.octet, sta[i].cli_MACAddress, MAC_LEN);
+        report_sta_fn(&addr, fn_priv);
+    }
+
+    free(sta);
+    return;
+}
+
+static bool
+num_bands(wifi_freq_bands_t band)
+{
+    int bands = 0;
+    while (band > 0) {
+        if (band & 1) bands++;
+        band >>= 1;
+    }
+
+    return bands;
+}
+
+static int
+chan_to_mhz(const wifi_freq_bands_t band, const int c)
+{
+    if (WARN_ON(num_bands(band) != 1))
+        return 0;
+
+    switch (band) {
+        case WIFI_FREQUENCY_2_4_BAND:
+            return 2407 + (c * 5);
+        case WIFI_FREQUENCY_5_BAND:
+        case WIFI_FREQUENCY_5L_BAND:
+        case WIFI_FREQUENCY_5H_BAND:
+            return 5000 + (c * 5);
+        case WIFI_FREQUENCY_6_BAND:
+            if (c == 2) return 5935;
+            else return 5950 + (c * 5);
+        case WIFI_FREQUENCY_60_BAND:
+            LOGW("%s: 60ghz not supported", __func__);
+            return 0;
+    }
+
+    LOGW("%s: called with band: 0x%02x for channel %d",
+         __func__, band, c);
+    return 0;
+}
+
+static enum osw_channel_state_dfs
+chan_state_to_osw(const wifi_channelState_t s)
+{
+    switch (s) {
+        case CHAN_STATE_AVAILABLE: return OSW_CHANNEL_NON_DFS;
+        case CHAN_STATE_DFS_NOP_FINISHED: return OSW_CHANNEL_DFS_CAC_POSSIBLE;
+        case CHAN_STATE_DFS_NOP_START: return OSW_CHANNEL_DFS_NOL;
+        case CHAN_STATE_DFS_CAC_START: return OSW_CHANNEL_DFS_CAC_IN_PROGRESS;
+        case CHAN_STATE_DFS_CAC_COMPLETED: return OSW_CHANNEL_DFS_CAC_COMPLETED;
+    }
+    LOGW("%s: called with state: %d, assuming non-dfs", __func__, s);
+    return OSW_CHANNEL_NON_DFS;
+}
+
+static bool
+mhz_to_chan_band(const int mhz, int *chan, int *band)
+{
+    const int b2ch1 = 2412;
+    const int b2ch13 = 2472;
+    const int b2ch14 = 2484;
+    const int b5ch36 = 5180;
+    const int b5ch177 = 5885;
+    const int b6ch1 = 5955;
+    const int b6ch2 = 5935;
+    const int b6ch233 = 7115;
+
+    if (mhz == b2ch14) {
+        *band = 2;
+        *chan = 14;
+        return true;
+    }
+    if (mhz == b6ch2) {
+        *band = 6;
+        *chan = 2;
+        return true;
+    }
+
+    if (mhz >= b2ch1 && mhz <= b2ch13) {
+        *band = 2;
+        *chan = (mhz - 2407) / 5;
+        return true;
+    }
+
+    if (mhz >= b5ch36 && mhz <= b5ch177) {
+        *band = 5;
+        *chan = (mhz - 5000) / 5;
+        return true;
+    }
+
+    if (mhz >= b6ch1 && mhz <= b6ch233) {
+        *band = 6;
+        *chan = (mhz - 5950) / 5;
+        return true;
+    }
+
+
+    LOGW("%s: unknown frequency: %d", __func__, mhz);
+    return false;
+}
+
+static enum osw_channel_width
+bw_to_osw(const wifi_channelBandwidth_t w)
+{
+    switch (w) {
+        case WIFI_CHANNELBANDWIDTH_20MHZ: return OSW_CHANNEL_20MHZ;
+        case WIFI_CHANNELBANDWIDTH_40MHZ: return OSW_CHANNEL_40MHZ;
+        case WIFI_CHANNELBANDWIDTH_80MHZ: return OSW_CHANNEL_80MHZ;
+        case WIFI_CHANNELBANDWIDTH_160MHZ: return OSW_CHANNEL_160MHZ;
+        case WIFI_CHANNELBANDWIDTH_80_80MHZ: return OSW_CHANNEL_80P80MHZ;
+    }
+
+    LOGW("%s: unknown bandwidth: %d", __func__, w);
+    return OSW_CHANNEL_20MHZ;
+}
+
+static wifi_channelBandwidth_t
+osw_to_bw(enum osw_channel_width w)
+{
+    switch (w) {
+        case OSW_CHANNEL_20MHZ: return WIFI_CHANNELBANDWIDTH_20MHZ;
+        case OSW_CHANNEL_40MHZ: return WIFI_CHANNELBANDWIDTH_40MHZ;
+        case OSW_CHANNEL_80MHZ: return WIFI_CHANNELBANDWIDTH_80MHZ;
+        case OSW_CHANNEL_160MHZ: return WIFI_CHANNELBANDWIDTH_160MHZ;
+        case OSW_CHANNEL_80P80MHZ: return WIFI_CHANNELBANDWIDTH_80_80MHZ;
+    }
+    LOGW("%s: unknown bandwidth: %d", __func__, w);
+    return WIFI_CHANNELBANDWIDTH_20MHZ;
+}
+
+static int
+chan_avg(const int *c)
+{
+    int sum = 0;
+    int n = 0;
+    if (c == NULL)
+        return 0;
+    while (*c) {
+        sum += *c;
+        n++;
+        c++;
+    }
+    return sum / n;
+}
+
+static int
+chan_to_center_2ghz(const wifi_radio_operationParam_t *p)
+{
+    int c[3] = { p->channel, 0, 0 };
+    switch (p->channelWidth) {
+        case WIFI_CHANNELBANDWIDTH_20MHZ:
+            break;
+        case WIFI_CHANNELBANDWIDTH_40MHZ:
+            if (p->numSecondaryChannels >= 1) {
+                c[1] = p->channelSecondary[0];
+            }
+            break;
+        case WIFI_CHANNELBANDWIDTH_80MHZ:
+        case WIFI_CHANNELBANDWIDTH_160MHZ:
+        case WIFI_CHANNELBANDWIDTH_80_80MHZ:
+            /* N/A on 2.4GHz band */
+            break;
+    }
+    return chan_to_mhz(p->band, chan_avg(c));
+}
+
+static int
+chan_to_center_5ghz(const UINT c, const int w)
+{
+    wifi_freq_bands_t b = WIFI_FREQUENCY_5_BAND;
+    return chan_to_mhz(b, chan_avg(unii_5g_chan2list(c, w)));
+}
+
+static int
+chan_to_center_6ghz(const UINT c, const int w)
+{
+    wifi_freq_bands_t b = WIFI_FREQUENCY_6_BAND;
+    return chan_to_mhz(b, chan_avg(unii_6g_chan2list(c, w)));
+}
+
+static int
+bw_to_mhz(const wifi_channelBandwidth_t w)
+{
+    switch (w) {
+        case WIFI_CHANNELBANDWIDTH_20MHZ: return 20;
+        case WIFI_CHANNELBANDWIDTH_40MHZ: return 40;
+        case WIFI_CHANNELBANDWIDTH_80MHZ: return 80;
+        case WIFI_CHANNELBANDWIDTH_160MHZ: return 160;
+        case WIFI_CHANNELBANDWIDTH_80_80MHZ: return 0; /* N/A */
+    }
+    return 0;
+}
+
+static int
+chan_to_center(const wifi_radio_operationParam_t *p)
+{
+    UINT c = p->channel;
+    int w = bw_to_mhz(p->channelWidth);
+
+    switch (p->band) {
+        case WIFI_FREQUENCY_2_4_BAND:
+            return chan_to_center_2ghz(p);
+        case WIFI_FREQUENCY_5_BAND:
+        case WIFI_FREQUENCY_5L_BAND:
+        case WIFI_FREQUENCY_5H_BAND:
+            return chan_to_center_5ghz(c, w);
+        case WIFI_FREQUENCY_6_BAND:
+            return chan_to_center_6ghz(c, w);
+        case WIFI_FREQUENCY_60_BAND:
+            break;
+    }
+
+    LOGW("%s: failed to decode channel center freq", __func__);
+    return 0;
+}
+
+static struct osw_channel
+radio_build_chan(const wifi_radio_operationParam_t *p)
+{
+    struct osw_channel c = {
+        .control_freq_mhz = chan_to_mhz(p->band, p->channel),
+        .center_freq0_mhz = chan_to_center(p),
+        .width = bw_to_osw(p->channelWidth),
+    };
+    return c;
+}
+
+static enum osw_radar_detect
+get_radar(wifi_freq_bands_t band, int rix)
+{
+    const struct wifihal_3_0_priv *priv = &g_priv;
+    static const int band5 = WIFI_FREQUENCY_5_BAND
+                           | WIFI_FREQUENCY_5L_BAND
+                           | WIFI_FREQUENCY_5H_BAND;
+    BOOL b;
+
+    if ((band & band5) == 0)
+        return OSW_RADAR_UNSUPPORTED;
+
+    if (MEASURE(priv->wifi_getRadioDfsSupport, (rix, &b)) != RETURN_OK)
+        return OSW_RADAR_UNSUPPORTED;
+
+    if (b == false)
+        return OSW_RADAR_UNSUPPORTED;
+
+    if (MEASURE(priv->wifi_getRadioDfsEnable, (rix, &b)) != RETURN_OK)
+        return OSW_RADAR_UNSUPPORTED;
+
+    if (b == true)
+        return OSW_RADAR_DETECT_ENABLED;
+    else
+        return OSW_RADAR_DETECT_DISABLED;
+}
+
+static void
+fill_chan_list(const struct wifihal_3_0_priv *priv,
+               int rix,
+               const wifi_freq_bands_t band,
+               struct osw_drv_phy_state *phy)
+{
+    wifi_channelMap_t ch_map[128] = {0};
+    const size_t ch_size = ARRAY_SIZE(ch_map);
+
+    if (WARN_ON(MEASURE(priv->wifi_getRadioChannels, (rix, ch_map, ch_size)) != RETURN_OK))
+        return;
+
+    size_t i;
+    size_t n = 0;
+
+    for (i = 0; i < ch_size; i++)
+        if (ch_map[i].ch_number != 0)
+            n++;
+
+    struct osw_channel_state *cs = CALLOC(n, sizeof(*cs));
+    phy->n_channel_states = n;
+    phy->channel_states = cs;
+
+    for (i = 0; i < ch_size; i++) {
+        const wifi_channelState_t s = ch_map[i].ch_state;
+        const int c = ch_map[i].ch_number;
+
+        if (c == 0) continue;
+
+        cs->channel.control_freq_mhz = chan_to_mhz(band, c);
+        cs->dfs_state = chan_state_to_osw(s);
+        cs++;
+    }
+}
+
+static void
+osw_drv_request_phy_state_cb(struct osw_drv *drv,
+                             const char *phy_name)
+{
+    const struct wifihal_3_0_priv *priv = osw_drv_get_priv(drv);
+    struct osw_drv_phy_state phy = {0};
+    wifi_radio_operationParam_t radio_params = {0};
+    wifi_radio_index_t rix = 0;
+
+    if (phy_name_to_radio_index(phy_name, &rix) == false)
+        goto report;
+
+    if (MEASURE(priv->wifi_getRadioOperatingParameters, (rix, &radio_params)) != WIFI_HAL_SUCCESS) {
+        LOGE("cannot get radio operating parameters for index: %d", rix);
+        goto report;
+    }
+
+    phy.exists = true;
+    phy.enabled = radio_params.enable;
+    phy.radar = get_radar(radio_params.band, rix);
+    fill_chan_list(priv, rix, radio_params.band, &phy);
+    // phy_state.tx_chainmask = ... not supported in RDK
+
+report:
+    osw_drv_report_phy_state(drv, phy_name, &phy);
+    FREE(phy.channel_states);
+}
+
+static enum osw_acl_policy
+bss_get_acl_policy(const wifi_front_haul_bss_t *bss)
+{
+    if (bss->mac_filter_enable == false)
+        return OSW_ACL_NONE;
+
+    switch (bss->mac_filter_mode) {
+        case wifi_mac_filter_mode_black_list:
+            return OSW_ACL_DENY_LIST;
+        case wifi_mac_filter_mode_white_list:
+            return OSW_ACL_ALLOW_LIST;
+    }
+
+    /* Shouldn't be reached */
+    return OSW_ACL_NONE;
+}
+
+static void
+bss_fill_acl(const wifi_vap_info_t *vap,
+             struct osw_drv_vif_state_ap *ap)
+{
+    const struct wifihal_3_0_priv *priv = &g_priv;
+    int ap_index = vap->vap_index;
+    UINT size;
+
+    if (WARN_ON(MEASURE(priv->wifi_getApAclDeviceNum, (ap_index, &size)) != RETURN_OK)) return;
+    if (size == 0) return; /* nothing to do */
+
+#ifdef WIFI_HAL_VERSION_3_PHASE2
+    mac_address_t *macs = CALLOC(size, sizeof(*macs));
+    UINT len = 0;
+
+    if (WARN_ON(MEASURE(priv->wifi_getApAclDevices, (ap_index, macs, size, &len)) != RETURN_OK)) goto end;
+    if (WARN_ON(len > size)) goto end;
+
+    ap->acl.count = len;
+    ap->acl.list = CALLOC(len, sizeof(*ap->acl.list));
+
+    UINT i;
+    for (i = 0; i < len; i++)
+        memcpy(&ap->acl.list[i].octet, macs[i], MAC_LEN);
+
+end:
+    FREE(macs);
+#else
+    char buf[64*1024]; /* should be big enough */
+    char *bufp = buf;
+    char *p;
+
+    size = sizeof(buf);
+    if (WARN_ON(MEASURE(priv->wifi_getApAclDevices, (ap_index, buf, size)) != RETURN_OK)) return;
+    while ((p = strsep(&bufp, "\n")) != NULL) {
+        static struct osw_hwaddr zero;
+        struct osw_hwaddr addr;
+
+        /* FIXME: This could be done better */
+        sscanf(p, OSW_HWADDR_FMT, OSW_HWADDR_SARG(&addr));
+        if (memcmp(&addr, &zero, sizeof(addr)) == 0)
+            continue;
+
+        int n = ++ap->acl.count;
+        ap->acl.list = REALLOC(ap->acl.list, n * sizeof(*ap->acl.list));
+        memcpy(&ap->acl.list[n - 1], &addr, sizeof(addr));
+    }
+#endif
+}
+
+#define MAX_PSK 64
+
+static void
+bss_add_psk(struct osw_drv_vif_state_ap *ap,
+            int key_id,
+            const char *str)
+{
+    size_t n = ++ap->psk_list.count;
+    struct osw_ap_psk **arr = &ap->psk_list.list;
+    size_t size = n * sizeof(**arr);
+    (*arr) = REALLOC(*arr, size);
+    (*arr)[n - 1].key_id = key_id;
+    STRSCPY_WARN((*arr)[n - 1].psk.str, str);
+}
+
+static void
+bss_fill_psk(const wifi_vap_info_t *vap,
+             struct osw_drv_vif_state_ap *ap)
+{
+    struct wifihal_3_0_priv *priv = &g_priv;
+    INT ap_index = vap->vap_index;
+    wifi_key_multi_psk_t keys[MAX_PSK];
+    INT size = ARRAY_SIZE(keys);
+
+    if (priv->wifi_getMultiPskKeys == NULL)
+        return;
+
+    if (WARN_ON(MEASURE(priv->wifi_getMultiPskKeys, (ap_index, keys, size)) != RETURN_OK))
+        return;
+
+    INT i;
+    for (i = 0; i < size; i++) {
+        const char *str = keys[i].wifi_psk;
+        int key_id = atoi(keys[i].wifi_keyId);
+
+        if (strlen(str) < 8) continue;
+        bss_add_psk(ap, key_id, str);
+    }
+}
+
+static enum osw_pmf
+mfp_to_osw_pmf(const wifi_mfp_cfg_t mfp)
+{
+    switch (mfp) {
+        case wifi_mfp_cfg_disabled: return OSW_PMF_DISABLED;
+        case wifi_mfp_cfg_optional: return OSW_PMF_OPTIONAL;
+        case wifi_mfp_cfg_required: return OSW_PMF_REQUIRED;
+    }
+    LOGW("%s: unknown mfp: %d, default to disabled", __func__, mfp);
+    return OSW_PMF_DISABLED;
+}
+
+static void
+bss_fill_wpa(const wifi_vap_info_t *vap,
+             struct osw_drv_vif_state_ap *ap)
+{
+    const wifi_front_haul_bss_t *bss = &vap->u.bss_info;
+    const wifi_vap_security_t *sec = &bss->security;
+    struct osw_wpa *wpa = &ap->wpa;
+    bool is_key = false;
+
+    switch (sec->mode) {
+        case wifi_security_mode_none:
+            return;
+        case wifi_security_mode_wep_64:
+            LOGW("%s: wep 64 not supported", vap->vap_name);
+            return;
+        case wifi_security_mode_wep_128:
+            LOGW("%s: wep 128 not supported", vap->vap_name);
+            return;
+        case wifi_security_mode_wpa_personal:
+            wpa->wpa = true;
+            wpa->akm_psk = true;
+            is_key = true;
+            break;
+        case wifi_security_mode_wpa2_personal:
+            wpa->rsn = true;
+            wpa->akm_psk = true;
+            is_key = true;
+            break;
+        case wifi_security_mode_wpa_wpa2_personal:
+            wpa->wpa = true;
+            wpa->rsn = true;
+            wpa->akm_psk = true;
+            is_key = true;
+            break;
+        case wifi_security_mode_wpa_enterprise:
+            LOGI("%s: wpa enterprise not supported", vap->vap_name);
+            break;
+        case wifi_security_mode_wpa2_enterprise:
+            LOGI("%s: wpa2 enterprise not supported", vap->vap_name);
+            break;
+        case wifi_security_mode_wpa_wpa2_enterprise:
+            LOGI("%s: wpa1+2 enterprise not supported", vap->vap_name);
+            break;
+        case wifi_security_mode_wpa3_personal:
+            wpa->rsn = true;
+            wpa->akm_sae = true;
+            is_key = true;
+            break;
+        case wifi_security_mode_wpa3_transition:
+            wpa->rsn = true;
+            wpa->akm_psk = true;
+            wpa->akm_sae = true;
+            is_key = true;
+            break;
+        case wifi_security_mode_wpa3_enterprise:
+            LOGI("%s: wpa3 enterprise not supported", vap->vap_name);
+            break;
+    }
+
+    switch (sec->encr) {
+        case wifi_encryption_none:
+            break;
+        case wifi_encryption_tkip:
+            wpa->pairwise_tkip = true;
+            break;
+        case wifi_encryption_aes:
+            wpa->pairwise_ccmp = true;
+            break;
+        case wifi_encryption_aes_tkip:
+            wpa->pairwise_tkip = true;
+            wpa->pairwise_ccmp = true;
+            break;
+    }
+
+    wpa->pmf = mfp_to_osw_pmf(sec->mfp);
+
+    /* FIXME: Is this expected? This isn't documented. */
+    if (sec->wpa3_transition_disable &&
+        wpa->akm_sae == true &&
+        wpa->akm_psk == true) {
+        wpa->akm_psk = false;
+        LOGI("%s: overriding: disabling wpa3 transition", vap->vap_name);
+    }
+
+    wpa->group_rekey_seconds = sec->rekey_interval;
+
+    if (is_key == true) {
+        size_t max = sizeof(sec->u.key.key);
+
+        switch (sec->u.key.type) {
+            case wifi_security_key_type_psk:
+            case wifi_security_key_type_pass:
+            case wifi_security_key_type_sae:
+            case wifi_security_key_type_psk_sae:
+                /* FIXME: What's the difference between PSK
+                 * and PASS? PSK and SAE? Is one of these an
+                 * actual PMK instead? Assume everything as
+                 * ASCII for now. */
+
+                if (WARN_ON(strnlen(sec->u.key.key, max) >= max) == false)
+                    bss_add_psk(ap, -1, sec->u.key.key);
+                break;
+        }
+    }
+
+    /* FIXME: ft_mobility_domain and akm_ft_* aren't
+     * implemented in Wifi HAL at this time.
+     */
+}
+
+static void
+osw_drv_request_vif_state_cb(struct osw_drv *drv,
+                             const char *phy_name,
+                             const char *vif_name)
+{
+    const struct wifihal_3_0_priv *priv = osw_drv_get_priv(drv);
+    struct osw_drv_vif_state vif = {0};
+    struct osw_drv_vif_state_ap *ap = &vif.u.ap;
+    wifi_vap_info_t vap = {0};
+    wifi_radio_index_t rix;
+
+    if (phy_name_to_radio_index(phy_name, &rix) == false)
+        goto report;
+
+    if (vap_walk_rix_name_to_info(priv, rix, vif_name, &vap) == false)
+        goto report;
+
+    /* FIXME: No clue if accessing vap->u.bss_info is legal.
+     * There's no vap_type.
+     */
+
+    const wifi_front_haul_bss_t *bss = &vap.u.bss_info;
+
+    vif.exists = true;
+    vif.enabled = bss->enabled;
+    vif.vif_type = OSW_VIF_AP;
+    memcpy(&vif.mac_addr.octet, bss->bssid, MAC_LEN);
+
+    STRSCPY_WARN(vif.u.ap.bridge_if_name.buf, vap.bridge_name);
+    ap->isolated = bss->isolation;
+    ap->ssid_hidden = bss->showSsid ? false : true;
+
+    size_t max_ssid = ARRAY_SIZE(bss->ssid);
+    STRSCPY_WARN(ap->ssid.buf, bss->ssid);
+    ap->ssid.len = strnlen(bss->ssid, max_ssid);
+
+    ap->mode.wmm_enabled = bss->wmm_enabled;
+    ap->mode.wmm_uapsd_enabled = bss->UAPSDEnabled;
+    ap->mode.wnm_bss_trans = bss->bssTransitionActivated;
+    ap->mode.rrm_neighbor_report = bss->nbrReportActivated;
+    ap->acl_policy = bss_get_acl_policy(bss);
+    bss_fill_acl(&vap, ap);
+    bss_fill_wpa(&vap, ap);
+    bss_fill_psk(&vap, ap);
+
+    wifi_radio_operationParam_t radio_params = {0};
+    if (MEASURE(priv->wifi_getRadioOperatingParameters, (rix, &radio_params)) != RETURN_OK)
+        goto report;
+
+    wifi_ieee80211Variant_t v = radio_params.variant;
+    if (v & WIFI_80211_VARIANT_AX) ap->mode.he_enabled = true;
+    if (v & WIFI_80211_VARIANT_AC) ap->mode.vht_enabled = true;
+    if (v & WIFI_80211_VARIANT_N) ap->mode.ht_enabled = true;
+
+    // WIFI_80211_VARIANT_A = 0x01,
+    // WIFI_80211_VARIANT_B = 0x02,
+    // WIFI_80211_VARIANT_G = 0x04,
+    // WIFI_80211_VARIANT_H = 0x10,
+    // WIFI_80211_VARIANT_AD = 0x40,
+    // mode.wps
+
+    /* FIXME: Is the radio_params using Transmision Units or Milliseconds? */
+    ap->beacon_interval_tu = radio_params.beaconInterval;
+    ap->channel = radio_build_chan(&radio_params);
+
+report:
+    osw_drv_report_vif_state(drv, phy_name, vif_name, &vif);
+    FREE(ap->acl.list);
+    FREE(ap->psk_list.list);
+}
+
+static void
+osw_drv_request_sta_state_cb(struct osw_drv *drv,
+                             const char *phy_name,
+                             const char *vif_name,
+                             const struct osw_hwaddr *mac_addr)
+{
+    const struct wifihal_3_0_priv *priv = osw_drv_get_priv(drv);
+    struct osw_drv_sta_state sta = {0};
+    wifi_associated_dev_t *arr = NULL;
+    wifi_vap_info_t vap = {0};
+    wifi_radio_index_t rix;
+    UINT n = 0;
+    UINT i;
+
+    if (phy_name_to_radio_index(phy_name, &rix) == false)
+        goto report;
+
+    if (vap_walk_rix_name_to_info(priv, rix, vif_name, &vap) == false)
+        goto report;
+
+    INT vix = vap.vap_index;
+    if (MEASURE(priv->wifi_getApAssociatedDeviceDiagnosticResult, (vix, &arr, &n)) != RETURN_OK)
+        goto report;
+
+    for (i = 0; i < n; i++) {
+        const size_t n = sizeof(mac_addr->octet);
+        const void *mac = mac_addr->octet;
+
+        if (memcmp(mac, arr[i].cli_MACAddress, n) == 0) {
+            if (arr[i].cli_Active)
+                sta.connected = true;
+
+            /* FIXME: key_id */
+        }
+    }
+
+report:
+    osw_drv_report_sta_state(drv, phy_name, vif_name, mac_addr, &sta);
+    free(arr);
+    return;
+}
+
+static void
+vap_configure_ap_psk(wifi_vap_info_t *vap,
+                     const struct osw_drv_vif_config_ap *ap)
+{
+    struct wifihal_3_0_priv *priv = &g_priv;
+    INT vix = vap->vap_index;
+
+    if (ap->psk_list.count > 0) {
+        const char *cstr = ap->psk_list.list[0].psk.str;
+        STRSCPY_WARN(vap->u.bss_info.security.u.key.key, cstr);
+    }
+
+    if (priv->wifi_pushMultiPskKeys == NULL)
+        return;
+
+    if (ap->psk_list.count <= 1)
+        WARN_ON(MEASURE(priv->wifi_pushMultiPskKeys, (vix, NULL, 0)) != RETURN_OK);
+
+    if (ap->psk_list.count > 1) {
+        wifi_key_multi_psk_t keys[MAX_PSK];
+        size_t max = ARRAY_SIZE(keys);
+        size_t n = 0;
+
+        for (n = 1; n < ap->psk_list.count; n++) {
+            const char *psk_str = ap->psk_list.list[n].psk.str;
+            int key_id = ap->psk_list.list[n].key_id;
+            char key_id_str[32];
+
+            if (n >= max) break;
+
+            snprintf(key_id_str, sizeof(key_id_str), "%d", key_id);
+            STRSCPY_WARN(keys[n].wifi_keyId, key_id_str);
+            STRSCPY_WARN(keys[n].wifi_psk, psk_str);
+        }
+
+        WARN_ON(ap->psk_list.count > max);
+        WARN_ON(MEASURE(priv->wifi_pushMultiPskKeys, (vix, keys, n)) != RETURN_OK);
+    }
+}
+
+static wifi_security_modes_t
+get_sec_mode(const struct osw_wpa *wpa)
+{
+    if (wpa->wpa == false && wpa->rsn == false)
+        return wifi_security_mode_none;
+    else if (wpa->akm_psk == true && wpa->akm_sae == false) {
+        if (wpa->wpa == true && wpa->rsn == false)
+            return wifi_security_mode_wpa_personal;
+        else if (wpa->wpa == false && wpa->rsn == true)
+            return wifi_security_mode_wpa2_personal;
+        else if (wpa->wpa == true && wpa->rsn == true)
+            return wifi_security_mode_wpa_wpa2_personal;
+    }
+    else if (wpa->akm_psk == false && wpa->akm_sae == true) {
+        if (wpa->wpa == false && wpa->rsn == true)
+            return wifi_security_mode_wpa3_personal;
+    }
+    else if (wpa->akm_psk == true && wpa->akm_sae == true) {
+        if (wpa->rsn == true) /* wpa->wpa can be whatever */
+            return wifi_security_mode_wpa3_transition;
+    }
+
+    /* FIXME: Some unhandled cases for now: */
+    //wifi_security_mode_wep_64
+    //wifi_security_mode_wep_128
+    //wifi_security_mode_wpa_enterprise
+    //wifi_security_mode_wpa2_enterprise
+    //wifi_security_mode_wpa_wpa2_enterprise
+    //wifi_security_mode_wpa3_enterprise
+
+    return wifi_security_mode_none;
+}
+
+static wifi_encryption_method_t
+get_sec_encr(const struct osw_wpa *wpa)
+{
+    if (wpa->pairwise_tkip == false && wpa->pairwise_ccmp == false)
+        return wifi_encryption_none;
+    else if (wpa->pairwise_tkip == true && wpa->pairwise_ccmp == false)
+        return wifi_encryption_tkip;
+    else if (wpa->pairwise_tkip == false && wpa->pairwise_ccmp == true)
+        return wifi_encryption_aes;
+    else if (wpa->pairwise_tkip == true && wpa->pairwise_ccmp == true)
+        return wifi_encryption_aes_tkip;
+
+    char buf[256] = {0};
+    osw_wpa_to_str(buf, sizeof(buf), wpa);
+    LOGW("%s: unhandled encr: wpa=%s", __func__, buf);
+    return wifi_encryption_none;
+}
+
+static wifi_mfp_cfg_t
+get_sec_mfp(const enum osw_pmf pmf)
+{
+    switch (pmf) {
+        case OSW_PMF_DISABLED: return wifi_mfp_cfg_disabled;
+        case OSW_PMF_OPTIONAL: return wifi_mfp_cfg_optional;
+        case OSW_PMF_REQUIRED: return wifi_mfp_cfg_required;
+    }
+
+    LOGW("%s: unhandled mfp: pmf=%d", __func__, pmf);
+    return wifi_mfp_cfg_disabled;
+}
+
+static void
+vap_configure_ap(const struct wifihal_3_0_priv *priv,
+                 wifi_vap_info_t *vap,
+                 const struct osw_drv_phy_config *pconf,
+                 const struct osw_drv_vif_config *vconf,
+                 bool *changed)
+{
+    const struct osw_drv_vif_config_ap *ap = &vconf->u.ap;
+    const int vix = vap->vap_index;
+    wifi_front_haul_bss_t *bss = &vap->u.bss_info;
+
+    /* FIXME: How to verify that vap->u.bss_info is legal?
+     * There's no vap_type in wifi_vap_info_t.
+     */
+
+    if (vconf->changed == false) {
+        return;
+    }
+
+    if (vconf->enabled_changed == true) {
+        bss->enabled = vconf->enabled;
+        *changed = true;
+    }
+
+    if (vconf->vif_type_changed == true) {
+        LOGW("%s: cannot change vif_type to %d, unsupported",
+             vconf->vif_name, vconf->vif_type);
+    }
+
+    if (ap->bridge_if_name_changed == true) {
+        STRSCPY_WARN(vap->bridge_name, ap->bridge_if_name.buf);
+        *changed = true;
+    }
+
+    if (ap->ssid_changed == true) {
+        const size_t len = ap->ssid.len + sizeof('\0');
+        const size_t max = ARRAY_SIZE(bss->ssid);
+        if (len <= max) {
+            memcpy(bss->ssid, ap->ssid.buf, len);
+        }
+        else {
+            LOGW("%s: cannot fit ssid into buffer, '%s' is too long (%zu > %zu)",
+                 vap->vap_name, ap->ssid.buf, len, max);
+        }
+        *changed = true;
+    }
+
+    if (ap->isolated == true) {
+        bss->isolation = ap->isolated;
+        *changed = true;
+    }
+
+    if (ap->psk_list_changed == true) {
+        vap_configure_ap_psk(vap, ap);
+        *changed = true;
+    }
+
+    if (ap->ssid_hidden_changed == true) {
+        bss->showSsid = ap->ssid_hidden == true ? false : true;
+        *changed = true;
+    }
+
+    if (ap->wpa_changed == true) {
+        bss->security.rekey_interval = ap->wpa.group_rekey_seconds;
+        bss->security.mode = get_sec_mode(&ap->wpa);
+        bss->security.encr = get_sec_encr(&ap->wpa);
+        bss->security.mfp = get_sec_mfp(ap->wpa.pmf);
+        *changed = true;
+
+        /* FIXME:
+           BOOL  wpa3_transition_disable;
+           UINT  rekey_interval;
+           BOOL  strict_rekey;  // must be set for enterprise VAPs
+           UINT  eapol_key_timeout;
+           UINT  eapol_key_retries;
+           UINT  eap_identity_req_timeout;
+           UINT  eap_identity_req_retries;
+           UINT  eap_req_timeout;
+           UINT  eap_req_retries;
+           BOOL  disable_pmksa_caching;
+         */
+    }
+
+    if (ap->mode_changed == true) {
+        bss->wmm_enabled = ap->mode.wmm_enabled;
+        bss->UAPSDEnabled = ap->mode.wmm_uapsd_enabled;
+        bss->bssTransitionActivated = ap->mode.wnm_bss_trans;
+        bss->nbrReportActivated = ap->mode.rrm_neighbor_report;
+        *changed = true;
+
+        /* The following are applied per radio in another
+         * place in the code:
+           bool ht_enabled;
+           bool vht_enabled;
+           bool he_enabled;
+         */
+
+        /* FIXME:
+           struct osw_rateset_legacy supported_rates;
+           struct osw_rateset_legacy basic_rates;
+           struct osw_beacon_rate beacon_rate;
+           bool ht_required;
+           bool vht_required;
+           bool he_required;
+           bool wps;
+         */
+    }
+
+    if (ap->acl_policy_changed == true) {
+        switch (ap->acl_policy) {
+            case OSW_ACL_NONE:
+                bss->mac_filter_enable = false;
+                break;
+            case OSW_ACL_ALLOW_LIST:
+                bss->mac_filter_enable = true;
+                bss->mac_filter_mode = wifi_mac_filter_mode_white_list;
+                break;
+            case OSW_ACL_DENY_LIST:
+                bss->mac_filter_enable = true;
+                bss->mac_filter_mode = wifi_mac_filter_mode_black_list;
+                break;
+        }
+
+        *changed = true;
+    }
+
+    if (ap->acl_changed == true) {
+        /* FIXME: This is not atomic. In some cases will
+         * need (not always!) to kick out clients that
+         * inadvertently made it into the network. Eg.
+         * opensync onboard and backhaul networks are strict
+         * lists.
+         */
+        WARN_ON(priv->wifi_delApAclDevices(vix) != RETURN_OK);
+
+        size_t i;
+        for (i = 0; i < ap->acl.count; i++) {
+            const struct osw_hwaddr *addr = &ap->acl.list[i];
+            struct osw_hwaddr_str str;
+            osw_hwaddr2str(addr, &str);
+            WARN_ON(priv->wifi_addApAclDevice(vix, str.buf) != RETURN_OK);
+        }
+
+        *changed = true;
+    }
+
+    /* FIXME: add handling of wifi_vap_info_t:
+    INT     mgmtPowerControl;
+    UINT    bssMaxSta;
+    BOOL    rapidReconnectEnable;       //should not be implemented in the hal
+    UINT    rapidReconnThreshold;       //should not be implemented in the hal
+    BOOL    vapStatsEnable;             //should not be implemented in the hal
+    wifi_interworking_t interworking;
+    BOOL    sec_changed;                //should not be implemented in the hal
+    wifi_wps_t   wps;
+    wifi_bitrate_t beaconRate;
+    UINT   wmmNoAck;
+    UINT   wepKeyLength;
+    BOOL   bssHotspot;
+    UINT   wpsPushButton;
+    char   beaconRateCtl[32];
+    */
+
+    //bool mcast2ucast;
+    /* ap->channel_changed is handled per phy */
+}
+
+struct vap_configure_arg {
+    const struct wifihal_3_0_priv *priv;
+    const struct osw_drv_phy_config *pconf;
+    const struct osw_drv_vif_config *vconf;
+    bool *changed;
+    wifi_vap_info_t *vap;
+};
+
+static bool
+vap_configure_cb(wifi_vap_info_t *vap, void *fn_priv)
+{
+    struct vap_configure_arg *arg = fn_priv;
+
+    if (strcmp(vap->vap_name, arg->vconf->vif_name) != 0)
+        return false;
+
+    switch (arg->vconf->vif_type) {
+        case OSW_VIF_UNDEFINED:
+            break;
+        case OSW_VIF_AP:
+            vap_configure_ap(arg->priv, vap, arg->pconf, arg->vconf, arg->changed);
+        case OSW_VIF_AP_VLAN:
+            break;
+        case OSW_VIF_STA:
+            break;
+    }
+
+    if (arg->changed)
+        arg->vap = vap;
+
+    return true;
+}
+
+static void
+chan_fill_sec_chan(wifi_radio_operationParam_t *p, const int *chans)
+{
+    while (chans != NULL && *chans != 0) {
+        if (*chans != (int)p->channel) {
+            p->channelSecondary[p->numSecondaryChannels++] = *chans;
+        }
+        chans++;
+    }
+}
+
+static void
+chan_fill_sec_chan_5ghz(wifi_radio_operationParam_t *p)
+{
+    const int w = bw_to_mhz(p->channelWidth);
+    const int *chans = unii_5g_chan2list(p->channel, w);
+    chan_fill_sec_chan(p, chans);
+}
+
+static void
+chan_fill_sec_chan_6ghz(wifi_radio_operationParam_t *p)
+{
+    const int w = bw_to_mhz(p->channelWidth);
+    const int *chans = unii_6g_chan2list(p->channel, w);
+    chan_fill_sec_chan(p, chans);
+}
+
+static void
+chan_fill_rparam(const struct osw_channel *c,
+                 wifi_radio_operationParam_t *p)
+{
+    int band;
+    int cn;
+
+    if (mhz_to_chan_band(c->control_freq_mhz, &cn, &band) == false)
+        return;
+
+    p->channel = cn;
+    p->channelWidth = osw_to_bw(c->width);
+    p->numSecondaryChannels = 0;
+
+    switch (band) {
+        case 2:
+            if (c->width == OSW_CHANNEL_40MHZ) {
+                p->numSecondaryChannels = 1;
+                if (c->control_freq_mhz < c->center_freq0_mhz)
+                    p->channelSecondary[0] = p->channel + 4;
+                else
+                    p->channelSecondary[0] = p->channel - 4;
+
+                WARN_ON(p->channelSecondary[0] < 1);
+                WARN_ON(p->channelSecondary[0] > 14);
+            }
+            break;
+        case 5:
+            chan_fill_sec_chan_5ghz(p);
+            break;
+        case 6:
+            chan_fill_sec_chan_6ghz(p);
+            break;
+    }
+
+    /* FIXME: p->operatingClass */
+}
+
+static bool
+try_csa(int rix, const char *phy_name, const struct osw_channel *c)
+{
+    const struct wifihal_3_0_priv *priv = &g_priv;
+    const wifi_channelBandwidth_t w = osw_to_bw(c->width);
+    const int bw = bw_to_mhz(w);
+    const int cs_count = 15;
+    int cn;
+    int band;
+
+    if (getenv("OSW_DRV_WIFIHAL_DISABLE_PUSH_CHANNEL") != NULL)
+        return false;
+
+    if (WARN_ON(mhz_to_chan_band(c->control_freq_mhz, &cn, &band) == false))
+        return false;
+
+    LOGI("osw: drv: wifihal: %s: changing channel to %d @ %dMHz",
+         phy_name, cn, bw);
+
+    if (WARN_ON(MEASURE(priv->wifi_pushRadioChannel2, (rix, cn, bw, cs_count)) != RETURN_OK))
+        return false;
+
+    return true;
+}
+
+static wifi_ieee80211Variant_t
+get_hal_variant(const wifi_freq_bands_t bands, const struct osw_ap_mode *m)
+{
+    wifi_ieee80211Variant_t v = 0;
+
+    if (bands & WIFI_FREQUENCY_2_4_BAND) {
+        /* FIXME: supported_rates/basic_rates/beacon_rate should
+         * be used to infer if 11b is enabled. OSW could provide a
+         * helper. */
+        // FIXME: v |= WIFI_80211_VARIANT_B;
+        v |= WIFI_80211_VARIANT_G;
+    }
+
+    if (bands & WIFI_FREQUENCY_5_BAND ||
+        bands & WIFI_FREQUENCY_5L_BAND ||
+        bands & WIFI_FREQUENCY_5H_BAND ||
+        bands & WIFI_FREQUENCY_6_BAND) {
+        v |= WIFI_80211_VARIANT_A;
+    }
+
+    if (m->ht_enabled == true)
+        v |= WIFI_80211_VARIANT_N;
+    if (m->vht_enabled == true)
+        v |= WIFI_80211_VARIANT_AC;
+    if (m->he_enabled == true)
+        v |= WIFI_80211_VARIANT_AX;
+
+    /* FIXME: Why is 11h a mode variant? I saw it enabled on
+     * 2.4G phy as well, hmm..
+     */
+    v |= WIFI_80211_VARIANT_H;
+
+    /* FIXME: WIFI_80211_VARIANT_AD */
+
+    return v;
+}
+
+static void
+osw_drv_request_config_cb(struct osw_drv *drv,
+                          struct osw_drv_conf *conf)
+{
+    struct wifihal_3_0_priv *priv = osw_drv_get_priv(drv);
+    unsigned int i;
+
+    if (drv_is_enabled() == false) return;
+
+    for (i = 0; i < conf->n_phy_list; i++) {
+        struct osw_drv_phy_config *pconf = &conf->phy_list[i];
+        const char *phy_name = pconf->phy_name;
+        bool phy_changed = false;
+        wifi_radio_operationParam_t radio_params = {0};
+        wifi_radio_index_t rix;
+
+        if (phy_name_to_radio_index(phy_name, &rix) == false)
+            continue;
+
+        if (MEASURE(priv->wifi_getRadioOperatingParameters, (rix, &radio_params)) != RETURN_OK) {
+            LOGW("Cannot get radio operating params for radio index: %d", rix);
+            continue;
+        }
+
+        if (pconf->enabled_changed) {
+            radio_params.enable = pconf->enabled;
+            phy_changed = true;
+        }
+
+        if (pconf->tx_chainmask_changed) {
+            // FIXME: Wifi HAL doesn't seem to support this.
+        }
+
+        if (pconf->radar_changed) {
+            BOOL b = 0;
+            switch (pconf->radar) {
+                case OSW_RADAR_UNSUPPORTED: break;
+                case OSW_RADAR_DETECT_ENABLED: b = 1; break;
+                case OSW_RADAR_DETECT_DISABLED: b = 0; break;
+            }
+            WARN_ON(MEASURE(priv->wifi_setRadioDfsEnable, (rix, b)) != RETURN_OK);
+        }
+
+        bool vap_changed = false;
+        wifi_vap_info_map_t vaps = {0};
+        wifi_vap_info_map_t vaps2 = {0};
+        if (WARN_ON(MEASURE(priv->wifi_getRadioVapInfoMap, (rix, &vaps)) != RETURN_OK))
+            continue;
+
+        const struct osw_channel *c = NULL;
+        const struct osw_ap_mode *m = NULL;
+        bool csa_required = false;
+        unsigned int j;
+        for (j = 0; j < pconf->vif_list.count; j++) {
+            const struct osw_drv_vif_config *vconf = &pconf->vif_list.list[j];
+            const char *vif_name = vconf->vif_name;
+            bool changed = false;
+            struct vap_configure_arg arg = {
+                .priv = priv,
+                .pconf = pconf,
+                .vconf = vconf,
+                .changed = &changed,
+                .vap = NULL,
+            };
+            /* FIXME: Some of the actions taken by vap_configure_cb()
+             * call wifi hal api - this might not be a good idea
+             * because some parameters may only be changable when
+             * interface is already UP, ie. bringing interface up
+             * would require 2 rounds of reconfigs (with 30s timeout
+             * in between by osw_confsync). This is fine for initial
+             * bring up.
+             */
+            vap_walk_buf(&vaps, vap_configure_cb, &arg);
+            if (changed) {
+                memcpy(&vaps2.vap_array[vaps2.num_vaps], arg.vap, sizeof(*arg.vap));
+                vaps2.num_vaps++;
+                vap_changed = true;
+                LOGI("osw: drv: wifihal: %s: will use createVAP()", arg.vap->vap_name);
+            }
+            osw_drv_report_vif_changed(drv, phy_name, vif_name);
+
+            /* FIXME: This assumes all vifs have the same channel and
+             * mode. OSW may need to provide a combined values for
+             * easier implementation of OSW drivers.
+             */
+            if (vconf->vif_type == OSW_VIF_AP) {
+                const struct osw_drv_vif_config_ap *ap = &vconf->u.ap;
+
+                if (ap->channel_changed == true) {
+                    c = &ap->channel;
+                    csa_required |= ap->csa_required;
+                }
+
+                if (ap->mode_changed == true) {
+                    m = &ap->mode;
+                }
+
+                if (ap->beacon_interval_tu_changed == true) {
+                    radio_params.beaconInterval = vconf->u.ap.beacon_interval_tu;
+                    phy_changed = true;
+                }
+            }
+        }
+
+        if (m != NULL) {
+            radio_params.variant = get_hal_variant(radio_params.band, m);
+            phy_changed = true;
+        }
+
+        if (c != NULL) {
+            if (csa_required == true && phy_changed == true) {
+                LOGI("osw: drv: wifihal: %s: skipping csa, radio reconfig required anyway", phy_name);
+                csa_required = false;
+            }
+
+            if (csa_required == false || try_csa(rix, phy_name, c) == false) {
+                chan_fill_rparam(c, &radio_params);
+                radio_params.autoChannelEnabled = 0;
+                phy_changed = true;
+            }
+        }
+
+        if (vap_changed) {
+            LOGI("osw: drv: wifihal: %s: configuring vaps", pconf->phy_name);
+            if (MEASURE(priv->wifi_createVAP, (rix, &vaps2)) != RETURN_OK) {
+                LOGE("Failed to update VAP map for radio index: %d", rix);
+            }
+        }
+
+        if (phy_changed) {
+            LOGI("osw: drv: wifihal: %s: configuring radio", pconf->phy_name);
+            if (MEASURE(priv->wifi_setRadioOperatingParameters, (rix, &radio_params)) != RETURN_OK) {
+                LOGE("Failed to set radio operating params for radio index: %d", rix);
+            }
+        }
+
+        osw_drv_report_phy_changed(drv, phy_name);
+    }
+
+    osw_drv_conf_free(conf);
+}
+
+static void
+osw_drv_request_sta_deauth_cb(struct osw_drv *drv,
+                              const char *phy_name,
+                              const char *vif_name,
+                              const struct osw_hwaddr *mac_addr,
+                              int dot11_reason_code)
+{
+    const struct wifihal_3_0_priv *priv = osw_drv_get_priv(drv);
+    int steer_index = 0; /* FIXME: ??? */
+    int ap_index = vif_name_to_ap_index(priv, vif_name);
+    wifi_disconnectType_t type = DISCONNECT_TYPE_DEAUTH;
+    mac_address_t mac = {0};
+    INT ret;
+
+    memcpy(&mac, mac_addr->octet, MAC_LEN);
+    ret = MEASURE(priv->wifi_steering_clientDisconnect, (steer_index, ap_index, mac,
+                                                         type, dot11_reason_code));
+    WARN_ON(ret != RETURN_OK);
+}
+
+const struct osw_drv_ops g_wifihal_3_0_ops = {
+    .name = DRV_NAME,
+    .init_fn = osw_drv_init_cb,
+    .get_phy_list_fn = osw_drv_get_phy_list_cb,
+    .get_vif_list_fn = osw_drv_get_vif_list_cb,
+    .get_sta_list_fn = osw_drv_get_sta_list_cb,
+    .request_phy_state_fn = osw_drv_request_phy_state_cb,
+    .request_vif_state_fn = osw_drv_request_vif_state_cb,
+    .request_sta_state_fn = osw_drv_request_sta_state_cb,
+    .request_config_fn = osw_drv_request_config_cb,
+    .request_sta_deauth_fn = osw_drv_request_sta_deauth_cb,
+};
+
+OSW_DRV_DEFINE(g_wifihal_3_0_ops);
Index: device-core/src/lib/osw/src/osw_mux.c
===================================================================
--- /dev/null
+++ device-core/src/lib/osw/src/osw_mux.c
@@ -0,0 +1,77 @@
+#include <memutil.h>
+#include <osw_conf.h>
+#include <osw_drv.h>
+#include "osw_drv_i.h"
+
+bool
+osw_mux_request_config(struct osw_drv_conf *conf)
+{
+    struct osw_drv *drv;
+    bool requested = false;
+
+    ds_tree_foreach(&g_osw_drv_tree, drv) {
+        struct osw_drv_conf *tmp = CALLOC(1, sizeof(*tmp));
+        size_t i;
+
+        for (i = 0; i < conf->n_phy_list; i++) {
+            struct osw_drv_phy_config *phy = &conf->phy_list[i];
+            if (phy->phy_name == NULL)
+                continue;
+            if (ds_tree_find(&drv->phy_tree, phy->phy_name) == NULL)
+                continue;
+
+            tmp->n_phy_list++;
+            size_t s = tmp->n_phy_list * sizeof(*tmp->phy_list);
+            tmp->phy_list = REALLOC(tmp->phy_list, s);
+            memcpy(&tmp->phy_list[tmp->n_phy_list - 1], phy, sizeof(*phy));
+            memset(phy, 0, sizeof(*phy));
+            /* The memset() is important. It makes osw_drv_conf_free()
+             * at return to free() only the bits that were not given
+             * to any of the drivers.
+             */
+        }
+
+        if (osw_drv_conf_changed(tmp) == false) {
+            osw_drv_conf_free(tmp);
+            continue;
+        }
+
+        osw_drv_set_chan_sync(drv, tmp);
+
+        assert(drv->ops->request_config_fn != NULL);
+        drv->ops->request_config_fn(drv, tmp);
+        /* tmp is now owned by the driver. The driver
+         * is expected to free it.
+         */
+
+        requested = true;
+    }
+
+    osw_drv_conf_free(conf);
+    return requested;
+}
+
+static struct osw_drv *
+osw_mux_phy_to_drv(const char *phy_name)
+{
+    struct osw_drv *drv;
+
+    ds_tree_foreach(&g_osw_drv_tree, drv)
+        if (ds_tree_find(&drv->phy_tree, phy_name) != NULL)
+            return drv;
+
+    return NULL;
+}
+
+bool
+osw_mux_request_sta_deauth(const char *phy_name,
+                           const char *vif_name,
+                           const struct osw_hwaddr *mac_addr,
+                           int dot11_reason_code)
+{
+    struct osw_drv *drv = osw_mux_phy_to_drv(phy_name);
+    if (drv == NULL) return false;
+    drv->ops->request_sta_deauth_fn(drv, phy_name, vif_name,
+                                    mac_addr, dot11_reason_code);
+    return true;
+}
Index: device-core/src/lib/osw/src/osw_req.c
===================================================================
--- /dev/null
+++ device-core/src/lib/osw/src/osw_req.c
@@ -0,0 +1,53 @@
+#include <memutil.h>
+#include <osw_state.h>
+#include <osw_conf.h>
+#include <osw_drv.h>
+#include "osw_drv_i.h"
+#include "osw_state_i.h"
+
+static struct osw_drv_conf *
+osw_req_conf_to_drv_conf(struct osw_conf *conf,
+                         struct osw_drv *drv)
+{
+    struct osw_conf *state = osw_conf_build_from_state();
+    struct osw_drv_conf *drv_conf = CALLOC(1, sizeof(*drv_conf));
+
+    // compare conf to state and generate adequate drv_conf entries and _changed=true
+    osw_conf_free(state);
+    return drv_conf;
+}
+
+void
+osw_req_config(struct osw_conf *conf)
+{
+    struct osw_drv *drv;
+
+    ds_tree_foreach(&g_osw_drv_tree, drv) {
+        struct osw_drv_conf *drv_conf = osw_req_conf_to_drv_conf(conf, drv);
+
+        if (drv_conf->n_phy_list == 0) {
+            osw_drv_conf_free(drv_conf);
+            continue;
+        }
+
+        drv->ops->request_config_fn(drv, drv_conf);
+        /* drv_conf is now owned by the driver. The driver
+         * is expected to free it.
+         */
+    }
+
+    osw_conf_free(conf);
+}
+
+void
+osw_req_sta_deauth(const char *phy_name,
+                   const char *vif_name,
+                   const struct osw_hwaddr *mac_addr,
+                   int dot11_reason)
+{
+    // FIXME
+    //struct osw_drv *drv = osw_drv_phy_get_drv(phy_name);
+    struct osw_drv *drv = NULL;
+    if (drv == NULL) return;
+    drv->ops->request_sta_deauth_fn(drv, phy_name, vif_name, mac_addr, dot11_reason);
+}
Index: device-core/src/lib/osw/src/osw_state.c
===================================================================
--- /dev/null
+++ device-core/src/lib/osw/src/osw_state.c
@@ -0,0 +1,254 @@
+#include <ev.h>
+#include <const.h>
+#include <os.h>
+#include <memutil.h>
+#include <osw_state.h>
+#include "osw_state_i.h"
+#include "osw_drv_i.h"
+
+struct ds_dlist g_osw_state_observer_list = DS_DLIST_INIT(struct osw_state_observer, node);
+
+#define osw_log_state_observer_register(o) \
+    LOGI("osw: state: registering observer: name=%s", o->name)
+#define osw_log_state_observer_unregister(o) \
+    LOGI("osw: state: unregistering observer: name=%s", o->name)
+
+static void
+osw_state_observer_notify_add(struct osw_state_observer *observer)
+{
+    struct osw_drv *drv;
+    struct osw_drv_phy *phy;
+    struct osw_drv_vif *vif;
+    struct osw_drv_sta *sta;
+
+    ds_tree_foreach(&g_osw_drv_tree, drv) {
+        ds_tree_foreach(&drv->phy_tree, phy) {
+            if (phy->cur_state.exists == false)
+                continue;
+
+            if (observer->phy_added_fn != NULL)
+                observer->phy_added_fn(observer, &phy->pub);
+
+            ds_tree_foreach(&phy->vif_tree, vif) {
+                if (vif->cur_state.exists == false)
+                    continue;
+
+                if (observer->vif_added_fn != NULL)
+                    observer->vif_added_fn(observer, &vif->pub);
+
+                ds_tree_foreach(&vif->sta_tree, sta) {
+                    if (sta->cur_state.connected == false)
+                        continue;
+
+                    if (observer->sta_connected_fn != NULL)
+                        observer->sta_connected_fn(observer, &sta->pub);
+                }
+            }
+        }
+    }
+}
+
+static void
+osw_state_observer_notify_remove(struct osw_state_observer *observer)
+{
+    struct osw_drv *drv;
+    struct osw_drv_phy *phy;
+    struct osw_drv_vif *vif;
+    struct osw_drv_sta *sta;
+
+    ds_tree_foreach(&g_osw_drv_tree, drv) {
+        ds_tree_foreach(&drv->phy_tree, phy) {
+            ds_tree_foreach(&phy->vif_tree, vif) {
+                ds_tree_foreach(&vif->sta_tree, sta) {
+                    if (observer->sta_disconnected_fn != NULL)
+                        observer->sta_disconnected_fn(observer, &sta->pub);
+                }
+                if (observer->vif_removed_fn != NULL)
+                    observer->vif_removed_fn(observer, &vif->pub);
+            }
+            if (observer->phy_removed_fn != NULL)
+                observer->phy_removed_fn(observer, &phy->pub);
+        }
+    }
+}
+
+static void
+osw_state_observer_notify_settled(struct osw_state_observer *observer)
+{
+    bool is_settled = osw_drv_work_is_settled();
+
+    if (is_settled == true && observer->idle_fn != NULL)
+        observer->idle_fn(observer);
+
+    if (is_settled == false && observer->busy_fn != NULL)
+        observer->busy_fn(observer);
+}
+
+void
+osw_state_register_observer(struct osw_state_observer *observer)
+{
+    osw_log_state_observer_register(observer);
+    ds_dlist_insert_tail(&g_osw_state_observer_list, observer);
+    osw_state_observer_notify_add(observer);
+    osw_state_observer_notify_settled(observer);
+}
+
+void
+osw_state_unregister_observer(struct osw_state_observer *observer)
+{
+    osw_log_state_observer_unregister(observer);
+    ds_dlist_remove(&g_osw_state_observer_list, observer);
+    osw_state_observer_notify_remove(observer);
+}
+
+const struct osw_state_phy_info *
+osw_state_phy_lookup(const char *phy_name)
+{
+    struct osw_drv *drv;
+    struct osw_drv_phy *phy;
+
+    ds_tree_foreach(&g_osw_drv_tree, drv)
+        if ((phy = ds_tree_find(&drv->phy_tree, phy_name)) != NULL)
+            if (phy->cur_state.exists == true)
+                return &phy->pub;
+
+    return NULL;
+}
+
+const struct osw_state_vif_info *
+osw_state_vif_lookup(const char *phy_name,
+                     const char *vif_name)
+{
+    struct osw_drv *drv;
+    struct osw_drv_phy *phy;
+    struct osw_drv_vif *vif;
+
+    ds_tree_foreach(&g_osw_drv_tree, drv)
+        if ((phy = ds_tree_find(&drv->phy_tree, phy_name)) != NULL)
+            if (phy->cur_state.exists == true)
+                if ((vif = ds_tree_find(&phy->vif_tree, vif_name)) != NULL)
+                    if (vif->cur_state.exists == true)
+                        return &vif->pub;
+
+    return NULL;
+}
+
+const struct osw_state_sta_info *
+osw_state_sta_lookup(const char *phy_name,
+                     const char *vif_name,
+                     const struct osw_hwaddr *mac_addr)
+{
+    struct osw_drv *drv;
+    struct osw_drv_phy *phy;
+    struct osw_drv_vif *vif;
+    struct osw_drv_sta *sta;
+
+    ds_tree_foreach(&g_osw_drv_tree, drv)
+        if ((phy = ds_tree_find(&drv->phy_tree, phy_name)) != NULL)
+            if (phy->cur_state.exists == true)
+                if ((vif = ds_tree_find(&phy->vif_tree, vif_name)) != NULL)
+                    if (vif->cur_state.exists == true)
+                        if ((sta = ds_tree_find(&vif->sta_tree, mac_addr)) != NULL)
+                            if (sta->cur_state.connected == true)
+                                return &sta->pub;
+
+    return NULL;
+}
+
+const struct osw_state_sta_info *
+osw_state_sta_lookup_newest(const struct osw_hwaddr *mac_addr)
+{
+    struct osw_drv *drv;
+    struct osw_drv_phy *phy;
+    struct osw_drv_vif *vif;
+    struct osw_drv_sta *sta;
+    struct osw_drv_sta *newest = NULL;
+
+    ds_tree_foreach(&g_osw_drv_tree, drv)
+        ds_tree_foreach(&drv->phy_tree, phy)
+            if (phy->cur_state.exists == true)
+                ds_tree_foreach(&phy->vif_tree, vif)
+                    if (vif->cur_state.exists == true)
+                        if ((sta = ds_tree_find(&vif->sta_tree, mac_addr)) != NULL)
+                            if (sta->cur_state.connected == true)
+                                if (newest == NULL || sta->pub.connected_at > newest->pub.connected_at)
+                                    newest = sta;
+
+    return newest != NULL ? &newest->pub : NULL;
+}
+
+void
+osw_state_phy_get_list(osw_state_report_phy_fn_t fn,
+                       void *priv)
+{
+    struct osw_drv *drv;
+    struct osw_drv_phy *phy;
+
+    ds_tree_foreach(&g_osw_drv_tree, drv)
+        ds_tree_foreach(&drv->phy_tree, phy)
+            if (phy->cur_state.exists == true)
+                fn(&phy->pub, priv);
+}
+
+void
+osw_state_vif_get_list(osw_state_report_vif_fn_t fn,
+                       const char *phy_name,
+                       void *priv)
+{
+    struct osw_drv *drv;
+    struct osw_drv_phy *phy;
+    struct osw_drv_vif *vif;
+
+    ds_tree_foreach(&g_osw_drv_tree, drv)
+        if ((phy = ds_tree_find(&drv->phy_tree, phy_name)) != NULL)
+            if (phy->cur_state.exists == true)
+                ds_tree_foreach(&phy->vif_tree, vif)
+                    if (vif->cur_state.exists == true)
+                        fn(&vif->pub, priv);
+}
+
+static void
+osw_state_sta_get_list_on_phy(osw_state_report_sta_fn_t fn,
+                              struct osw_drv_phy *phy,
+                              const char *vif_name,
+                              void *priv)
+{
+    struct osw_drv_vif *vif;
+    struct osw_drv_sta *sta;
+
+    if (phy->cur_state.exists == true)
+        if ((vif = ds_tree_find(&phy->vif_tree, vif_name)) != NULL)
+            if (vif->cur_state.exists == true)
+                ds_tree_foreach(&vif->sta_tree, sta)
+                    if (sta->cur_state.connected == true)
+                        fn(&sta->pub, priv);
+}
+
+static void
+osw_state_sta_get_list_on_drv(osw_state_report_sta_fn_t fn,
+                              struct osw_drv *drv,
+                              const char *vif_name,
+                              void *priv)
+{
+    struct osw_drv_phy *phy;
+
+    ds_tree_foreach(&drv->phy_tree, phy)
+        osw_state_sta_get_list_on_phy(fn, phy, vif_name, priv);
+}
+
+void
+osw_state_sta_get_list(osw_state_report_sta_fn_t fn,
+                       const char *phy_name,
+                       const char *vif_name,
+                       void *priv)
+{
+    struct osw_drv *drv;
+    struct osw_drv_phy *phy;
+
+    ds_tree_foreach(&g_osw_drv_tree, drv) {
+        if (phy_name == NULL)
+            osw_state_sta_get_list_on_drv(fn, drv, vif_name, priv);
+        else if ((phy = ds_tree_find(&drv->phy_tree, phy_name)) != NULL)
+            osw_state_sta_get_list_on_phy(fn, phy, vif_name, priv);
+    }
+}
Index: device-core/src/lib/osw/src/osw_state_i.h
===================================================================
--- /dev/null
+++ device-core/src/lib/osw/src/osw_state_i.h
@@ -0,0 +1,17 @@
+#ifndef OSW_STATE_I_H
+#define OSW_STATE_I_H
+
+#include <osw_state.h>
+#include <ds_dlist.h>
+
+#define OSW_STATE_NOTIFY(fn, ...) \
+    do { \
+        struct osw_state_observer *i; \
+        ds_dlist_foreach(&g_osw_state_observer_list, i) \
+            if (i->fn != NULL) \
+                i->fn(i, ## __VA_ARGS__); \
+    } while (0)
+
+extern struct ds_dlist g_osw_state_observer_list;
+
+#endif
Index: device-core/src/lib/osw/src/osw_thread.c
===================================================================
--- /dev/null
+++ device-core/src/lib/osw/src/osw_thread.c
@@ -0,0 +1,24 @@
+#include <pthread.h>
+#include <stdbool.h>
+#include <assert.h>
+
+static pthread_mutex_t g_mutex = PTHREAD_MUTEX_INITIALIZER;
+static pthread_t g_thread;
+static bool g_thread_initialized = false;
+
+void
+osw_thread_init(void)
+{
+    assert(pthread_mutex_lock(&g_mutex) == 0);
+    if (g_thread_initialized == false) {
+        g_thread = pthread_self();
+        g_thread_initialized = true;
+    }
+    assert(pthread_mutex_unlock(&g_mutex) == 0);
+}
+
+void
+osw_thread_sanity_check(void)
+{
+    assert(pthread_equal(g_thread, pthread_self()) != 0);
+}
Index: device-core/src/lib/osw/src/osw_types.c
===================================================================
--- /dev/null
+++ device-core/src/lib/osw/src/osw_types.c
@@ -0,0 +1,354 @@
+#include <osw_types.h>
+#include <osw_ut.h>
+#include <module.h>
+#include <const.h>
+#include <util.h>
+
+static void
+strip_trailing_whitespace(char *str)
+{
+    char *p;
+    while ((p = strrchr(str, ' ')) != NULL)
+        *p = '\0';
+}
+
+const char *
+osw_pmf_to_str(enum osw_pmf pmf)
+{
+    switch (pmf) {
+        case OSW_PMF_DISABLED: return "disabled";
+        case OSW_PMF_OPTIONAL: return "optional";
+        case OSW_PMF_REQUIRED: return "required";
+    }
+    return "";
+}
+const char *
+osw_vif_type_to_str(enum osw_vif_type t)
+{
+    switch (t) {
+        case OSW_VIF_UNDEFINED: return "undefined";
+        case OSW_VIF_AP: return "ap";
+        case OSW_VIF_AP_VLAN: return "ap_vlan";
+        case OSW_VIF_STA: return "sta";
+    }
+    return "";
+}
+
+const char *
+osw_acl_policy_to_str(enum osw_acl_policy p)
+{
+    switch (p) {
+        case OSW_ACL_NONE: return "none";
+        case OSW_ACL_ALLOW_LIST: return "allow";
+        case OSW_ACL_DENY_LIST: return "deny";
+    }
+    return "";
+}
+
+const char *
+osw_channel_width_to_str(enum osw_channel_width w)
+{
+    switch (w) {
+        case OSW_CHANNEL_20MHZ: return "20";
+        case OSW_CHANNEL_40MHZ: return "40";
+        case OSW_CHANNEL_80MHZ: return "80";
+        case OSW_CHANNEL_160MHZ: return "160";
+        case OSW_CHANNEL_80P80MHZ: return "80p80";
+    }
+    return "";
+}
+
+const char *
+osw_radar_to_str(enum osw_radar_detect r)
+{
+    switch (r) {
+        case OSW_RADAR_UNSUPPORTED: return "unsupported";
+        case OSW_RADAR_DETECT_ENABLED: return "enabled";
+        case OSW_RADAR_DETECT_DISABLED: return "disabled";
+    }
+    return "";
+}
+
+void
+osw_wpa_to_str(char *out, size_t len, const struct osw_wpa *wpa)
+{
+    out[0] = 0;
+    csnprintf(&out, &len, " wpa=");
+    if (wpa->wpa) csnprintf(&out, &len, "wpa ");
+    if (wpa->rsn) csnprintf(&out, &len, "rsn ");
+    if (wpa->pairwise_tkip) csnprintf(&out, &len, "tkip ");
+    if (wpa->pairwise_ccmp) csnprintf(&out, &len, "ccmp ");
+    if (wpa->akm_psk) csnprintf(&out, &len, "psk ");
+    if (wpa->akm_sae) csnprintf(&out, &len, "sae ");
+    if (wpa->akm_ft_psk) csnprintf(&out, &len, "ft_psk ");
+    if (wpa->akm_ft_sae) csnprintf(&out, &len, "ft_sae ");
+    csnprintf(&out, &len, "pmf=%s ", osw_pmf_to_str(wpa->pmf));
+    csnprintf(&out, &len, "mdid=%04x ", wpa->ft_mobility_domain);
+    csnprintf(&out, &len, "gtk=%d ", wpa->group_rekey_seconds);
+    strip_trailing_whitespace(out);
+}
+
+void
+osw_ap_mode_to_str(char *out, size_t len, const struct osw_ap_mode *mode)
+{
+    out[0] = 0;
+    if (mode->wnm_bss_trans) csnprintf(&out, &len, "btm ");
+    if (mode->rrm_neighbor_report) csnprintf(&out, &len, "rrm ");
+    if (mode->wmm_enabled) csnprintf(&out, &len, "wmm ");
+    if (mode->wmm_uapsd_enabled) csnprintf(&out, &len, "uapsd ");
+    if (mode->ht_enabled) csnprintf(&out, &len, "ht ");
+    if (mode->ht_required) csnprintf(&out, &len, "htR ");
+    if (mode->vht_enabled) csnprintf(&out, &len, "vht ");
+    if (mode->vht_required) csnprintf(&out, &len, "vhtR ");
+    if (mode->he_enabled) csnprintf(&out, &len, "he ");
+    if (mode->ht_required) csnprintf(&out, &len, "heR ");
+    if (mode->wps) csnprintf(&out, &len, "wps ");
+    strip_trailing_whitespace(out);
+}
+
+enum osw_band
+osw_freq_to_band(const int freq)
+{
+    const int b2ch1 = 2412;
+    const int b2ch13 = 2472;
+    const int b2ch14 = 2484;
+    const int b5ch36 = 5180;
+    const int b5ch177 = 5885;
+    const int b6ch1 = 5955;
+    const int b6ch2 = 5935;
+    const int b6ch233 = 7115;
+
+    if (freq == b2ch14)
+        return OSW_BAND_2GHZ;
+    if (freq == b6ch2)
+        return OSW_BAND_6GHZ;
+    if (freq >= b2ch1 && freq <= b2ch13)
+        return OSW_BAND_2GHZ;
+    if (freq >= b5ch36 && freq <= b5ch177)
+        return OSW_BAND_5GHZ;
+    if (freq >= b6ch1 && freq <= b6ch233)
+        return OSW_BAND_6GHZ;
+
+    return OSW_BAND_UNDEFINED;
+}
+
+int
+osw_freq_to_chan(const int freq)
+{
+    const int b2ch1 = 2412;
+    const int b2ch13 = 2472;
+    const int b2ch14 = 2484;
+    const int b5ch36 = 5180;
+    const int b5ch177 = 5885;
+    const int b6ch1 = 5955;
+    const int b6ch2 = 5935;
+    const int b6ch233 = 7115;
+
+    if (freq == b2ch14)
+        return 14;
+    if (freq == b6ch2)
+        return 2;
+    if (freq >= b2ch1 && freq <= b2ch13)
+        return (freq - 2407) / 5;
+    if (freq >= b5ch36 && freq <= b5ch177)
+        return (freq - 5000) / 5;
+    if (freq >= b6ch1 && freq <= b6ch233)
+        return (freq - 5950) / 5;
+
+    return 0;
+}
+
+int
+osw_channel_width_to_mhz(const enum osw_channel_width w)
+{
+    switch (w) {
+        case OSW_CHANNEL_20MHZ: return 20;
+        case OSW_CHANNEL_40MHZ: return 40;
+        case OSW_CHANNEL_80MHZ: return 80;
+        case OSW_CHANNEL_160MHZ: return 160;
+        case OSW_CHANNEL_80P80MHZ: return 0; /* N/A */
+    }
+    return 0;
+}
+
+static const int *
+osw_2g_chan_list(int chan, int width, int max_chan)
+{
+    static const int lists[] = {
+        20, 1, 0,
+        20, 2, 0,
+        20, 3, 0,
+        20, 4, 0,
+        20, 5, 0,
+        20, 6, 0,
+        20, 7, 0,
+        20, 8, 0,
+        20, 9, 0,
+        20, 10, 0,
+        20, 11, 0,
+        20, 12, 0,
+        20, 13, 0,
+        40, 9, 13, 0,
+        40, 8, 12, 0,
+        40, 7, 11, 0,
+        40, 6, 10, 0,
+        40, 5, 9, 0,
+        40, 4, 8, 0,
+        40, 3, 7, 0,
+        40, 2, 6, 0,
+        40, 1, 5, 0,
+        -1,
+    };
+    const int *start;
+    const int *p;
+
+    for (p = lists; *p != -1; p++) {
+        if (*p == width) {
+            bool out_of_range = false;
+            bool found = false;
+            for (start = ++p; *p; p++) {
+                if (*p == chan) found = true;
+                if (*p > max_chan) out_of_range = true;
+            }
+            if (found == true && out_of_range == false) {
+                return start;
+            }
+        }
+    }
+
+    return NULL;
+}
+
+const int *
+osw_channel_sidebands(enum osw_band band, int chan, int width, int max_2g_chan)
+{
+    static int empty[] = { 0 };
+    switch (band) {
+        case OSW_BAND_UNDEFINED: return empty;
+        case OSW_BAND_2GHZ: return osw_2g_chan_list(chan, width, max_2g_chan);
+        case OSW_BAND_5GHZ: return unii_5g_chan2list(chan, width);
+        case OSW_BAND_6GHZ: return unii_6g_chan2list(chan, width);
+    }
+    return empty;
+}
+
+int
+osw_chan_to_freq(enum osw_band band, int chan)
+{
+    switch (band) {
+        case OSW_BAND_UNDEFINED: return 0;
+        case OSW_BAND_2GHZ: return 2407 + (chan * 5);
+        case OSW_BAND_5GHZ: return 5000 + (chan * 5);
+        case OSW_BAND_6GHZ: return 5950 + (chan * 5);
+    }
+    return 0;
+}
+
+static int
+osw_chan_avg(const int *chans)
+{
+    int sum = 0;
+    int n = 0;
+    while (chans != NULL && *chans != 0) {
+        sum += *chans;
+        n++;
+        chans++;
+    }
+    if (n == 0) return 0;
+    else return sum / n;
+}
+
+void
+osw_channel_compute_center_freq(struct osw_channel *c, int max_2g_chan)
+{
+    const enum osw_band b = osw_freq_to_band(c->control_freq_mhz);
+    const int w = osw_channel_width_to_mhz(c->width);
+    const int cn = osw_freq_to_chan(c->control_freq_mhz);
+    const int *chans = osw_channel_sidebands(b, cn, w, max_2g_chan);
+    const int avg = osw_chan_avg(chans);
+    c->center_freq0_mhz = osw_chan_to_freq(b, avg);
+}
+
+int
+osw_hwaddr_cmp(const struct osw_hwaddr *addr_a,
+               const struct osw_hwaddr *addr_b)
+{
+    return memcmp(addr_a, addr_b, sizeof(struct osw_hwaddr));
+}
+
+static void
+osw_types_ut_2g_chan_list_cb(void *data)
+{
+    const int *list;
+
+    list = osw_2g_chan_list(1, 20, 11);
+    assert(list != NULL);
+    assert(list[0] == 1);
+    assert(list[1] == 0);
+
+    list = osw_2g_chan_list(11, 20, 11);
+    assert(list != NULL);
+    assert(list[0] == 11);
+    assert(list[1] == 0);
+
+    list = osw_2g_chan_list(13, 20, 13);
+    assert(list != NULL);
+    assert(list[0] == 13);
+    assert(list[1] == 0);
+
+    list = osw_2g_chan_list(13, 20, 11);
+    assert(list == NULL);
+
+    list = osw_2g_chan_list(1, 40, 11);
+    assert(list != NULL);
+    assert(list[0] == 1);
+    assert(list[1] == 5);
+    assert(list[2] == 0);
+
+    /* Current expectation is that HT40+ is always preferred
+     * until it is not possible to do, at which point HT40-
+     * should be returned.
+     */
+    list = osw_2g_chan_list(6, 40, 11);
+    assert(list != NULL);
+    assert(list[0] == 6);
+    assert(list[1] == 10);
+    assert(list[2] == 0);
+
+    list = osw_2g_chan_list(11, 40, 11);
+    assert(list != NULL);
+    assert(list[0] == 7);
+    assert(list[1] == 11);
+    assert(list[2] == 0);
+
+    list = osw_2g_chan_list(13, 40, 11);
+    assert(list == NULL);
+
+    list = osw_2g_chan_list(9, 40, 11);
+    assert(list != NULL);
+    assert(list[0] == 5);
+    assert(list[1] == 9);
+    assert(list[2] == 0);
+
+    list = osw_2g_chan_list(9, 40, 13);
+    assert(list != NULL);
+    assert(list[0] == 9);
+    assert(list[1] == 13);
+    assert(list[2] == 0);
+
+}
+
+static void
+osw_types_ut_module_init_cb(void *data)
+{
+    osw_ut_register("osw_types_ut_2g_chan_list", osw_types_ut_2g_chan_list_cb, NULL);
+}
+
+static void
+osw_types_ut_module_fini_cb(void *data)
+{
+}
+
+MODULE(osw_types_ut_module,
+       osw_types_ut_module_init_cb,
+       osw_types_ut_module_fini_cb);
Index: device-core/src/lib/osw/src/osw_ut.c
===================================================================
--- /dev/null
+++ device-core/src/lib/osw/src/osw_ut.c
@@ -0,0 +1,157 @@
+#include <assert.h>
+#include <string.h>
+#include <sys/wait.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <ev.h>
+
+#include <util.h>
+#include <module.h>
+#include <const.h>
+
+#include "osw_ut.h"
+#include "osw_drv_i.h"
+
+struct osw_ut_module {
+    char *name;
+    char *file_name;
+    char *fun_name;
+    void *data;
+    osw_ut_module_run_f fun;
+
+    struct osw_ut_module *next;
+};
+
+static struct osw_ut_module* g_modules = NULL;
+
+void
+osw_ut_register_raw(const char *name,
+                    const char *file_name,
+                    const char *fun_name,
+                    osw_ut_module_run_f fun,
+                    void *data)
+{
+    struct osw_ut_module *module;
+
+    assert(name);
+    assert(file_name);
+    assert(fun_name);
+    assert(fun);
+
+    assert((module = calloc(1, sizeof(struct osw_ut_module))));
+    assert((module->name = strdup(name)));
+    assert((module->file_name = strdup(file_name)));
+    assert((module->fun_name = strdup(fun_name)));
+    module->fun = fun;
+    module->data = data;
+
+    if(g_modules)
+        module->next = g_modules;
+
+    g_modules = module;
+}
+
+struct osw_ut_proc {
+    struct ev_child child;
+    struct ev_io io;
+    int fds[2];
+    char *output;
+    bool verbose;
+};
+
+static void
+osw_ut_child_cb(EV_P_ ev_child *arg, int events)
+{
+    ev_child_stop(EV_A_ arg);
+}
+
+static void
+osw_ut_io_cb(EV_P_ ev_io *arg, int events)
+{
+    struct osw_ut_proc *proc = container_of(arg, struct osw_ut_proc, io);
+    char buf[4096] = {0};
+    ssize_t len = read(arg->fd, buf, sizeof(buf) - 1);
+
+    if (len <= 0) {
+        ev_io_stop(EV_A_ arg);
+        close(arg->fd);
+        return;
+    }
+
+    /* FIXME: This could be more efficient (less copying)
+     * and also rotate logs (to avoid running out of memory
+     * if logs become excessively long (which shouldn't
+     * really happen, but hey). This is good enough for now.
+     */
+    if (proc->verbose)
+        write(fileno(stdout), buf, len);
+    else
+        strgrow(&proc->output, "%s", buf);
+}
+
+static void
+osw_ut_run_proc(struct osw_ut_proc *p, struct osw_ut_module *m)
+{
+    assert(pipe(p->fds) == 0);
+    const pid_t pid = fork();
+
+    if (pid == 0) {
+        assert(close(p->fds[0]) == 0);
+        assert(close(1) == 0);
+        assert(close(2) == 0);
+        assert(dup2(p->fds[1], 1) == 1);
+        assert(dup2(p->fds[1], 2) == 2);
+        ev_loop_destroy(EV_DEFAULT);
+        ev_default_loop(EVFLAG_FORKCHECK);
+        osw_drv_unregister_all();
+        m->fun(m->data);
+        exit(EXIT_SUCCESS);
+        return;
+    }
+
+    assert(close(p->fds[1]) == 0);
+    ev_child_init(&p->child, osw_ut_child_cb, pid, 0);
+    ev_child_start(EV_DEFAULT_ &p->child);
+    ev_io_init(&p->io, osw_ut_io_cb, p->fds[0], EV_READ);
+    ev_io_start(EV_DEFAULT_ &p->io);
+    ev_run(EV_DEFAULT_ 0);
+    ev_child_stop(EV_DEFAULT_ &p->child);
+}
+
+static void
+osw_ut_run_one(struct osw_ut_module *m, bool verbose)
+{
+    struct osw_ut_proc proc = {0};
+
+    proc.verbose = verbose;
+    if (verbose)
+        fprintf(stderr, "    RUN: %s: %s\n", m->file_name, m->fun_name);
+
+    osw_ut_run_proc(&proc, m);
+
+    if (WIFEXITED(proc.child.rstatus)) {
+        fprintf(stderr, "   PASS: %s: %s\n", m->file_name, m->fun_name);
+    } else {
+        if (proc.output != NULL) fprintf(stderr, "%s", proc.output);
+        fprintf(stderr, "!!!FAIL: %s: %s (logs above)\n", m->file_name, m->fun_name);
+    }
+
+    free(proc.output);
+}
+
+void
+osw_ut_run_by_prefix(const char *prefix, bool verbose)
+{
+    struct osw_ut_module *m;
+    for (m = g_modules; m != NULL; m = m->next)
+        if (strstr(m->fun_name, prefix) == m->fun_name)
+            osw_ut_run_one(m, verbose);
+}
+
+void
+osw_ut_run_all(bool verbose)
+{
+    struct osw_ut_module *m;
+    for (m = g_modules; m != NULL; m = m->next)
+        osw_ut_run_one(m, verbose);
+}
Index: device-core/src/lib/osw/unit.mk
===================================================================
--- /dev/null
+++ device-core/src/lib/osw/unit.mk
@@ -0,0 +1,49 @@
+###############################################################################
+#
+# One Wi-Fi
+#
+###############################################################################
+UNIT_NAME := osw
+
+# This unit relies heavily on MODULE(). LIB will generate
+# broken binaries because .ctors section will be stripped
+# away.
+UNIT_TYPE := SHLIB
+UNIT_DIR := lib
+
+UNIT_SRC := src/osw_thread.c
+UNIT_SRC += src/osw_ut.c
+UNIT_SRC += src/osw_drv.c
+UNIT_SRC += src/osw_drv_dummy.c
+UNIT_SRC += src/osw_drv_target.c
+UNIT_SRC += $(if $(wildcard $(PKG_CONFIG_SYSROOT_DIR)/usr/include/ccsp)$(wildcard $(UNIT_PATH)/inc/ccsp),src/osw_drv_wifihal_3_0.c,)
+UNIT_SRC += src/osw_req.c
+UNIT_SRC += src/osw_state.c
+UNIT_SRC += src/osw_conf.c
+UNIT_SRC += src/osw_confsync.c
+UNIT_SRC += src/osw_types.c
+UNIT_SRC += src/osw_mux.c
+UNIT_SRC += src/osw.c
+
+UNIT_CFLAGS := -I$(UNIT_PATH)/inc
+
+# FIXME: This isn't optimal, but the Wifi HAL doesn't really
+# making this any easier by ifdefing functions and parts of
+# structures. The drv_wifihal_3_0.c which is relying on this
+# is supposed to support Wifi HAL 3.0 anyway. If this is
+# tried to be run against older Wifi HAL it'll be missing a
+# lot of symbols so dlsym() will fail anyway.
+UNIT_CFLAGS += -DWIFI_HAL_VERSION_3
+
+UNIT_LDFLAGS := -lpthread
+UNIT_LDFLAGS += -lev
+
+UNIT_EXPORT_CFLAGS := $(UNIT_CFLAGS)
+UNIT_EXPORT_LDFLAGS := $(UNIT_LDFLAGS)
+
+UNIT_DEPS := src/lib/module
+UNIT_DEPS += src/lib/common
+UNIT_DEPS += src/lib/osa
+ifeq ($(BUILD_SHARED_LIB),y)
+UNIT_DEPS += src/lib/opensync
+endif
Index: device-core/src/lib/ow/inc/ow_conf_barrier.h
===================================================================
--- /dev/null
+++ device-core/src/lib/ow/inc/ow_conf_barrier.h
@@ -0,0 +1,24 @@
+#ifndef OW_CONF_BARRIER_H
+#define OW_CONF_BARRIER_H
+
+/**
+ * This function waits for configurations to be applied.
+ *
+ * This is intended to be called from a non-mainloop threads
+ * to synchronize against osw_confsync and ow_conf work.
+ *
+ * It is safe to call this immediatelly after ow_conf_*()
+ * calls that modify a steady-state system into possible
+ * non-steady state that needs a reconfig.
+ *
+ * @param timeout_msec Provides a time limit. Required. If
+ *                     timeout is reached before ow_conf
+ *                     gets into a steady state EAGAIN will
+ *                     be returned.
+ * @return 0 on success
+ *         EAGAIN on timeout or error
+ */
+int
+ow_conf_barrier_wait(int timeout_msec);
+
+#endif /* OW_CONF_BARRIER_H */
Index: device-core/src/lib/ow/inc/ow_core.h
===================================================================
--- /dev/null
+++ device-core/src/lib/ow/inc/ow_core.h
@@ -0,0 +1,32 @@
+#ifndef OW_CORE_H
+#define OW_CORE_H
+
+#include <ev.h>
+
+/**
+ * Prepare OneWifi Core internals.
+ *
+ * Contrary to running, this does not instantiate any
+ * runtime resources, or doesn't run through subsystem
+ * registrations.
+ *
+ * This is intended to provide extra customizations before
+ * mainloop is started.
+ */
+void
+ow_core_init(EV_P);
+
+/**
+ * Start OneWifi Core mainloop.
+ *
+ * The function does not exit under normal circumstances. It
+ * runs ev_run() until no references are left, or until
+ * ev_break().
+ *
+ * It's possible to integrate libev with 3rd party loops
+ * through ev_prepare and ev_check.
+ */
+void
+ow_core_run(EV_P);
+
+#endif /* OW_CORE_H */
Index: device-core/src/lib/ow/inc/ow_core_thread.h
===================================================================
--- /dev/null
+++ device-core/src/lib/ow/inc/ow_core_thread.h
@@ -0,0 +1,34 @@
+#ifndef OW_CORE_THREAD_H
+#define OW_CORE_THREAD_H
+
+typedef void *ow_core_thread_call_fn_t(void *priv);
+
+/**
+ * Start OneWifi Core Thread
+ *
+ * This returns control flow as soon as the Core Thread
+ * logic settles down and is ready to operate through other
+ * APIs that it exposes (eg. ow_conf).
+ *
+ * The alternative is to integrate more tightly with libev
+ * and ow_core_init() and ow_core_start().
+ */
+void
+ow_core_thread_start(void);
+
+/**
+ * Run provided call within Core Thread context.
+ *
+ * This allows thread-safe interactions from a
+ * foreign thread. This is expected to be called
+ * whenever ow_* or osw_* interactions are done
+ * from a non-core thread.
+ *
+ * This function blocks until after the call is
+ * performed on the other end, and returns
+ * whatever the provided function pointer returns.
+ */
+void *
+ow_core_thread_call(ow_core_thread_call_fn_t *fn, void *fn_priv);
+
+#endif /* OW_CORE_THREAD_H */
Index: device-core/src/lib/ow/inc/ow_webconfig.h
===================================================================
--- /dev/null
+++ device-core/src/lib/ow/inc/ow_webconfig.h
@@ -0,0 +1,20 @@
+#ifndef OW_WEBCONFIG_H
+#define OW_WEBCONFIG_H
+
+#include <ccsp/wifi_hal.h>
+
+void
+ow_webconfig_get_phy(const char *phy_name,
+                     wifi_radio_operationParam_t *oper,
+                     wifi_vap_info_map_t *map);
+
+void
+ow_webconfig_set_phy(const char *phy_name,
+                     const wifi_radio_operationParam_t *oper);
+
+void
+ow_webconfig_set_vif(const char *phy_name,
+                     const char *vif_name,
+                     const wifi_vap_info_t *vap);
+
+#endif
Index: device-core/src/lib/ow/kconfig/Kconfig.libs
===================================================================
--- /dev/null
+++ device-core/src/lib/ow/kconfig/Kconfig.libs
@@ -0,0 +1,7 @@
+menuconfig OW
+    bool "OneWifi Library (OW)"
+    default y
+    help
+        This provides the bulk of OneWifi logic. It can be
+        used either in a single process via ow_core, or as a
+        thread via ow_core_thread.
Index: device-core/src/lib/ow/scripts/run_uml.sh
===================================================================
--- /dev/null
+++ device-core/src/lib/ow/scripts/run_uml.sh
@@ -0,0 +1,32 @@
+#!/bin/sh -axe
+#
+# This is intended to be run from (the same as native target
+# was built in) docker instance, from the opensync root
+# directory (the one, where core/, platform/ and vendor/
+# directories are at).
+#
+
+prepare=$(readlink -f "$0" | cut -f 1 -d '.')_prepare.sh
+$prepare
+self=$(readlink -f "$0")
+init="${self%.*}_init.sh"
+wm=$(readlink -f core/work/native-*/bin/wm)
+db=$(readlink -f core/work/native-*/rootfs/usr/opensync/etc/conf.db.bck)
+ovsh=$(readlink -f core/work/native-*/bin/ovsh)
+mem=${mem:-128M}
+dir=$(dirname "$self")
+
+linux.uml \
+	mem=$mem \
+	time-travel=inf-cpu \
+	hostfs=/ \
+	root=none \
+	rootfstype=hostfs \
+	mac80211_hwsim.radios=2 \
+	rootflags=/ \
+	init=$init \
+	env=$(env | grep opt_ | base64 -w0) \
+	env_dir=$dir \
+	env_db=$db \
+	env_wm=$wm \
+	env_cmd="$@"
Index: device-core/src/lib/ow/scripts/run_uml_init.sh
===================================================================
--- /dev/null
+++ device-core/src/lib/ow/scripts/run_uml_init.sh
@@ -0,0 +1,79 @@
+#!/bin/bash -ax
+export USER_MODE_LINUX=y
+
+mount -t proc proc /proc
+mount -t sysfs sys /sys
+mount -t tmpfs tmp /tmp
+mount -t tmpfs tmp /var
+mount -o rw,remount /
+mkdir -p /var/run
+ip link set lo up
+
+PATH=/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin
+dir=$(grep -o 'env_dir=[^ ]*' /proc/cmdline | cut -d= -f2)
+env=$(grep -o 'env=[^ ]*' /proc/cmdline | cut -d= -f2)
+wm=$(grep -o 'env_wm=[^ ]*' /proc/cmdline | cut -d= -f2)
+db=$(grep -o 'env_db=[^ ]*' /proc/cmdline | cut -d= -f2)
+cmd=$(grep -o 'env_cmd=.*' /proc/cmdline | cut -d= -f2-)
+PATH=$PATH:$(dirname "$wm")
+
+eval "$(echo "$env" | base64 -d)"
+
+iw dev wlan0 del || true
+iw dev wlan1 del || true
+iw phy phy0 interface add wlan0 type station
+iw phy phy0 interface add wlan0_1 type station
+iw phy phy0 interface add wlan0_2 type station
+iw phy phy1 interface add wlan1 type station
+iw phy phy1 interface add wlan1_1 type station
+iw phy phy1 interface add wlan1_2 type station
+
+mkdir -p /var/run/hostapd
+mkdir -p /var/run/wpa_supplicant
+rm -rf /var/run/hostapd
+rm -rf /var/run/wpa_supplicant
+
+hostapd -g /var/run/hostapd/global -B -f /tmp/hapd-glob.log -dd -t
+wpa_supplicant -g /var/run/wpa_supplicantglobal -B -f /tmp/wpas_glob.log -dd -t
+
+db1=/var/run/db1.sock
+db2=/var/run/db2.sock
+conf1=/var/lib/openvswitch/conf1.db
+conf2=/var/lib/openvswitch/conf2.db
+
+mkdir -p /var/lib/openvswitch
+mkdir -p /var/run/openvswitch
+cp -v "$db" "$conf1"
+cp -v "$db" "$conf2"
+
+dut="env PLUME_OVSDB_SOCK_PATH=$db1 sh -axe"
+dut_phy=phy0
+dut_vif_sta=wlan0
+dut_vif_ap0=wlan0_1
+dut_vif_ap1=wlan0_2
+dut_vif_sta_idx=0
+dut_vif_ap0_idx=1
+dut_vif_ap1_idx=2
+dut_mac_sta=$(cat /sys/class/net/$dut_vif_sta/address)
+dut_mac_ap0=$(cat /sys/class/net/$dut_vif_ap0/address)
+dut_mac_ap1=$(cat /sys/class/net/$dut_vif_ap1/address)
+
+ulimit -c unlimited
+echo /tmp/core > /proc/sys/kernel/core_pattern
+cd "$dir"
+
+# This runs 2 WM instances, one nested in another, but
+# otherwise operating on 2 databases. The $dut and $ref take
+# care of wrapping things so that, eg. ovsh works with the
+# correct WM2 instance. Running them like that allows the
+# test flow to finish when the inner most test script
+# finishes, or if something crashes at any layer.
+time ovsdb-server \
+	--remote=punix:$db1 \
+	--run "env PLUME_OVSDB_SOCK_PATH=$db1 $cmd" \
+	"$conf1"
+
+cp /tmp/*.log "logs/$cmd/"
+cp /tmp/core "logs/$cmd/"
+
+halt -f -p
Index: device-core/src/lib/ow/scripts/run_uml_prepare.sh
===================================================================
--- /dev/null
+++ device-core/src/lib/ow/scripts/run_uml_prepare.sh
@@ -0,0 +1,9 @@
+#!/bin/sh
+nice -n 19 make \
+	-C core \
+	TARGET=native \
+	IMAGE_DEPLOYMENT_PROFILE=dev-debug \
+	-j $(nproc) \
+	src/ow \
+	ovsdb-create \
+	src/tools/ovsh
Index: device-core/src/lib/ow/src/ow_acl_kick.c
===================================================================
--- /dev/null
+++ device-core/src/lib/ow/src/ow_acl_kick.c
@@ -0,0 +1,231 @@
+#include <module.h>
+#include <log.h>
+#include <const.h>
+#include <memutil.h>
+#include <ds_tree.h>
+#include <osw_ut.h>
+#include <osw_state.h>
+#include <osw_mux.h>
+#include "ow_conf.h"
+
+/*
+ * OneWifi ACL Kick
+ *
+ * ACL in drivers themselves don't (typically) kick stations
+ * when ACL is changed. The usecase for that is, eg.
+ * steering, where one first prepares the ACL into a desired
+ * state and then initiates actions like sending Deauth or
+ * Action frames to stations of interest.
+ *
+ * This modules makes sure that ACLs configured via ow_conf
+ * are enforced at all times, ie. regardless of the ordering
+ * of ACL mutation and stations connecting/disconnecting, a
+ * client that is effectivelly banned through the ACL, will
+ * be kicked if necessary.
+ *
+ * This could be improved by looking at osw_state as well.
+ * Whatever ow_conf expresses to be configured on the ACL
+ * doesn't necessarily mean it will be configured on an
+ * interface because osw_conf can mutate the configuration.
+ */
+
+struct ow_acl_kick {
+    struct ow_conf_observer conf_obs;
+    struct osw_state_observer state_obs;
+    struct ds_tree vif_tree;
+    ev_timer work;
+};
+
+struct ow_acl_kick_vif {
+    struct ds_tree_node node;
+    char *vif_name;
+};
+
+static bool
+ow_acl_kick_addr_is_allowed(const char *vif_name,
+                            const struct osw_hwaddr *addr)
+{
+    const enum osw_acl_policy *p = ow_conf_vif_get_ap_acl_policy(vif_name);
+    if (p == NULL)
+        return true;
+
+    const bool listed = ow_conf_vif_has_ap_acl(vif_name, addr);
+    switch (*p) {
+        case OSW_ACL_NONE: return true;
+        case OSW_ACL_ALLOW_LIST: return (listed == true);
+        case OSW_ACL_DENY_LIST: return (listed == false);
+    }
+
+    /* shouldn't reach here */
+    assert(0);
+    return true;
+}
+
+static void
+ow_acl_kick_sta_police(const struct osw_state_sta_info *sta)
+{
+    const char *phy_name = sta->vif->phy->phy_name;
+    const char *vif_name = sta->vif->vif_name;
+    const struct osw_hwaddr *sta_addr = sta->mac_addr;
+    const int reason = 1; /* unspecified */
+
+    LOGD("ow: acl kick: %s/"OSW_HWADDR_FMT": policing",
+         vif_name, OSW_HWADDR_ARG(sta_addr));
+
+    if (ow_acl_kick_addr_is_allowed(vif_name, sta_addr) == true)
+        return;
+
+    LOGI("ow: acl kick: %s/"OSW_HWADDR_FMT": "
+         "connected but not allowed, kicking",
+         vif_name, OSW_HWADDR_ARG(sta_addr));
+
+    osw_mux_request_sta_deauth(phy_name, vif_name, sta_addr, reason);
+}
+
+static void
+ow_acl_kick_sta_police_sta_cb(const struct osw_state_sta_info *sta,
+                              void *priv)
+{
+    ow_acl_kick_sta_police(sta);
+}
+
+static void
+ow_acl_kick_vif_add(struct ow_acl_kick *oak, const char *vif_name)
+{
+    struct ow_acl_kick_vif *vif = CALLOC(1, sizeof(*vif));
+    vif->vif_name = STRDUP(vif_name);
+    ds_tree_insert(&oak->vif_tree, vif, vif->vif_name);
+    ev_timer_stop(EV_DEFAULT_ &oak->work);
+    ev_timer_set(&oak->work, 0, 0);
+    ev_timer_start(EV_DEFAULT_ &oak->work);
+}
+
+static void
+ow_acl_kick_vif_del(struct ow_acl_kick *oak, struct ow_acl_kick_vif *vif)
+{
+    ds_tree_remove(&oak->vif_tree, vif);
+    FREE(vif->vif_name);
+    FREE(vif);
+}
+
+static void
+ow_acl_kick_work_cb(EV_P_ ev_timer *arg, int events)
+{
+    struct ow_acl_kick *oak = container_of(arg, struct ow_acl_kick, work);
+    struct ow_acl_kick_vif *vif;
+    struct ow_acl_kick_vif *tmp;
+    const char *phy_name = NULL;
+
+    ds_tree_foreach_safe(&oak->vif_tree, vif, tmp) {
+        LOGD("ow: acl kick: %s: doing work", vif->vif_name);
+        osw_state_sta_get_list(ow_acl_kick_sta_police_sta_cb,
+                               phy_name, vif->vif_name, NULL);
+        ow_acl_kick_vif_del(oak, vif);
+    }
+}
+
+static void
+ow_acl_kick_conf_vif_changed_cb(struct ow_conf_observer *obs,
+                                const char *vif_name)
+{
+    struct ow_acl_kick *oak = container_of(obs, struct ow_acl_kick, conf_obs);
+    struct ow_acl_kick_vif *vif = ds_tree_find(&oak->vif_tree, vif_name);
+    if (vif != NULL) return;
+    LOGD("ow: acl kick: %s: adding work", vif_name);
+    ow_acl_kick_vif_add(oak, vif_name);
+}
+
+static void
+ow_acl_kick_sta_connected_cb(struct osw_state_observer *obs,
+                             const struct osw_state_sta_info *sta)
+{
+    ow_acl_kick_sta_police(sta);
+}
+
+static void
+ow_acl_kick_sta_changed_cb(struct osw_state_observer *obs,
+                           const struct osw_state_sta_info *sta)
+{
+    ow_acl_kick_sta_police(sta);
+}
+
+static struct ow_acl_kick g_ow_acl_kick = {
+    .conf_obs = {
+        .name = __FILE__,
+        .vif_changed_fn = ow_acl_kick_conf_vif_changed_cb,
+    },
+    .state_obs = {
+        .name = __FILE__,
+        .sta_connected_fn = ow_acl_kick_sta_connected_cb,
+        .sta_changed_fn = ow_acl_kick_sta_changed_cb,
+    },
+    .vif_tree = DS_TREE_INIT(ds_str_cmp, struct ow_acl_kick_vif, node),
+};
+
+static void
+ow_acl_kick_init(struct ow_acl_kick *oak)
+{
+    LOGI("ow: acl kick: initializing");
+    ev_timer_init(&oak->work, ow_acl_kick_work_cb, 0, 0);
+    ow_conf_register_observer(&oak->conf_obs);
+    osw_state_register_observer(&oak->state_obs);
+}
+
+static void
+ow_acl_kick_ut_cb(void *data)
+{
+    const char *vif_name = "vif1";
+    const struct osw_hwaddr addr1 = { .octet = {0,1,2,3,4,5} };
+    const struct osw_hwaddr addr2 = { .octet = {0,2,3,4,5,6} };
+    const enum osw_acl_policy none = OSW_ACL_NONE;
+    const enum osw_acl_policy allow = OSW_ACL_ALLOW_LIST;
+    const enum osw_acl_policy deny = OSW_ACL_DENY_LIST;
+
+    ow_conf_init();
+
+    ow_conf_vif_set_ap_acl_policy(vif_name, &deny);
+    ow_conf_vif_flush_ap_acl(vif_name);
+    ow_conf_vif_add_ap_acl(vif_name, &addr1);
+    assert(ow_acl_kick_addr_is_allowed(vif_name, &addr1) == false);
+    assert(ow_acl_kick_addr_is_allowed(vif_name, &addr2) == true);
+
+    ow_conf_vif_set_ap_acl_policy(vif_name, &deny);
+    ow_conf_vif_flush_ap_acl(vif_name);
+    ow_conf_vif_add_ap_acl(vif_name, &addr2);
+    assert(ow_acl_kick_addr_is_allowed(vif_name, &addr1) == true);
+    assert(ow_acl_kick_addr_is_allowed(vif_name, &addr2) == false);
+
+    ow_conf_vif_set_ap_acl_policy(vif_name, &none);
+    ow_conf_vif_flush_ap_acl(vif_name);
+    ow_conf_vif_add_ap_acl(vif_name, &addr2);
+    assert(ow_acl_kick_addr_is_allowed(vif_name, &addr1) == true);
+    assert(ow_acl_kick_addr_is_allowed(vif_name, &addr2) == true);
+
+    ow_conf_vif_set_ap_acl_policy(vif_name, &allow);
+    ow_conf_vif_flush_ap_acl(vif_name);
+    ow_conf_vif_add_ap_acl(vif_name, &addr1);
+    assert(ow_acl_kick_addr_is_allowed(vif_name, &addr1) == true);
+    assert(ow_acl_kick_addr_is_allowed(vif_name, &addr2) == false);
+
+    ow_conf_vif_set_ap_acl_policy(vif_name, &allow);
+    ow_conf_vif_flush_ap_acl(vif_name);
+    ow_conf_vif_add_ap_acl(vif_name, &addr2);
+    assert(ow_acl_kick_addr_is_allowed(vif_name, &addr1) == false);
+    assert(ow_acl_kick_addr_is_allowed(vif_name, &addr2) == true);
+}
+
+static void
+ow_acl_kick_module_init_cb(void *data)
+{
+    ow_acl_kick_init(&g_ow_acl_kick);
+    osw_ut_register("ow_acl_kick_ut", ow_acl_kick_ut_cb, NULL);
+}
+
+static void
+ow_acl_kick_module_fini_cb(void *data)
+{
+}
+
+MODULE(ow_acl_kick_module,
+       ow_acl_kick_module_init_cb,
+       ow_acl_kick_module_fini_cb);
Index: device-core/src/lib/ow/src/ow_bus.c
===================================================================
--- /dev/null
+++ device-core/src/lib/ow/src/ow_bus.c
@@ -0,0 +1,22 @@
+#include <log.h>
+#include "ow_bus.h"
+
+static struct ds_dlist g_ow_bus_list = DS_DLIST_INIT(struct ow_bus_ops, node);
+
+void
+ow_bus_register_ops(struct ow_bus_ops *ops)
+{
+    LOGD("ow: bus: %s: registering", ops->name);
+    ds_dlist_insert_tail(&g_ow_bus_list, ops);
+}
+
+void
+ow_bus_init(void)
+{
+    struct ow_bus_ops *ops;
+
+    ds_dlist_foreach(&g_ow_bus_list, ops) {
+        LOGI("ow: bus: %s: initializing", ops->name);
+        if (ops->init_fn != NULL) ops->init_fn(ops);
+    }
+}
Index: device-core/src/lib/ow/src/ow_bus.h
===================================================================
--- /dev/null
+++ device-core/src/lib/ow/src/ow_bus.h
@@ -0,0 +1,20 @@
+#ifndef OW_BUS_H
+#define OW_BUS_H
+
+struct ow_bus_ops;
+
+typedef void ow_bus_init_fn_t(struct ow_bus_ops *ops);
+
+struct ow_bus_ops {
+    const char *name;
+    ow_bus_init_fn_t *const init_fn;
+    struct ds_dlist_node node;
+};
+
+void
+ow_bus_register_ops(struct ow_bus_ops *ops);
+
+void
+ow_bus_init(void);
+
+#endif /* OW_BUS_H */
Index: device-core/src/lib/ow/src/ow_conf.c
===================================================================
--- /dev/null
+++ device-core/src/lib/ow/src/ow_conf.c
@@ -0,0 +1,1345 @@
+#include <osw_thread.h>
+#include <osw_state.h>
+#include <osw_conf.h>
+#include <osw_confsync.h>
+#include <osw_req.h>
+#include <osw_ut.h>
+#include <osw_drv_dummy.h>
+#include <osw.h>
+#include "ow_conf.h"
+#include <module.h>
+#include <memutil.h>
+#include <ds_tree.h>
+#include <const.h>
+#include <util.h>
+#include <log.h>
+#include <ev.h>
+
+struct ow_conf_phy {
+    struct ds_tree_node node;
+    char *phy_name;
+    bool *enabled;
+    bool *ap_ht_enabled;
+    bool *ap_vht_enabled;
+    bool *ap_he_enabled;
+    int *tx_chainmask;
+    int *ap_beacon_interval_tu;
+    struct osw_channel *ap_channel;
+};
+
+struct ow_conf_vif {
+    struct ds_tree_node node;
+    char *phy_name;
+    char *vif_name;
+
+    bool *enabled;
+    enum osw_vif_type *type;
+
+    struct osw_channel *ap_channel;
+    struct osw_ssid *ap_ssid;
+    struct osw_ifname *ap_bridge_if_name;
+    struct ds_tree ap_psk_tree; /* ow_conf_psk */
+    struct ds_tree ap_acl_tree; /* ow_conf_acl */
+    bool *ap_ssid_hidden;
+    bool *ap_isolated;
+    bool *ap_ht_enabled;
+    bool *ap_vht_enabled;
+    bool *ap_he_enabled;
+    bool *ap_wpa;
+    bool *ap_rsn;
+    bool *ap_pairwise_tkip;
+    bool *ap_pairwise_ccmp;
+    bool *ap_akm_psk;
+    bool *ap_akm_sae;
+    bool *ap_akm_ft_psk;
+    bool *ap_akm_ft_sae;
+    bool *ap_wps;
+    bool *ap_wmm;
+    bool *ap_wmm_uapsd;
+    bool *ap_wnm_bss_trans;
+    bool *ap_rrm_neighbor_report;
+    bool *ap_mcast2ucast;
+    int *ap_group_rekey_seconds;
+    int *ap_ft_mobility_domain;
+    int *ap_beacon_interval_tu;
+    enum osw_pmf *ap_pmf;
+    enum osw_acl_policy *ap_acl_policy;
+};
+
+struct ow_conf_acl {
+    struct ds_tree_node node;
+    struct osw_hwaddr mac_addr;
+};
+
+struct ow_conf_psk {
+    struct ds_tree_node node;
+    struct ow_conf_vif *vif;
+    struct osw_ap_psk ap_psk;
+};
+
+struct ow_conf {
+    struct osw_conf_mutator conf_mutator;
+    struct osw_conf_observer conf_observer;
+    struct osw_state_observer state_observer;
+    struct osw_confsync confsync;
+    ev_timer work;
+    struct ds_tree phy_tree;
+    struct ds_tree vif_tree;
+    struct ds_dlist obs_list;
+    bool force;
+    bool cs_settled;
+    bool cs_idle;
+    bool settled;
+};
+
+static int
+ow_conf_acl_cmp(const void *a, const void *b)
+{
+    const struct osw_hwaddr *x = a;
+    const struct osw_hwaddr *y = b;
+    return memcmp(x, y, sizeof(*x));
+}
+
+static void
+ow_conf_notify_agitated(struct ow_conf *c)
+{
+    struct ow_conf_observer *obs;
+    ds_dlist_foreach(&c->obs_list, obs)
+        if (obs->agitated_fn != NULL)
+            obs->agitated_fn(obs);
+}
+
+static void
+ow_conf_notify_settled(struct ow_conf *c)
+{
+    struct ow_conf_observer *obs;
+    ds_dlist_foreach(&c->obs_list, obs)
+        if (obs->settled_fn != NULL)
+            obs->settled_fn(obs);
+}
+
+static void
+ow_conf_notify(struct ow_conf *c, const bool settled)
+{
+    if (c->settled == settled) {
+        LOGD("ow: conf: settled not changed");
+        return;
+    }
+
+    if (settled == true) {
+        LOGI("ow: conf: settled");
+        ow_conf_notify_settled(c);
+    }
+
+    if (settled == false) {
+        LOGI("ow: conf: agitated");
+        ow_conf_notify_agitated(c);
+    }
+
+    c->settled = settled;
+}
+
+static void
+ow_conf_update_settled(struct ow_conf *c)
+{
+    const bool work_settled = !ev_is_active(&c->work);
+    ow_conf_notify(c, c->cs_settled && c->cs_idle && work_settled);
+}
+
+static struct ow_conf_phy *
+ow_conf_phy_alloc(struct ow_conf *self, const char *phy_name)
+{
+    struct ow_conf_phy *phy = CALLOC(1, sizeof(*phy));
+    phy->phy_name = STRDUP(phy_name);
+    ds_tree_insert(&self->phy_tree, phy, phy->phy_name);
+    return phy;
+}
+
+static struct ow_conf_phy *
+ow_conf_phy_get(struct ow_conf *self, const char *phy_name)
+{
+    return ds_tree_find(&self->phy_tree, phy_name) ?: ow_conf_phy_alloc(self, phy_name);
+}
+
+static struct ow_conf_phy *
+ow_conf_phy_get_ro(struct ow_conf *self, const char *phy_name)
+{
+    return ds_tree_find(&self->phy_tree, phy_name);
+}
+
+static struct ow_conf_vif *
+ow_conf_vif_alloc(struct ow_conf *self, const char *vif_name)
+{
+    struct ow_conf_vif *vif = CALLOC(1, sizeof(*vif));
+    vif->vif_name = STRDUP(vif_name);
+    ds_tree_insert(&self->vif_tree, vif, vif->vif_name);
+    ds_tree_init(&vif->ap_psk_tree, ds_int_cmp, struct ow_conf_psk, node);
+    ds_tree_init(&vif->ap_acl_tree, ow_conf_acl_cmp, struct ow_conf_acl, node);
+    return vif;
+}
+
+static struct ow_conf_vif *
+ow_conf_vif_get(struct ow_conf *self, const char *vif_name)
+{
+    return ds_tree_find(&self->vif_tree, vif_name) ?: ow_conf_vif_alloc(self, vif_name);
+}
+
+static struct ow_conf_vif *
+ow_conf_vif_get_ro(struct ow_conf *self, const char *vif_name)
+{
+    return ds_tree_find(&self->vif_tree, vif_name);
+}
+
+static void
+ow_conf_work(struct ow_conf *self)
+{
+    struct osw_conf *conf = osw_conf_build();
+    struct osw_conf *state = osw_conf_build_from_state();
+    const bool force = self->force;
+    self->force = false;
+    osw_confsync_set(&self->confsync, conf, state, force);
+}
+
+static void
+ow_conf_work_cb(EV_P_ ev_timer *arg, int event)
+{
+    struct ow_conf *self = container_of(arg, struct ow_conf, work);
+    ow_conf_work(self);
+    ow_conf_update_settled(self);
+}
+
+static void
+ow_conf_work_schedule(struct ow_conf *self)
+{
+    ev_timer_start(EV_DEFAULT_ &self->work);
+    ow_conf_update_settled(self);
+}
+
+static void
+ow_conf_conf_mutated_cb(struct osw_conf_observer *observer)
+{
+    struct ow_conf *self = container_of(observer, struct ow_conf, conf_observer);
+    self->force = true;
+    ow_conf_work_schedule(self);
+}
+
+static void
+ow_conf_conf_mutate_phy(struct ow_conf *self,
+                        struct osw_conf_phy *osw_phy)
+{
+    const char *phy_name = osw_phy->phy_name;
+    struct ow_conf_phy *ow_phy = ds_tree_find(&self->phy_tree, phy_name);
+
+    if (ow_phy == NULL) return;
+
+    if (ow_phy->enabled != NULL) osw_phy->enabled = *ow_phy->enabled;
+    if (ow_phy->tx_chainmask != NULL) osw_phy->tx_chainmask = *ow_phy->tx_chainmask;
+}
+
+static void
+ow_conf_conf_mutate_acl(struct ds_tree *in,
+                        struct ds_tree *out)
+{
+    struct osw_conf_acl *p;
+    struct ow_conf_acl *i;
+
+    /* FIXME: differentiate between overwrite and append */
+    while ((i = ds_tree_head(out)) != NULL) {
+        ds_tree_remove(out, i);
+        FREE(i);
+    }
+
+    ds_tree_foreach(in, i) {
+        p = MALLOC(sizeof(*p));
+        p->mac_addr = i->mac_addr;
+        ds_tree_insert(out, p, &p->mac_addr);
+    }
+}
+
+static void
+ow_conf_conf_mutate_psk(struct ds_tree *in,
+                        struct ds_tree *out)
+{
+    struct osw_conf_psk *p;
+    struct ow_conf_psk *i;
+
+    /* FIXME: differentiate between overwrite and append */
+    while ((i = ds_tree_head(out)) != NULL) {
+        ds_tree_remove(out, i);
+        FREE(i);
+    }
+
+    ds_tree_foreach(in, i) {
+        p = MALLOC(sizeof(*p));
+        p->ap_psk = i->ap_psk;
+        ds_tree_insert(out, p, &p->ap_psk.key_id);
+    }
+}
+
+static void
+ow_conf_conf_mutate_vif_ap(struct ow_conf_phy *ow_phy,
+                           struct ow_conf_vif *ow_vif,
+                           struct osw_conf_vif *osw_vif)
+{
+    if (ow_phy != NULL) {
+        if (ow_phy->ap_ht_enabled != NULL) osw_vif->u.ap.mode.ht_enabled = *ow_phy->ap_ht_enabled;
+        if (ow_phy->ap_vht_enabled != NULL) osw_vif->u.ap.mode.vht_enabled = *ow_phy->ap_vht_enabled;
+        if (ow_phy->ap_he_enabled != NULL) osw_vif->u.ap.mode.he_enabled = *ow_phy->ap_he_enabled;
+        if (ow_phy->ap_beacon_interval_tu != NULL) osw_vif->u.ap.beacon_interval_tu = *ow_phy->ap_beacon_interval_tu;
+        if (ow_phy->ap_channel != NULL) osw_vif->u.ap.channel = *ow_phy->ap_channel;
+    }
+    if (ow_vif->ap_channel != NULL) osw_vif->u.ap.channel = *ow_vif->ap_channel;
+    if (ow_vif->ap_ssid != NULL) osw_vif->u.ap.ssid = *ow_vif->ap_ssid;
+    if (ow_vif->ap_bridge_if_name != NULL) osw_vif->u.ap.bridge_if_name = *ow_vif->ap_bridge_if_name;
+    if (ow_vif->ap_ssid_hidden != NULL) osw_vif->u.ap.ssid_hidden = *ow_vif->ap_ssid_hidden;
+    if (ow_vif->ap_isolated != NULL) osw_vif->u.ap.isolated = *ow_vif->ap_isolated;
+    if (ow_vif->ap_ht_enabled != NULL) osw_vif->u.ap.mode.ht_enabled = *ow_vif->ap_ht_enabled;
+    if (ow_vif->ap_vht_enabled != NULL) osw_vif->u.ap.mode.vht_enabled = *ow_vif->ap_vht_enabled;
+    if (ow_vif->ap_he_enabled != NULL) osw_vif->u.ap.mode.he_enabled = *ow_vif->ap_he_enabled;
+    if (ow_vif->ap_wpa != NULL) osw_vif->u.ap.wpa.wpa = *ow_vif->ap_wpa;
+    if (ow_vif->ap_rsn != NULL) osw_vif->u.ap.wpa.rsn = *ow_vif->ap_rsn;
+    if (ow_vif->ap_pairwise_tkip != NULL) osw_vif->u.ap.wpa.pairwise_tkip = *ow_vif->ap_pairwise_tkip;
+    if (ow_vif->ap_pairwise_ccmp != NULL) osw_vif->u.ap.wpa.pairwise_ccmp = *ow_vif->ap_pairwise_ccmp;
+    if (ow_vif->ap_akm_psk != NULL) osw_vif->u.ap.wpa.akm_psk = *ow_vif->ap_akm_psk;
+    if (ow_vif->ap_akm_sae != NULL) osw_vif->u.ap.wpa.akm_sae = *ow_vif->ap_akm_sae;
+    if (ow_vif->ap_akm_ft_psk != NULL) osw_vif->u.ap.wpa.akm_ft_psk = *ow_vif->ap_akm_ft_psk;
+    if (ow_vif->ap_akm_ft_sae != NULL) osw_vif->u.ap.wpa.akm_ft_sae = *ow_vif->ap_akm_ft_sae;
+    if (ow_vif->ap_pmf != NULL) osw_vif->u.ap.wpa.pmf = *ow_vif->ap_pmf;
+    if (ow_vif->ap_group_rekey_seconds != NULL) osw_vif->u.ap.wpa.group_rekey_seconds = *ow_vif->ap_group_rekey_seconds;
+    if (ow_vif->ap_ft_mobility_domain != NULL) osw_vif->u.ap.wpa.ft_mobility_domain = *ow_vif->ap_ft_mobility_domain;
+    if (ow_vif->ap_beacon_interval_tu != NULL) osw_vif->u.ap.beacon_interval_tu = *ow_vif->ap_beacon_interval_tu;
+    if (ow_vif->ap_acl_policy != NULL) osw_vif->u.ap.acl_policy = *ow_vif->ap_acl_policy;
+    if (ow_vif->ap_wps != NULL) osw_vif->u.ap.mode.wps = *ow_vif->ap_wps;
+    if (ow_vif->ap_wmm != NULL) osw_vif->u.ap.mode.wmm_enabled = *ow_vif->ap_wmm;
+    if (ow_vif->ap_wmm_uapsd != NULL) osw_vif->u.ap.mode.wmm_uapsd_enabled = *ow_vif->ap_wmm_uapsd;
+    if (ow_vif->ap_wnm_bss_trans != NULL) osw_vif->u.ap.mode.wnm_bss_trans = *ow_vif->ap_wnm_bss_trans;
+    if (ow_vif->ap_rrm_neighbor_report != NULL) osw_vif->u.ap.mode.rrm_neighbor_report = *ow_vif->ap_rrm_neighbor_report;
+    if (ow_vif->ap_mcast2ucast != NULL) osw_vif->u.ap.mcast2ucast = *ow_vif->ap_mcast2ucast;
+
+    ow_conf_conf_mutate_acl(&ow_vif->ap_acl_tree, &osw_vif->u.ap.acl_tree);
+    ow_conf_conf_mutate_psk(&ow_vif->ap_psk_tree, &osw_vif->u.ap.psk_tree);
+}
+
+static void
+ow_conf_conf_mutate_vif(struct ow_conf *self,
+                        struct osw_conf_vif *osw_vif)
+{
+    const char *phy_name = osw_vif->phy->phy_name;
+    const char *vif_name = osw_vif->vif_name;
+    struct ow_conf_phy *ow_phy = ds_tree_find(&self->phy_tree, phy_name);
+    struct ow_conf_vif *ow_vif = ds_tree_find(&self->vif_tree, vif_name);
+    enum osw_vif_type type = osw_vif->vif_type;
+
+    if (ow_vif == NULL) return;
+    if (ow_vif->phy_name == NULL) return;
+    if (strcmp(ow_vif->phy_name, phy_name) != 0) return;
+
+    /* FIXME: Use macro and add tracing */
+    if (ow_vif->enabled != NULL) osw_vif->enabled = *ow_vif->enabled;
+
+    if (ow_vif->type != NULL)
+        type = *(ow_vif->type);
+
+    switch (type) {
+        case OSW_VIF_UNDEFINED:
+            break;
+        case OSW_VIF_AP:
+            ow_conf_conf_mutate_vif_ap(ow_phy, ow_vif, osw_vif);
+            break;
+        case OSW_VIF_AP_VLAN:
+            break;
+        case OSW_VIF_STA:
+            break;
+    }
+}
+
+static void
+ow_conf_conf_mutate_cb(struct osw_conf_mutator *mutator,
+                       struct osw_conf *conf)
+{
+    struct ow_conf *self = container_of(mutator, struct ow_conf, conf_mutator);
+    struct osw_conf_phy *osw_phy;
+    struct osw_conf_vif *osw_vif;
+
+    /* This only mutates entities that already exist in the
+     * base config given. The base config is derived from
+     * osw_state. The assumption is that it's not possible
+     * to create PHY and VIF out of thin air. All possible
+     * interfaces that are ever to be configured must be
+     * pre-allocated at the system integration level and
+     * exposed by osw_drv implementation(s).
+     */
+    ds_tree_foreach(&conf->phy_tree, osw_phy) {
+        ow_conf_conf_mutate_phy(self, osw_phy);
+
+        ds_tree_foreach(&osw_phy->vif_tree, osw_vif) {
+            ow_conf_conf_mutate_vif(self, osw_vif);
+        }
+    }
+}
+
+static void
+ow_conf_state_busy_cb(struct osw_state_observer *observer)
+{
+    LOGI("ow: conf: state: busy");
+}
+
+static void
+ow_conf_state_idle_cb(struct osw_state_observer *observer)
+{
+    struct ow_conf *self = container_of(observer, struct ow_conf, state_observer);
+    struct osw_conf *conf = osw_conf_build();
+    struct osw_conf *state = osw_conf_build_from_state();
+    LOGI("ow: conf: state: idle");
+    osw_confsync_set(&self->confsync, conf, state, false);
+}
+
+static void
+ow_conf_state_phy_added_cb(struct osw_state_observer *observer,
+                           const struct osw_state_phy_info *phy)
+{
+    struct ow_conf *self = container_of(observer, struct ow_conf, state_observer);
+    LOGI("ow: conf: state: %s: added", phy->phy_name);
+    ow_conf_work_schedule(self);
+}
+
+static void
+ow_conf_state_phy_changed_cb(struct osw_state_observer *observer,
+                             const struct osw_state_phy_info *phy)
+{
+    struct ow_conf *self = container_of(observer, struct ow_conf, state_observer);
+    LOGI("ow: conf: state: %s: changed", phy->phy_name);
+    ow_conf_work_schedule(self);
+}
+
+static void
+ow_conf_state_phy_removed_cb(struct osw_state_observer *observer,
+                             const struct osw_state_phy_info *phy)
+{
+    struct ow_conf *self = container_of(observer, struct ow_conf, state_observer);
+    LOGI("ow: conf: state: %s: removed", phy->phy_name);
+    ow_conf_work_schedule(self);
+}
+
+static void
+ow_conf_state_vif_added_cb(struct osw_state_observer *observer,
+                           const struct osw_state_vif_info *vif)
+{
+    struct ow_conf *self = container_of(observer, struct ow_conf, state_observer);
+    LOGI("ow: conf: state: %s/%s: added", vif->phy->phy_name, vif->vif_name);
+    ow_conf_work_schedule(self);
+}
+
+static void
+ow_conf_state_vif_changed_cb(struct osw_state_observer *observer,
+                             const struct osw_state_vif_info *vif)
+{
+    struct ow_conf *self = container_of(observer, struct ow_conf, state_observer);
+    LOGI("ow: conf: state: %s/%s: changed", vif->phy->phy_name, vif->vif_name);
+    ow_conf_work_schedule(self);
+}
+
+static void
+ow_conf_state_vif_removed_cb(struct osw_state_observer *observer,
+                             const struct osw_state_vif_info *vif)
+{
+    struct ow_conf *self = container_of(observer, struct ow_conf, state_observer);
+    LOGI("ow: conf: state: %s/%s: removed", vif->phy->phy_name, vif->vif_name);
+    ow_conf_work_schedule(self);
+}
+
+static void
+ow_conf_agitated_cb(struct osw_confsync *cs)
+{
+    struct ow_conf *c = container_of(cs, struct ow_conf, confsync);
+    LOGD("ow: conf: confsync: agitated");
+    c->cs_settled = false;
+    ow_conf_update_settled(c);
+    /* FIXME: This could arm a watchdog to detect reconfig
+     * that is failing for too long. Maybe 5 minutes is a
+     * good limit. */
+}
+
+static void
+ow_conf_settled_cb(struct osw_confsync *cs)
+{
+    struct ow_conf *c = container_of(cs, struct ow_conf, confsync);
+    LOGD("ow: conf: confsync: settled");
+    c->cs_settled = true;
+    ow_conf_update_settled(c);
+}
+
+static void
+ow_conf_confsync_idle_cb(struct osw_confsync *cs)
+{
+    struct ow_conf *c = container_of(cs, struct ow_conf, confsync);
+    LOGD("ow: conf: confsync: idle");
+    c->cs_idle = true;
+    ow_conf_update_settled(c);
+}
+
+static void
+ow_conf_confsync_busy_cb(struct osw_confsync *cs)
+{
+    struct ow_conf *c = container_of(cs, struct ow_conf, confsync);
+    LOGD("ow: conf: confsync: busy");
+    c->cs_idle = false;
+    ow_conf_update_settled(c);
+}
+
+static struct ow_conf g_ow_conf = {
+    .phy_tree = DS_TREE_INIT(ds_str_cmp, struct ow_conf_phy, node),
+    .vif_tree = DS_TREE_INIT(ds_str_cmp, struct ow_conf_vif, node),
+    .obs_list = DS_DLIST_INIT(struct ow_conf_observer, node),
+    .conf_mutator = {
+        .name ="ow_conf",
+        .mutate_fn = ow_conf_conf_mutate_cb,
+    },
+    .conf_observer = {
+        .name = "ow_conf",
+        .mutated_fn = ow_conf_conf_mutated_cb,
+    },
+    .state_observer = {
+        .name = "ow_conf",
+        .idle_fn = ow_conf_state_idle_cb,
+        .busy_fn = ow_conf_state_busy_cb,
+        .phy_added_fn = ow_conf_state_phy_added_cb,
+        .phy_changed_fn = ow_conf_state_phy_changed_cb,
+        .phy_removed_fn = ow_conf_state_phy_removed_cb,
+        .vif_added_fn = ow_conf_state_vif_added_cb,
+        .vif_changed_fn = ow_conf_state_vif_changed_cb,
+        .vif_removed_fn = ow_conf_state_vif_removed_cb,
+    },
+    .confsync = {
+        .agitated_fn = ow_conf_agitated_cb,
+        .settled_fn = ow_conf_settled_cb,
+        .idle_fn = ow_conf_confsync_idle_cb,
+        .busy_fn = ow_conf_confsync_busy_cb,
+    },
+};
+
+void
+ow_conf_register_observer(struct ow_conf_observer *obs)
+{
+    struct ow_conf *self = &g_ow_conf;
+
+    LOGI("ow: conf: registering observer: name=%s", obs->name);
+    ds_dlist_insert_tail(&self->obs_list, obs);
+}
+
+static void
+ow_conf_phy_notify_changed(const char *phy_name)
+{
+    struct ow_conf *self = &g_ow_conf;
+    struct ow_conf_observer *obs;
+
+    ds_dlist_foreach(&self->obs_list, obs)
+        if (obs->phy_changed_fn != NULL)
+            obs->phy_changed_fn(obs, phy_name);
+}
+
+static void
+ow_conf_vif_notify_changed(const char *vif_name)
+{
+    struct ow_conf *self = &g_ow_conf;
+    struct ow_conf_observer *obs;
+
+    ds_dlist_foreach(&self->obs_list, obs)
+        if (obs->vif_changed_fn != NULL)
+            obs->vif_changed_fn(obs, vif_name);
+}
+
+void
+ow_conf_phy_unset(const char *phy_name)
+{
+    struct ow_conf *self = &g_ow_conf;
+    struct ow_conf_phy *phy = ow_conf_phy_get(self, phy_name);
+    ds_tree_remove(&self->phy_tree, phy);
+    FREE(phy);
+}
+
+bool
+ow_conf_phy_is_set(const char *phy_name)
+{
+    struct ow_conf *self = &g_ow_conf;
+    return ds_tree_find(&self->phy_tree, phy_name) == NULL ? false : true;
+}
+
+void
+ow_conf_vif_set_phy_name(const char *vif_name,
+                         const char *phy_name)
+{
+    struct ow_conf *self = &g_ow_conf;
+    struct ow_conf_vif *vif = ow_conf_vif_get(self, vif_name);
+    bool changed = ((vif->phy_name == NULL) ||
+                    (vif->phy_name != NULL && phy_name == NULL) ||
+                    (strcmp(vif->phy_name, phy_name) != 0));
+
+    if (changed == true && vif->phy_name == NULL && phy_name != NULL) {
+        LOGI("ow: conf: %s: phy_name set to %s",
+             vif_name, phy_name);
+    }
+
+    if (changed == true && vif->phy_name != NULL && phy_name == NULL) {
+        LOGI("ow: conf: %s: phy_name unset from %s",
+             vif_name, vif->phy_name);
+    }
+
+    if (changed == true && vif->phy_name != NULL && phy_name != NULL) {
+        LOGI("ow: conf: %s: phy_name changed from %s from %s",
+             vif_name, vif->phy_name, phy_name);
+    }
+
+    FREE(vif->phy_name);
+    vif->phy_name = phy_name ? STRDUP(phy_name) : NULL;
+    if (changed) {
+        osw_conf_invalidate(&self->conf_mutator);
+        ow_conf_vif_notify_changed(vif_name);
+    }
+}
+
+const char *
+ow_conf_vif_get_phy_name(const char *vif_name)
+{
+    struct ow_conf *self = &g_ow_conf;
+    struct ow_conf_vif *vif = ow_conf_vif_get_ro(self, vif_name);
+    return vif != NULL ? vif->phy_name : NULL;
+}
+
+bool
+ow_conf_vif_has_ap_acl(const char *vif_name, const struct osw_hwaddr *addr)
+{
+    struct ow_conf *self = &g_ow_conf;
+    struct ow_conf_vif *vif = ow_conf_vif_get_ro(self, vif_name);
+    if (vif == NULL) return false;
+    struct ow_conf_acl *acl = ds_tree_find(&vif->ap_acl_tree, addr);
+    if (acl == NULL) return false;
+    return true;
+}
+
+void
+ow_conf_vif_set_ap_psk(const char *vif_name,
+                       int key_id,
+                       const char *str)
+{
+    struct ow_conf *self = &g_ow_conf;
+    struct ow_conf_vif *vif = ow_conf_vif_get(self, vif_name);
+    struct ow_conf_psk *psk = ds_tree_find(&vif->ap_psk_tree, &key_id);
+
+    if (psk == NULL) {
+        psk = CALLOC(1, sizeof(*psk));
+        psk->ap_psk.key_id = key_id;
+        ds_tree_insert(&vif->ap_psk_tree, psk, &psk->ap_psk.key_id);
+        LOGI("ow: conf: %s: psk: adding: key_id=%d", vif_name, key_id);
+    }
+
+    if (str != NULL)
+        STRSCPY_WARN(psk->ap_psk.psk.str, str);
+
+    if (str == NULL) {
+        LOGI("ow: conf: %s: psk: removing: key_id=%d", vif_name, key_id);
+        ds_tree_remove(&vif->ap_psk_tree, psk);
+        FREE(psk);
+    }
+    osw_conf_invalidate(&self->conf_mutator);
+    ow_conf_vif_notify_changed(vif_name);
+}
+
+void
+ow_conf_vif_flush_ap_psk(const char *vif_name)
+{
+    struct ow_conf *self = &g_ow_conf;
+    struct ow_conf_vif *vif = ow_conf_vif_get(self, vif_name);
+    struct ow_conf_psk *psk;
+
+    while ((psk = ds_tree_head(&vif->ap_psk_tree)) != NULL)
+        ow_conf_vif_set_ap_psk(vif_name, psk->ap_psk.key_id, NULL);
+}
+
+const char *
+ow_conf_vif_get_ap_psk(const char *vif_name,
+                       int key_id)
+{
+    struct ow_conf *self = &g_ow_conf;
+    struct ow_conf_vif *vif = ow_conf_vif_get(self, vif_name);
+    struct ow_conf_psk *psk = ds_tree_find(&vif->ap_psk_tree, &key_id);
+    return psk ? psk->ap_psk.psk.str : NULL;
+}
+
+void
+ow_conf_vif_add_ap_acl(const char *vif_name,
+                       const struct osw_hwaddr *addr)
+{
+    struct ow_conf *self = &g_ow_conf;
+    struct ow_conf_vif *vif = ow_conf_vif_get(self, vif_name);
+    struct ow_conf_acl *acl = ds_tree_find(&vif->ap_acl_tree, addr);
+
+    if (acl != NULL) return;
+
+    LOGI("ow: conf: %s: acl: adding: " OSW_HWADDR_FMT,
+         vif_name, OSW_HWADDR_ARG(addr));
+
+    acl = MALLOC(sizeof(*acl));
+    memcpy(&acl->mac_addr, addr, sizeof(*addr));
+    ds_tree_insert(&vif->ap_acl_tree, acl, &acl->mac_addr);
+    osw_conf_invalidate(&self->conf_mutator);
+    ow_conf_vif_notify_changed(vif_name);
+}
+
+void
+ow_conf_vif_del_ap_acl(const char *vif_name,
+                       const struct osw_hwaddr *addr)
+{
+    struct ow_conf *self = &g_ow_conf;
+    struct ow_conf_vif *vif = ow_conf_vif_get(self, vif_name);
+    struct ow_conf_acl *acl = ds_tree_find(&vif->ap_acl_tree, addr);
+
+    if (acl == NULL) return;
+
+    LOGI("ow: conf: %s: acl: removing: " OSW_HWADDR_FMT,
+         vif_name, OSW_HWADDR_ARG(addr));
+
+    ds_tree_remove(&vif->ap_acl_tree, acl);
+    FREE(acl);
+    osw_conf_invalidate(&self->conf_mutator);
+    ow_conf_vif_notify_changed(vif_name);
+}
+
+void
+ow_conf_vif_flush_ap_acl(const char *vif_name)
+{
+    struct ow_conf *self = &g_ow_conf;
+    struct ow_conf_vif *vif = ow_conf_vif_get(self, vif_name);
+    struct ow_conf_acl *acl;
+
+    while ((acl = ds_tree_head(&vif->ap_acl_tree)) != NULL)
+        ow_conf_vif_del_ap_acl(vif_name, &acl->mac_addr);
+}
+
+#define DEFINE_FIELD(member, type, lookup_type, lookup, fn_set, fn_get, fn_notify, fmt, arg) \
+    void fn_set(const char *key, const type *v) { \
+        osw_thread_sanity_check(); \
+        lookup_type *obj = lookup(&g_ow_conf, key); \
+        bool changed = (obj->member == NULL && v != NULL) || \
+                       (obj->member != NULL && v == NULL) || \
+                       (obj->member != NULL && v != NULL && memcmp(obj->member, v, sizeof(*v)) != 0); \
+        if (changed == true && obj->member != NULL && v != NULL) LOGI("ow: conf: %s: %s changed from " fmt " to " fmt, key, #member, arg(*obj->member), arg(*v)); \
+        if (changed == true && v == NULL) LOGI("ow: conf: %s: %s unset from " fmt, key, #member, arg(*obj->member)); \
+        if (changed == true && obj->member == NULL) LOGI("ow: conf: %s: %s set to " fmt, key, #member, arg(*v)); \
+        FREE(obj->member); \
+        obj->member = NULL; \
+        if (v != NULL) { \
+            obj->member = MALLOC(sizeof(*v)); \
+            memcpy(obj->member, v, sizeof(*v)); \
+        } \
+        if (changed) osw_conf_invalidate(&g_ow_conf.conf_mutator); \
+        if (changed) fn_notify(key); \
+    } \
+    const type *fn_get(const char *key) { \
+        osw_thread_sanity_check(); \
+        lookup_type *obj = lookup##_ro(&g_ow_conf, key); \
+        return obj ? obj->member : NULL; \
+    }
+
+#define FMT_nop "%s"
+#define ARG_nop(x) ""
+
+#define FMT_phy_enabled "%d"
+#define ARG_phy_enabled(x) x
+#define FMT_phy_tx_chainmask "0x%04x"
+#define ARG_phy_tx_chainmask(x) x
+#define FMT_phy_ap_ht_enabled "%d"
+#define ARG_phy_ap_ht_enabled(x) x
+#define FMT_phy_ap_vht_enabled "%d"
+#define ARG_phy_ap_vht_enabled(x) x
+#define FMT_phy_ap_he_enabled "%d"
+#define ARG_phy_ap_he_enabled(x) x
+#define FMT_phy_ap_beacon_interval_tu "%d"
+#define ARG_phy_ap_beacon_interval_tu(x) x
+#define FMT_phy_ap_channel OSW_CHANNEL_FMT
+#define ARG_phy_ap_channel(x) OSW_CHANNEL_ARG(&(x))
+
+#define FMT_vif_enabled "%d"
+#define ARG_vif_enabled(x) x
+#define FMT_vif_type "%s"
+#define ARG_vif_type(x) ((x) == OSW_VIF_UNDEFINED ? "undefined" : \
+                         (x) == OSW_VIF_AP ? "ap" : \
+                         (x) == OSW_VIF_AP_VLAN ? "ap_vlan" : \
+                         (x) == OSW_VIF_STA ? "sta" : \
+                         "")
+#define FMT_vif_ap_channel OSW_CHANNEL_FMT
+#define ARG_vif_ap_channel(x) OSW_CHANNEL_ARG(&(x))
+#define FMT_vif_ap_ssid OSW_SSID_FMT
+#define ARG_vif_ap_ssid(x) OSW_SSID_ARG(&(x))
+#define FMT_vif_ap_bridge_if_name "%s"
+#define ARG_vif_ap_bridge_if_name(x) (x).buf
+#define FMT_vif_ap_ssid_hidden "%d"
+#define ARG_vif_ap_ssid_hidden(x) x
+#define FMT_vif_ap_isolated "%d"
+#define ARG_vif_ap_isolated(x) x
+#define FMT_vif_ap_ht_enabled "%d"
+#define ARG_vif_ap_ht_enabled(x) x
+#define FMT_vif_ap_vht_enabled "%d"
+#define ARG_vif_ap_vht_enabled(x) x
+#define FMT_vif_ap_he_enabled "%d"
+#define ARG_vif_ap_he_enabled(x) x
+#define FMT_vif_ap_wpa "%d"
+#define ARG_vif_ap_wpa(x) x
+#define FMT_vif_ap_rsn "%d"
+#define ARG_vif_ap_rsn(x) x
+#define FMT_vif_ap_pairwise_tkip "%d"
+#define ARG_vif_ap_pairwise_tkip(x) x
+#define FMT_vif_ap_pairwise_ccmp "%d"
+#define ARG_vif_ap_pairwise_ccmp(x) x
+#define FMT_vif_ap_akm_psk "%d"
+#define ARG_vif_ap_akm_psk(x) x
+#define FMT_vif_ap_akm_sae "%d"
+#define ARG_vif_ap_akm_sae(x) x
+#define FMT_vif_ap_akm_ft_psk "%d"
+#define ARG_vif_ap_akm_ft_psk(x) x
+#define FMT_vif_ap_akm_ft_sae "%d"
+#define ARG_vif_ap_akm_ft_sae(x) x
+#define FMT_vif_ap_pmf "%s"
+#define ARG_vif_ap_pmf(x) ((x) == OSW_PMF_DISABLED ? "disabled" : \
+                           (x) == OSW_PMF_OPTIONAL ? "optional" : \
+                           (x) == OSW_PMF_REQUIRED ? "required" : \
+                           "")
+#define FMT_vif_ap_wps "%d"
+#define ARG_vif_ap_wps(x) x
+#define FMT_vif_ap_wmm "%d"
+#define ARG_vif_ap_wmm(x) x
+#define FMT_vif_ap_wmm_uapsd "%d"
+#define ARG_vif_ap_wmm_uapsd(x) x
+#define FMT_vif_ap_wnm_bss_trans "%d"
+#define ARG_vif_ap_wnm_bss_trans(x) x
+#define FMT_vif_ap_rrm_neighbor_report "%d"
+#define ARG_vif_ap_rrm_neighbor_report(x) x
+#define FMT_vif_ap_mcast2ucast "%d"
+#define ARG_vif_ap_mcast2ucast(x) x
+#define FMT_vif_ap_group_rekey_seconds "%d"
+#define ARG_vif_ap_group_rekey_seconds(x) x
+#define FMT_vif_ap_ft_mobility_domain "0x%04x"
+#define ARG_vif_ap_ft_mobility_domain(x) x
+#define FMT_vif_ap_beacon_interval_tu "%d"
+#define ARG_vif_ap_beacon_interval_tu(x) x
+#define FMT_vif_ap_acl_policy "%s"
+#define ARG_vif_ap_acl_policy(x) ((x) == OSW_ACL_NONE ? "none" : \
+                                  (x) == OSW_ACL_ALLOW_LIST ? "allow" : \
+                                  (x) == OSW_ACL_DENY_LIST ? "deny" : \
+                                  "undefined")
+
+#define DEFINE_PHY_FIELD(name) \
+    DEFINE_FIELD(name, \
+                 typeof(*((struct ow_conf_phy *)NULL)->name), \
+                 struct ow_conf_phy, \
+                 ow_conf_phy_get, \
+                 ow_conf_phy_set_##name, \
+                 ow_conf_phy_get_##name, \
+                 ow_conf_phy_notify_changed, \
+                 FMT_phy_##name, ARG_phy_##name)
+
+#define DEFINE_VIF_FIELD(name) \
+    DEFINE_FIELD(name, \
+                 typeof(*((struct ow_conf_vif *)NULL)->name), \
+                 struct ow_conf_vif, \
+                 ow_conf_vif_get, \
+                 ow_conf_vif_set_##name, \
+                 ow_conf_vif_get_##name, \
+                 ow_conf_vif_notify_changed, \
+                 FMT_vif_##name, ARG_vif_##name)
+
+DEFINE_PHY_FIELD(enabled);
+DEFINE_PHY_FIELD(tx_chainmask);
+DEFINE_PHY_FIELD(ap_ht_enabled);
+DEFINE_PHY_FIELD(ap_vht_enabled);
+DEFINE_PHY_FIELD(ap_he_enabled);
+DEFINE_PHY_FIELD(ap_beacon_interval_tu);
+DEFINE_PHY_FIELD(ap_channel);
+
+DEFINE_VIF_FIELD(type);
+DEFINE_VIF_FIELD(enabled);
+
+DEFINE_VIF_FIELD(ap_channel);
+DEFINE_VIF_FIELD(ap_ssid);
+DEFINE_VIF_FIELD(ap_bridge_if_name);
+DEFINE_VIF_FIELD(ap_ssid_hidden);
+DEFINE_VIF_FIELD(ap_isolated);
+DEFINE_VIF_FIELD(ap_ht_enabled);
+DEFINE_VIF_FIELD(ap_vht_enabled);
+DEFINE_VIF_FIELD(ap_he_enabled);
+DEFINE_VIF_FIELD(ap_wpa);
+DEFINE_VIF_FIELD(ap_rsn);
+DEFINE_VIF_FIELD(ap_pairwise_tkip);
+DEFINE_VIF_FIELD(ap_pairwise_ccmp);
+DEFINE_VIF_FIELD(ap_akm_psk);
+DEFINE_VIF_FIELD(ap_akm_sae);
+DEFINE_VIF_FIELD(ap_akm_ft_psk);
+DEFINE_VIF_FIELD(ap_akm_ft_sae);
+DEFINE_VIF_FIELD(ap_group_rekey_seconds);
+DEFINE_VIF_FIELD(ap_ft_mobility_domain);
+DEFINE_VIF_FIELD(ap_beacon_interval_tu);
+DEFINE_VIF_FIELD(ap_pmf);
+DEFINE_VIF_FIELD(ap_acl_policy);
+DEFINE_VIF_FIELD(ap_wps);
+DEFINE_VIF_FIELD(ap_wmm);
+DEFINE_VIF_FIELD(ap_wmm_uapsd);
+DEFINE_VIF_FIELD(ap_wnm_bss_trans);
+DEFINE_VIF_FIELD(ap_rrm_neighbor_report);
+DEFINE_VIF_FIELD(ap_mcast2ucast);
+
+void
+ow_conf_vif_unset(const char *vif_name)
+{
+    struct ow_conf *self = &g_ow_conf;
+    struct ow_conf_vif *vif = ow_conf_vif_get(self, vif_name);
+
+    ds_tree_remove(&self->vif_tree, vif);
+
+    ow_conf_vif_flush_ap_psk(vif_name);
+    ow_conf_vif_flush_ap_acl(vif_name);
+
+    FREE(vif->phy_name);
+    FREE(vif->vif_name);
+    FREE(vif->type);
+    FREE(vif->enabled);
+
+    FREE(vif->ap_channel);
+    FREE(vif->ap_ssid);
+    FREE(vif->ap_bridge_if_name);
+    FREE(vif->ap_ssid_hidden);
+    FREE(vif->ap_isolated);
+    FREE(vif->ap_ht_enabled);
+    FREE(vif->ap_vht_enabled);
+    FREE(vif->ap_he_enabled);
+    FREE(vif->ap_wpa);
+    FREE(vif->ap_rsn);
+    FREE(vif->ap_pairwise_tkip);
+    FREE(vif->ap_pairwise_ccmp);
+    FREE(vif->ap_akm_psk);
+    FREE(vif->ap_akm_sae);
+    FREE(vif->ap_akm_ft_psk);
+    FREE(vif->ap_akm_ft_sae);
+    FREE(vif->ap_group_rekey_seconds);
+    FREE(vif->ap_ft_mobility_domain);
+    FREE(vif->ap_beacon_interval_tu);
+    FREE(vif->ap_pmf);
+    FREE(vif->ap_acl_policy);
+
+    FREE(vif);
+}
+
+bool
+ow_conf_vif_is_set(const char *vif_name)
+{
+    struct ow_conf *self = &g_ow_conf;
+    return ds_tree_find(&self->vif_tree, vif_name) == NULL ? false : true;
+}
+
+bool
+ow_conf_is_settled(void)
+{
+    if (osw_drv_work_is_settled() == false) return false;
+    if (osw_confsync_is_settled(&g_ow_conf.confsync) == false) return false;
+    return true;
+}
+
+static void
+ow_conf_init_priv(struct ow_conf *self)
+{
+    osw_conf_register_mutator(&self->conf_mutator);
+    osw_conf_register_observer(&self->conf_observer);
+    osw_state_register_observer(&self->state_observer);
+    osw_confsync_init(&self->confsync);
+    ev_timer_init(&self->work, ow_conf_work_cb, 0, 0);
+}
+
+void
+ow_conf_init(void)
+{
+    static bool initialized;
+    if (initialized == true) return;
+    ow_conf_init_priv(&g_ow_conf);
+    initialized = true;
+}
+
+static void
+ow_conf_ut_ev_idle_cb(EV_P_ ev_idle *arg, int events)
+{
+    ev_idle_stop(EV_A_ arg);
+}
+
+static void
+ow_conf_ut_run(void)
+{
+    struct ev_idle idle;
+    ev_idle_init(&idle, ow_conf_ut_ev_idle_cb);
+    ev_idle_start(EV_DEFAULT_ &idle);
+    ev_run(EV_DEFAULT_ 0);
+    assert(ow_conf_is_settled() == true);
+}
+
+static void
+ow_conf_ut_phy_enabled_op_request_config_cb(struct osw_drv *drv,
+                                            struct osw_drv_conf *conf)
+{
+    struct osw_drv_dummy *dummy = osw_drv_get_priv(drv);
+    size_t i;
+
+    LOGI("ow: conf: ut: config");
+    for (i = 0; i < conf->n_phy_list; i++) {
+        struct osw_drv_phy_config *phy = &conf->phy_list[i];
+
+        assert(phy->changed == true);
+        LOGI("ow: conf: ut: config: %s: changing enabled: %d\n",
+             phy->phy_name, phy->enabled);
+
+        osw_drv_dummy_set_phy(dummy,
+                              phy->phy_name,
+                              (struct osw_drv_phy_state []){{
+                                  .exists = true,
+                                  .enabled = phy->enabled,
+                              }});
+    }
+
+    osw_drv_conf_free(conf);
+}
+
+static void
+ow_conf_ut_phy_enabled_cb(void *data)
+{
+    struct osw_drv_dummy dummy = {
+        .name = "phy_enabled",
+        .request_config_fn = ow_conf_ut_phy_enabled_op_request_config_cb,
+    };
+    bool enabled = true;
+    const char *phy_name = "phy1";
+
+    osw_init();
+    osw_drv_dummy_init(&dummy);
+    ow_conf_init();
+    ow_conf_ut_run();
+
+    osw_drv_dummy_set_phy(&dummy, phy_name, (struct osw_drv_phy_state []){{
+            .exists = true,
+            .enabled = true,
+            }});
+
+    ow_conf_ut_run();
+    assert(osw_state_phy_lookup(phy_name)->drv_state->enabled == true);
+
+    LOGI("ow: conf: ut: phy_enabled: disabling, expecting true->false");
+    enabled = false; ow_conf_phy_set_enabled(phy_name, &enabled);
+    ow_conf_ut_run();
+    assert(ow_conf_phy_get(&g_ow_conf, phy_name) != NULL);
+    assert(ow_conf_phy_get(&g_ow_conf, phy_name)->enabled != NULL);
+    assert(*ow_conf_phy_get(&g_ow_conf, phy_name)->enabled == enabled);
+    assert(osw_state_phy_lookup(phy_name)->drv_state->enabled == enabled);
+
+    LOGI("ow: conf: ut: phy_enabled: enabling, expecting false->true");
+    enabled = true; ow_conf_phy_set_enabled(phy_name, &enabled);
+    ow_conf_ut_run();
+    assert(ow_conf_phy_get(&g_ow_conf, phy_name) != NULL);
+    assert(ow_conf_phy_get(&g_ow_conf, phy_name)->enabled != NULL);
+    assert(*ow_conf_phy_get(&g_ow_conf, phy_name)->enabled == enabled);
+    assert(osw_state_phy_lookup(phy_name)->drv_state->enabled == enabled);
+
+    LOGI("ow: conf: ut: phy_enabled: blipping, expecting no action");
+    enabled = false; ow_conf_phy_set_enabled(phy_name, &enabled);
+    enabled = true; ow_conf_phy_set_enabled(phy_name, &enabled);
+    ow_conf_ut_run();
+    assert(ow_conf_phy_get(&g_ow_conf, phy_name) != NULL);
+    assert(ow_conf_phy_get(&g_ow_conf, phy_name)->enabled != NULL);
+    assert(*ow_conf_phy_get(&g_ow_conf, phy_name)->enabled == enabled);
+    assert(osw_state_phy_lookup(phy_name)->drv_state->enabled == enabled);
+
+    LOGI("ow: conf: ut: phy_enabled: changing other attr, expecting no action");
+    osw_drv_dummy_set_phy(&dummy, phy_name, (struct osw_drv_phy_state []){{
+            .exists = true,
+            .enabled = enabled,
+            .tx_chainmask = 0x1,
+            }});
+    ow_conf_ut_run();
+    assert(ow_conf_phy_get(&g_ow_conf, phy_name) != NULL);
+    assert(ow_conf_phy_get(&g_ow_conf, phy_name)->enabled != NULL);
+    assert(ow_conf_phy_get(&g_ow_conf, phy_name)->tx_chainmask == NULL);
+    assert(*ow_conf_phy_get(&g_ow_conf, phy_name)->enabled == enabled);
+    assert(osw_state_phy_lookup(phy_name)->drv_state->enabled == enabled);
+    assert(osw_state_phy_lookup(phy_name)->drv_state->tx_chainmask == 0x1);
+
+    LOGI("ow: conf: ut: phy_enabled: changing other attr again, expecting no action");
+    osw_drv_dummy_set_phy(&dummy, phy_name, (struct osw_drv_phy_state []){{
+            .exists = true,
+            .enabled = enabled,
+            .tx_chainmask = 0x2,
+            }});
+    ow_conf_ut_run();
+    assert(ow_conf_phy_get(&g_ow_conf, phy_name) != NULL);
+    assert(ow_conf_phy_get(&g_ow_conf, phy_name)->enabled != NULL);
+    assert(ow_conf_phy_get(&g_ow_conf, phy_name)->tx_chainmask == NULL);
+    assert(*ow_conf_phy_get(&g_ow_conf, phy_name)->enabled == enabled);
+    assert(osw_state_phy_lookup(phy_name)->drv_state->enabled == enabled);
+    assert(osw_state_phy_lookup(phy_name)->drv_state->tx_chainmask == 0x2);
+
+    LOGI("ow: conf: ut: phy_enabled: changing state, expecting corrective action, false->true");
+    osw_drv_dummy_set_phy(&dummy, phy_name, (struct osw_drv_phy_state []){{
+            .exists = true,
+            .enabled = false,
+            }});
+    ow_conf_ut_run();
+}
+
+static void
+ow_conf_ut_vif_enabled_op_request_config_cb(struct osw_drv *drv,
+                                            struct osw_drv_conf *conf)
+{
+    struct osw_drv_dummy *dummy = osw_drv_get_priv(drv);
+    size_t i;
+
+    LOGI("ow: conf: ut: config");
+    for (i = 0; i < conf->n_phy_list; i++) {
+        struct osw_drv_phy_config *phy = &conf->phy_list[i];
+        size_t j;
+
+        assert(phy->changed == false);
+        LOGI("ow: conf: ut: config: %s: changing enabled: %d\n",
+             phy->phy_name, phy->enabled);
+
+        for (j = 0; j < phy->vif_list.count; j++) {
+            struct osw_drv_vif_config *vif = &phy->vif_list.list[j];
+
+            assert(vif->enabled_changed);
+            LOGI("ow: conf: ut: config: %s/%s: changing enabled: %d\n",
+                 phy->phy_name, vif->vif_name, vif->enabled);
+
+            osw_drv_dummy_set_vif(dummy,
+                                  phy->phy_name,
+                                  vif->vif_name,
+                                  (struct osw_drv_vif_state []){{
+                                      .exists = true,
+                                      .vif_type = vif->vif_type,
+                                      .enabled = vif->enabled,
+                                  }});
+        }
+    }
+
+    osw_drv_conf_free(conf);
+}
+
+static void
+ow_conf_ut_vif_enabled_cb(void *data)
+{
+    struct osw_drv_dummy dummy = {
+        .name = "vif_enabled",
+        .request_config_fn = ow_conf_ut_vif_enabled_op_request_config_cb,
+    };
+    bool enabled = true;
+    const char *phy_name = "phy1";
+    const char *vif_name = "vif1";
+
+    osw_init();
+    osw_drv_dummy_init(&dummy);
+    ow_conf_init();
+    ow_conf_ut_run();
+
+    osw_drv_dummy_set_phy(&dummy, phy_name, (struct osw_drv_phy_state []){{
+            .exists = true,
+            .enabled = true,
+            }});
+
+    osw_drv_dummy_set_vif(&dummy, phy_name, vif_name, (struct osw_drv_vif_state []){{
+            .exists = true,
+            .vif_type = OSW_VIF_AP,
+            .enabled = true,
+            }});
+
+    ow_conf_ut_run();
+    assert(osw_state_vif_lookup(phy_name, vif_name)->drv_state->enabled == true);
+
+    ow_conf_vif_set_phy_name(vif_name, phy_name);
+    enabled = false; ow_conf_vif_set_enabled(vif_name, &enabled);
+    ow_conf_ut_run();
+    assert(ow_conf_vif_get(&g_ow_conf, vif_name) != NULL);
+    assert(ow_conf_vif_get(&g_ow_conf, vif_name)->enabled != NULL);
+    assert(*ow_conf_vif_get(&g_ow_conf, vif_name)->enabled == enabled);
+    assert(osw_state_vif_lookup(phy_name, vif_name)->drv_state->enabled == enabled);
+
+    enabled = true; ow_conf_vif_set_enabled(vif_name, &enabled);
+    ow_conf_ut_run();
+    assert(ow_conf_vif_get(&g_ow_conf, vif_name) != NULL);
+    assert(ow_conf_vif_get(&g_ow_conf, vif_name)->enabled != NULL);
+    assert(*ow_conf_vif_get(&g_ow_conf, vif_name)->enabled == enabled);
+    assert(osw_state_vif_lookup(phy_name, vif_name)->drv_state->enabled == enabled);
+
+    enabled = false; ow_conf_vif_set_enabled(vif_name, &enabled);
+    enabled = true; ow_conf_vif_set_enabled(vif_name, &enabled);
+    ow_conf_ut_run();
+    assert(ow_conf_vif_get(&g_ow_conf, vif_name) != NULL);
+    assert(ow_conf_vif_get(&g_ow_conf, vif_name)->enabled != NULL);
+    assert(*ow_conf_vif_get(&g_ow_conf, vif_name)->enabled == enabled);
+    assert(osw_state_vif_lookup(phy_name, vif_name)->drv_state->enabled == enabled);
+}
+
+static void
+ow_conf_ut_is_set_cb(void *arg)
+{
+    const char *phy_name = "phy1";
+
+    assert(ow_conf_phy_is_set(phy_name) == false);
+    assert(ow_conf_phy_get_enabled(phy_name) == NULL);
+    assert(ow_conf_phy_is_set(phy_name) == false);
+}
+
+struct ow_conf_ut_obs_arg {
+    struct ow_conf_observer obs;
+    int n_agitated;
+    int n_settled;
+};
+
+static void
+ow_conf_ut_obs_agitated_cb(struct ow_conf_observer *obs)
+{
+    struct ow_conf_ut_obs_arg *arg = container_of(obs, struct ow_conf_ut_obs_arg, obs);
+    arg->n_agitated++;
+}
+
+static void
+ow_conf_ut_obs_settled_cb(struct ow_conf_observer *obs)
+{
+    struct ow_conf_ut_obs_arg *arg = container_of(obs, struct ow_conf_ut_obs_arg, obs);
+    arg->n_settled++;
+}
+
+static void
+ow_conf_ut_obs_cb(void *arg)
+{
+    struct ow_conf *c = &g_ow_conf;
+    struct ow_conf_ut_obs_arg ctx = {
+        .obs = {
+            .agitated_fn = ow_conf_ut_obs_agitated_cb,
+            .settled_fn = ow_conf_ut_obs_settled_cb,
+        },
+    };
+
+    ow_conf_register_observer(&ctx.obs);
+
+    LOGI("settled");
+    assert(ctx.n_settled == 0);
+    ow_conf_settled_cb(&c->confsync);
+    assert(ctx.n_settled == 0);
+    ow_conf_confsync_idle_cb(&c->confsync);
+    assert(ctx.n_settled == 1);
+
+    LOGI("agitated");
+    assert(ctx.n_agitated == 0);
+    ow_conf_agitated_cb(&c->confsync);
+    assert(ctx.n_agitated == 1);
+    ow_conf_settled_cb(&c->confsync);
+    ow_conf_confsync_busy_cb(&c->confsync);
+    assert(ctx.n_settled == 2);
+    assert(ctx.n_agitated == 2);
+
+    LOGI("null deref");
+    memset(&ctx.obs, 0, sizeof(ctx.obs));
+    ow_conf_agitated_cb(&c->confsync);
+    ow_conf_settled_cb(&c->confsync);
+
+    /* FIXME: Test other callbacks. Before that can be done
+     * ow_conf_init() needs to be split into _init and
+     * _start, where _start actually attaches to modules to
+     * one another and sets up resources like linked lists
+     * between them, opens sockets, schedules libev objects,
+     * etc.
+     */
+}
+
+static void
+ow_conf_ut_module_init(void *data)
+{
+    osw_ut_register("ow_conf_ut_phy_enabled", ow_conf_ut_phy_enabled_cb, NULL);
+    osw_ut_register("ow_conf_ut_vif_enabled", ow_conf_ut_vif_enabled_cb, NULL);
+    osw_ut_register("ow_conf_ut_is_set", ow_conf_ut_is_set_cb, NULL);
+    osw_ut_register("ow_conf_ut_obs", ow_conf_ut_obs_cb, NULL);
+}
+
+static void
+ow_conf_ut_module_fini(void *data)
+{
+}
+
+MODULE(ow_conf_ut_module, ow_conf_ut_module_init, ow_conf_ut_module_fini);
+
+#define DEFINE_PHY_FIELD_UT(field, type, eq, ...) \
+    static void \
+    ow_conf_ut_field_phy_##field##_cb(void *data) { \
+        assert(ow_conf_phy_get_##field("phy1") == NULL); \
+        \
+        const type values[] = { __VA_ARGS__ }; \
+        size_t i; \
+        for (i = 0; i < ARRAY_SIZE(values); i++) { \
+           ow_conf_phy_set_##field("phy1", &values[i]); \
+           assert(ow_conf_phy_get_##field("phy1") != NULL); \
+           assert(eq(ow_conf_phy_get_##field("phy1"), &values[i])); \
+        } \
+        ow_conf_phy_set_##field("phy1", NULL); \
+        assert(ow_conf_phy_get_##field("phy1") == NULL); \
+    } \
+    static void \
+    ow_conf_ut_field_phy_##field##_module_init(void *data) { \
+        osw_ut_register("ow_conf_ut_field_phy_" #field, \
+                        ow_conf_ut_field_phy_##field##_cb, NULL); \
+    } \
+    static void \
+    ow_conf_ut_field_phy_##field##_module_fini(void *data) { \
+    } \
+    MODULE(ow_conf_ut_field_phy_##field##_module, \
+           ow_conf_ut_field_phy_##field##_module_init, \
+           ow_conf_ut_field_phy_##field##_module_fini)
+
+#define DEFINE_VIF_FIELD_UT(field, type, eq, ...) \
+    static void \
+    ow_conf_ut_field_vif_##field##_cb(void *data) { \
+        ow_conf_init(); \
+        assert(ow_conf_vif_get_##field("vif1") == NULL); \
+        \
+        const type values[] = { __VA_ARGS__ }; \
+        size_t i; \
+        for (i = 0; i < ARRAY_SIZE(values); i++) { \
+           ow_conf_vif_set_##field("vif1", &values[i]); \
+           assert(ow_conf_vif_get_##field("vif1") != NULL); \
+           assert(eq(ow_conf_vif_get_##field("vif1"), &values[i])); \
+        } \
+        ow_conf_vif_set_##field("vif1", NULL); \
+        assert(ow_conf_vif_get_##field("vif1") == NULL); \
+    } \
+    static void \
+    ow_conf_ut_field_vif_##field##_module_init(void *data) { \
+        osw_ut_register("ow_conf_ut_field_vif_" #field, \
+                        ow_conf_ut_field_vif_##field##_cb, NULL); \
+    } \
+    static void \
+    ow_conf_ut_field_vif_##field##_module_fini(void *data) { \
+    } \
+    MODULE(ow_conf_ut_field_vif_##field##_module, \
+           ow_conf_ut_field_vif_##field##_module_init, \
+           ow_conf_ut_field_vif_##field##_module_fini)
+
+
+#define FIELD_EQ(x, y) (*(x) == *(y))
+#define FIELD_MEM_EQ(x, y) (memcmp(x, y, sizeof(*(x))) == 0)
+#define FIELD_STR_EQ(x, y) (strcmp(x, y) == 0)
+
+DEFINE_PHY_FIELD_UT(enabled, bool, FIELD_EQ, true, false, true);
+DEFINE_PHY_FIELD_UT(tx_chainmask, int, FIELD_EQ, 1, 2, 3, 1, 0);
+DEFINE_VIF_FIELD_UT(enabled, bool, FIELD_EQ, true, false, true);
+DEFINE_VIF_FIELD_UT(type, enum osw_vif_type, FIELD_EQ, OSW_VIF_UNDEFINED, OSW_VIF_AP, OSW_VIF_AP_VLAN, OSW_VIF_STA);
+DEFINE_VIF_FIELD_UT(ap_channel, struct osw_channel, FIELD_MEM_EQ,
+                    { .control_freq_mhz = 5180, .width = OSW_CHANNEL_40MHZ, .center_freq0_mhz = 5190 },
+                    { .control_freq_mhz = 5220, .width = OSW_CHANNEL_80MHZ, .center_freq0_mhz = 5210 },
+                    { .control_freq_mhz = 5220, .width = OSW_CHANNEL_160MHZ, .center_freq0_mhz = 5250 },
+                    { .control_freq_mhz = 2412, .width = OSW_CHANNEL_20MHZ, .center_freq0_mhz = 2412 });
+DEFINE_VIF_FIELD_UT(ap_ssid, struct osw_ssid, FIELD_MEM_EQ, { .buf = "ssid1", .len = 5 }, { .buf = "ssid22", .len = 6 });
+DEFINE_VIF_FIELD_UT(ap_bridge_if_name, struct osw_ifname, FIELD_MEM_EQ, { .buf = "br0" }, { .buf = "br1" });
+DEFINE_VIF_FIELD_UT(ap_ssid_hidden, bool, FIELD_EQ, true, false, true);
+DEFINE_VIF_FIELD_UT(ap_group_rekey_seconds, int, FIELD_EQ, 1, 2, 60, 3600, 0);
+DEFINE_VIF_FIELD_UT(ap_ft_mobility_domain, int, FIELD_EQ, 0x400, 0x1600, 0x1337);
+DEFINE_VIF_FIELD_UT(ap_pmf, enum osw_pmf, FIELD_EQ, OSW_PMF_DISABLED, OSW_PMF_OPTIONAL, OSW_PMF_REQUIRED);
Index: device-core/src/lib/ow/src/ow_conf.h
===================================================================
--- /dev/null
+++ device-core/src/lib/ow/src/ow_conf.h
@@ -0,0 +1,123 @@
+#ifndef OW_CONF_H
+#define OW_CONF_H
+
+/**
+ * @file ow_conf.h
+ *
+ * @brief
+ * Defines API to access the OneWifi configuration database.
+ *
+ * @description
+ * The configuration database is used to separate southbound
+ * interface with OneWifi core.
+ *
+ * Each attribute is within an object group (phy, vif, ...) identified with a
+ * key (phy_name, vif_name, ...). Each attribute can be in a state of being
+ * defined or undefined. This eventually is translated to whether an attribute
+ * will override the system state or not, when merging/applying configuration.
+ *
+ * Group relations are weak references - an attribute referencing other group
+ * object's key, eg. ow_conf_vif_set_phy_name() will define phy-vif hierarchy.
+ *
+ * TODO:
+ * - get API (not necessary for now)
+ */
+
+#include <osw_types.h>
+#include <ds_dlist.h>
+
+struct ow_conf_observer;
+
+typedef void ow_conf_agitated_fn_t(struct ow_conf_observer *obs);
+typedef void ow_conf_settled_fn_t(struct ow_conf_observer *obs);
+typedef void ow_conf_phy_changed_fn_t(struct ow_conf_observer *obs,
+                                      const char *phy_name);
+typedef void ow_conf_vif_changed_fn_t(struct ow_conf_observer *obs,
+                                      const char *vif_name);
+
+struct ow_conf_observer {
+    /* public */
+    const char *name;
+    ow_conf_agitated_fn_t *const agitated_fn;
+    ow_conf_settled_fn_t *const settled_fn;
+    ow_conf_phy_changed_fn_t *const phy_changed_fn;
+    ow_conf_vif_changed_fn_t *const vif_changed_fn;
+
+    /* private */
+    struct ds_dlist_node node;
+};
+
+void ow_conf_register_observer(struct ow_conf_observer *obs);
+
+void ow_conf_init(void);
+bool ow_conf_is_settled(void);
+
+void ow_conf_phy_unset(const char *phy_name);
+void ow_conf_phy_set_enabled(const char *phy_name, const bool *enabled);
+void ow_conf_phy_set_tx_chainmask(const char *phy_name, const int *tx_chainmask);
+void ow_conf_phy_set_ap_ht_enabled(const char *phy_name, const bool *enabled);
+void ow_conf_phy_set_ap_vht_enabled(const char *phy_name, const bool *enabled);
+void ow_conf_phy_set_ap_he_enabled(const char *phy_name, const bool *enabled);
+void ow_conf_phy_set_ap_beacon_interval_tu(const char *phy_name, const int *tu);
+void ow_conf_phy_set_ap_channel(const char *phy_name, const struct osw_channel *channel);
+
+bool ow_conf_phy_is_set(const char *phy_name);
+const bool *ow_conf_phy_get_enabled(const char *phy_name);
+const int *ow_conf_phy_get_tx_chainmask(const char *phy_name);
+
+void ow_conf_vif_unset(const char *vif_name);
+void ow_conf_vif_set_phy_name(const char *vif_name, const char *phy_name);
+void ow_conf_vif_set_type(const char *vif_name, const enum osw_vif_type *type);
+void ow_conf_vif_set_enabled(const char *vif_name, const bool *enabled);
+void ow_conf_vif_set_ap_channel(const char *vif_name, const struct osw_channel *channel);
+void ow_conf_vif_set_ap_ssid(const char *vif_name, const struct osw_ssid *ssid);
+void ow_conf_vif_set_ap_bridge_if_name(const char *vif_name, const struct osw_ifname *bridge_if_name);
+void ow_conf_vif_set_ap_ssid_hidden(const char *vif_name, const bool *hidden);
+void ow_conf_vif_set_ap_isolated(const char *vif_name, const bool *isolated);
+void ow_conf_vif_set_ap_ht_enabled(const char *vif_name, const bool *ht_enabled);
+void ow_conf_vif_set_ap_vht_enabled(const char *vif_name, const bool *vht_enabled);
+void ow_conf_vif_set_ap_he_enabled(const char *vif_name, const bool *he_enabled);
+void ow_conf_vif_set_ap_wpa(const char *vif_name, const bool *wpa_enabled);
+void ow_conf_vif_set_ap_rsn(const char *vif_name, const bool *rsn_enabled);
+void ow_conf_vif_set_ap_pairwise_tkip(const char *vif_name, const bool *tkip_enabled);
+void ow_conf_vif_set_ap_pairwise_ccmp(const char *vif_name, const bool *ccmp_enabled);
+void ow_conf_vif_set_ap_akm_psk(const char *vif_name, const bool *psk_enabled);
+void ow_conf_vif_set_ap_akm_sae(const char *vif_name, const bool *sae_enabled);
+void ow_conf_vif_set_ap_akm_ft_psk(const char *vif_name, const bool *ft_psk_enabled);
+void ow_conf_vif_set_ap_akm_ft_sae(const char *vif_name, const bool *ft_sae_enabled);
+void ow_conf_vif_set_ap_pmf(const char *vif_name, const enum osw_pmf *pmf);
+void ow_conf_vif_set_ap_group_rekey_seconds(const char *vif_name, const int *seconds);
+void ow_conf_vif_set_ap_ft_mobility_domain(const char *vif_name, const int *mdid);
+void ow_conf_vif_set_ap_beacon_interval_tu(const char *vif_name, const int *tu);
+void ow_conf_vif_set_ap_acl_policy(const char *vif_name, const enum osw_acl_policy *policy);
+void ow_conf_vif_set_ap_wps(const char *vif_name, const bool *wps_enabled);
+void ow_conf_vif_set_ap_wmm(const char *vif_name, const bool *wmm_enabled);
+void ow_conf_vif_set_ap_wmm_uapsd(const char *vif_name, const bool *wmm_uapsd_enabled);
+void ow_conf_vif_set_ap_wnm_bss_trans(const char *vif_name, const bool *wnm_bss_trans_enabled);
+void ow_conf_vif_set_ap_rrm_neighbor_report(const char *vif_name, const bool *rmm_neighbor_report_enabled);
+void ow_conf_vif_set_ap_mcast2ucast(const char *vif_name, const bool *mcast2ucast_enabled);
+
+void ow_conf_vif_set_ap_psk(const char *vif_name, int key_id, const char *str);
+void ow_conf_vif_add_ap_acl(const char *vif_name, const struct osw_hwaddr *addr);
+void ow_conf_vif_del_ap_acl(const char *vif_name, const struct osw_hwaddr *addr);
+void ow_conf_vif_flush_ap_psk(const char *vif_name);
+void ow_conf_vif_flush_ap_acl(const char *vif_name);
+
+bool ow_conf_vif_is_set(const char *vif_name);
+const char *ow_conf_vif_get_phy_name(const char *vif_name);
+const bool *ow_conf_vif_get_enabled(const char *vif_name);
+const enum osw_acl_policy *ow_conf_vif_get_ap_acl_policy(const char *vif_name);
+const struct osw_ssid *ow_conf_vif_get_ap_ssid(const char *vif_name);
+const bool *ow_conf_vif_get_ap_wpa(const char *vif_name);
+const bool *ow_conf_vif_get_ap_rsn(const char *vif_name);
+const bool *ow_conf_vif_get_ap_pairwise_tkip(const char *vif_name);
+const bool *ow_conf_vif_get_ap_pairwise_ccmp(const char *vif_name);
+const bool *ow_conf_vif_get_ap_akm_psk(const char *vif_name);
+const bool *ow_conf_vif_get_ap_akm_sae(const char *vif_name);
+const bool *ow_conf_vif_get_ap_akm_ft_psk(const char *vif_name);
+const bool *ow_conf_vif_get_ap_akm_ft_sae(const char *vif_name);
+const enum osw_pmf *ow_conf_vif_get_ap_pmf(const char *vif_name);
+const char *ow_conf_vif_get_ap_psk(const char *vif_name, int key_id);
+bool ow_conf_vif_has_ap_acl(const char *vif_name, const struct osw_hwaddr *addr);
+
+#endif /* OW_CONF_H */
Index: device-core/src/lib/ow/src/ow_conf_barrier.c
===================================================================
--- /dev/null
+++ device-core/src/lib/ow/src/ow_conf_barrier.c
@@ -0,0 +1,266 @@
+/* libc */
+#include <time.h> /* clock_gettime() */
+#include <pthread.h> /* pthread_* */
+#include <errno.h> /* EAGAIN */
+#include <unistd.h> /* usleep() */
+
+/* 3rd party */
+#include <ev.h> /* ev_* */
+
+/* opensync */
+#include <module.h> /* MODULE() */
+#include <ds_dlist.h> /* ds_dlist_* */
+#include <log.h> /* LOG*() */
+#include <const.h> /* container_of() */
+#include <osw_ut.h> /* osw_ut_register() */
+
+/* onewifi */
+#include "ow_conf.h" /* ow_conf_register_observer() */
+
+struct ow_conf_barrier_waiter {
+    struct ds_dlist_node node;
+    pthread_cond_t cond;
+    pthread_condattr_t attr;
+    bool settled;
+};
+
+struct ow_conf_barrier {
+    struct ow_conf_observer conf_obs;
+    struct ds_dlist waiters;
+    ev_idle idle;
+    ev_async work;
+    pthread_mutex_t lock;
+    bool settled;
+};
+
+static size_t
+ow_conf_barrier_waiters_count(struct ow_conf_barrier *b)
+{
+    struct ow_conf_barrier_waiter *w;
+    size_t n = 0;
+
+    pthread_mutex_lock(&b->lock);
+    ds_dlist_foreach(&b->waiters, w)
+        n++;
+    pthread_mutex_unlock(&b->lock);
+
+    return n;
+}
+
+static void
+ow_conf_barrier_waiters_notify(struct ow_conf_barrier *b)
+{
+    struct ow_conf_barrier_waiter *w;
+
+    pthread_mutex_lock(&b->lock);
+    ds_dlist_foreach(&b->waiters, w) {
+        LOGD("ow: conf barrier: notifying: %p", w);
+        w->settled = true;
+        WARN_ON(pthread_cond_signal(&w->cond) != 0);
+    }
+    pthread_mutex_unlock(&b->lock);
+}
+
+static void
+ow_conf_barrier_agitated_cb(struct ow_conf_observer *obs)
+{
+    struct ow_conf_barrier *b = container_of(obs, struct ow_conf_barrier, conf_obs);
+    b->settled = false;
+}
+
+static void
+ow_conf_barrier_settled_cb(struct ow_conf_observer *obs)
+{
+    struct ow_conf_barrier *b = container_of(obs, struct ow_conf_barrier, conf_obs);
+    b->settled = true;
+    ow_conf_barrier_waiters_notify(b);
+}
+
+static void
+ow_conf_barrier_idle_cb(EV_P_ ev_idle *arg, int events)
+{
+    struct ow_conf_barrier *b = container_of(arg, struct ow_conf_barrier, idle);
+    ev_idle_stop(EV_A_ arg);
+    if (b->settled == true)
+        ow_conf_barrier_waiters_notify(b);
+}
+
+static void
+ow_conf_barrier_work_cb(EV_P_ ev_async *arg, int events)
+{
+    struct ow_conf_barrier *b = container_of(arg, struct ow_conf_barrier, work);
+    ev_idle_start(EV_A_ &b->idle);
+}
+
+static void
+ow_conf_barrier_init(struct ow_conf_barrier *b)
+{
+    ev_idle_init(&b->idle, ow_conf_barrier_idle_cb);
+    ev_async_init(&b->work, ow_conf_barrier_work_cb);
+}
+
+static void
+ow_conf_barrier_start(struct ow_conf_barrier *b)
+{
+    ow_conf_register_observer(&b->conf_obs);
+    ev_async_start(EV_DEFAULT_ &b->work);
+    ev_unref(EV_DEFAULT);
+}
+
+static void
+ow_conf_barrier_ts_add_msec(struct timespec *ts, int msec)
+{
+    int sec = (msec / 1000);
+    int nsec = (msec % 1000) * 1000000;
+    ts->tv_sec += sec;
+    ts->tv_nsec += nsec;
+    if (ts->tv_nsec >= 1000000000) {
+        ts->tv_sec += 1;
+        ts->tv_nsec %= 1000000000;
+    }
+}
+
+static int
+ow_conf_barrier_wait_priv(struct ow_conf_barrier *b, int timeout_msec)
+{
+    struct ow_conf_barrier_waiter w = {
+        .cond = PTHREAD_COND_INITIALIZER,
+    };
+    if (WARN_ON(pthread_condattr_init(&w.attr) != 0))
+        goto out;
+    if (WARN_ON(pthread_condattr_setclock(&w.attr, CLOCK_MONOTONIC) != 0))
+        goto out_condattr;
+    if (WARN_ON(pthread_cond_init(&w.cond, &w.attr) != 0))
+        goto out_condattr;
+
+    LOGD("ow: conf barrier: waiting: %p", &w);
+
+    struct timespec ts;
+    clock_gettime(CLOCK_MONOTONIC, &ts);
+    ow_conf_barrier_ts_add_msec(&ts, timeout_msec);
+
+    pthread_mutex_lock(&b->lock);
+    ds_dlist_insert_tail(&b->waiters, &w);
+    ev_async_send(EV_DEFAULT_ &b->work);
+    while (w.settled == false) {
+        int err = pthread_cond_timedwait(&w.cond, &b->lock, &ts);
+        LOGD("ow: conf barrier: %p: timedwait: %d", &w, err);
+        if (err != 0) break;
+    }
+    LOGD("ow: conf barrier: %p: settled: %d", &w, w.settled);
+    ds_dlist_remove(&b->waiters, &w);
+    pthread_mutex_unlock(&b->lock);
+
+out_condattr:
+    pthread_condattr_destroy(&w.attr);
+out:
+    LOGD("ow: conf barrier: %p: done", &w);
+    /* No need for mutex lock here. Waiter is no longer on
+     * barrier list so it can't be modified.
+     */
+    return w.settled == true ? 0 : EAGAIN;
+}
+
+static struct ow_conf_barrier g_ow_conf_barrier = {
+    .conf_obs = {
+        .name = __FILE__,
+        .agitated_fn = ow_conf_barrier_agitated_cb,
+        .settled_fn = ow_conf_barrier_settled_cb,
+    },
+    .waiters = DS_DLIST_INIT(struct ow_conf_barrier_waiter, node),
+    .lock = PTHREAD_MUTEX_INITIALIZER,
+    .settled = false,
+};
+
+int
+ow_conf_barrier_wait(int timeout_msec)
+{
+    return ow_conf_barrier_wait_priv(&g_ow_conf_barrier, timeout_msec);
+}
+
+struct ow_conf_barrier_ut_t_arg {
+    int usleep_before;
+    int barrier_wait;
+    int expected_err;
+};
+
+static void *
+ow_conf_barrier_ut_t_cb(void *data)
+{
+    struct ow_conf_barrier_ut_t_arg *arg = data;
+    LOGI("%s: %p: usleeping %d", __func__, arg, arg->usleep_before);
+    usleep(arg->usleep_before);
+    LOGI("%s: %p: waiting %d", __func__, arg, arg->barrier_wait);
+    assert(ow_conf_barrier_wait(arg->barrier_wait) == arg->expected_err);
+    LOGI("%s: %p: done", __func__, arg);
+    return NULL;
+}
+
+static void
+ow_conf_barrier_ut_cb(void *data)
+{
+    struct ow_conf_barrier *b = &g_ow_conf_barrier;
+    struct ow_conf_barrier_ut_t_arg a1 = { 0, 100, 0 };
+    struct ow_conf_barrier_ut_t_arg a2 = { 0, 200, 0 };
+    struct ow_conf_barrier_ut_t_arg a3 = { 0, 100, EAGAIN };
+    struct ow_conf_barrier_ut_t_arg a4 = { 0, 100, EAGAIN };
+    struct ow_conf_barrier_ut_t_arg a5 = { 0, 900, 0 };
+    pthread_t t1;
+    pthread_t t2;
+
+    ow_conf_barrier_init(b);
+    assert(b->settled == false);
+
+    /* no timeout */
+    pthread_create(&t1, NULL, ow_conf_barrier_ut_t_cb, &a1);
+    pthread_create(&t2, NULL, ow_conf_barrier_ut_t_cb, &a2);
+    while (ow_conf_barrier_waiters_count(b) != 2) {}
+    ev_run(EV_DEFAULT_ 0);
+    assert(b->settled == false);
+    ow_conf_barrier_settled_cb(&b->conf_obs);
+    while (ow_conf_barrier_waiters_count(b) != 0) {}
+    pthread_join(t1, NULL);
+    pthread_join(t2, NULL);
+
+    /* should timeout */
+    ow_conf_barrier_agitated_cb(&b->conf_obs);
+    pthread_create(&t1, NULL, ow_conf_barrier_ut_t_cb, &a3);
+    while (ow_conf_barrier_waiters_count(b) != 1) {}
+    ev_run(EV_DEFAULT_ 0);
+    assert(b->settled == false);
+    usleep(a3.barrier_wait * 1.5 * 1000);
+    assert(ow_conf_barrier_waiters_count(b) == 0);
+    pthread_join(t1, NULL);
+
+    /* a4 timeout, a5 no timeout */
+    ow_conf_barrier_agitated_cb(&b->conf_obs);
+    pthread_create(&t1, NULL, ow_conf_barrier_ut_t_cb, &a4);
+    pthread_create(&t2, NULL, ow_conf_barrier_ut_t_cb, &a5);
+    while (ow_conf_barrier_waiters_count(b) != 2) {}
+    ev_run(EV_DEFAULT_ 0);
+    assert(b->settled == false);
+    usleep(a4.barrier_wait * 1.5 * 1000);
+    assert(ow_conf_barrier_waiters_count(b) == 1);
+    ow_conf_barrier_settled_cb(&b->conf_obs);
+    while (ow_conf_barrier_waiters_count(b) != 0) {}
+    pthread_join(t1, NULL);
+    pthread_join(t2, NULL);
+}
+
+static void
+ow_conf_barrier_module_init_cb(void *data)
+{
+    struct ow_conf_barrier *b = &g_ow_conf_barrier;
+    ow_conf_barrier_init(b);
+    ow_conf_barrier_start(b);
+    osw_ut_register("ow_conf_barrier_ut", ow_conf_barrier_ut_cb, NULL);
+}
+
+static void
+ow_conf_barrier_module_fini_cb(void *data)
+{
+}
+
+MODULE(ow_conf_barrier_module,
+       ow_conf_barrier_module_init_cb,
+       ow_conf_barrier_module_fini_cb);
Index: device-core/src/lib/ow/src/ow_core.c
===================================================================
--- /dev/null
+++ device-core/src/lib/ow/src/ow_core.c
@@ -0,0 +1,66 @@
+/* libc */
+#include <stdbool.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+/* 3rd party */
+#include <ev.h>
+
+/* opensync */
+#include <target.h>
+#include <module.h>
+#include <log.h>
+#include <os_backtrace.h>
+
+/* osw */
+#include <osw_ut.h>
+#include <osw_thread.h>
+#include <osw.h>
+
+/* onewifi */
+#include "ow_bus.h"
+#include "ow_conf.h"
+
+static log_severity_t
+ow_core_get_log_severity(void)
+{
+    const char *p = getenv("OW_CORE_LOG_SEVERITY");
+    if (p != NULL) {
+        if (strcasecmp(p, "notice") == 0) return LOG_SEVERITY_NOTICE;
+        else if (strcasecmp(p, "info") == 0) return LOG_SEVERITY_INFO;
+        else if (strcasecmp(p, "debug") == 0) return LOG_SEVERITY_DEBUG;
+        else if (strcasecmp(p, "trace") == 0) return LOG_SEVERITY_TRACE;
+        else return atoi(p);
+    }
+    return LOG_SEVERITY_INFO;
+}
+
+void
+ow_core_init(EV_P)
+{
+    backtrace_init();
+    ev_default_loop(EVFLAG_FORKCHECK);
+    target_log_open("OW", 0);
+    log_severity_set(ow_core_get_log_severity());
+    osw_thread_init();
+    module_init();
+    assert(ev_run(EV_A_ EVRUN_ONCE | EVRUN_NOWAIT) == 0);
+}
+
+void
+ow_core_run(EV_P)
+{
+    /* FIXME: This is necessary to avoid mainloop exiting if
+     * there are no apparent action watchers. In some corner
+     * cases (depending on the type of buses) this can yield
+     * 0. To avoid exiting in such cases grab a reference so
+     * the mainloop keeps running.
+     */
+    ev_ref(EV_A);
+
+    osw_init();
+    ow_bus_init();
+    ow_conf_init();
+    ev_run(EV_A_ 0);
+}
Index: device-core/src/lib/ow/src/ow_core_thread.c
===================================================================
--- /dev/null
+++ device-core/src/lib/ow/src/ow_core_thread.c
@@ -0,0 +1,209 @@
+/* libc */
+#include <ev.h>
+#include <pthread.h>
+
+/* opensync */
+#include <ds_dlist.h>
+#include <memutil.h>
+#include <module.h>
+#include <log.h>
+#include <const.h>
+#include <osw_ut.h>
+
+/* onewifi */
+#include <ow_core.h>
+#include <ow_core_thread.h>
+
+struct ow_core_thread {
+    bool started;
+    bool ready;
+    ev_idle idle;
+    ev_async cancel;
+    ev_async call;
+    pthread_t thread;
+    pthread_mutex_t lock;
+    pthread_cond_t cond;
+    struct ds_dlist calls;
+};
+
+struct ow_core_thread_call {
+    struct ds_dlist_node node;
+    ow_core_thread_call_fn_t *fn;
+    void *fn_priv;
+    void *fn_ret;
+    bool done;
+};
+
+static void
+ow_core_thread_idle_cb(EV_P_ ev_idle *arg, int events)
+{
+    struct ow_core_thread *t = container_of(arg, struct ow_core_thread, idle);
+    LOGI("ow: core thread: ready");
+    ev_idle_stop(EV_A_ arg);
+    pthread_mutex_lock(&t->lock);
+    t->ready = true;
+    pthread_cond_signal(&t->cond);
+    pthread_mutex_unlock(&t->lock);
+}
+
+static void
+ow_core_thread_start_ev(EV_P_ struct ow_core_thread *t)
+{
+    ev_idle_start(EV_A_ &t->idle);
+    ev_async_start(EV_A_ &t->cancel);
+    ev_unref(EV_A);
+    ev_async_start(EV_A_ &t->call);
+    ev_unref(EV_A);
+}
+
+static void *
+ow_core_thread_cb(void *arg)
+{
+    struct ow_core_thread *t = arg;
+
+    ow_core_init(EV_DEFAULT);
+    ow_core_thread_start_ev(EV_DEFAULT_ t);
+    LOGI("ow: core thread: running");
+    ow_core_run(EV_DEFAULT);
+    LOGI("ow: core thread: stopped");
+
+    return NULL;
+}
+
+static struct ow_core_thread g_ow_core_thread = {
+    .lock = PTHREAD_MUTEX_INITIALIZER,
+    .cond = PTHREAD_COND_INITIALIZER,
+    .calls = DS_DLIST_INIT(struct ow_core_thread_call, node),
+};
+
+static void
+ow_core_thread_cancel_cb(EV_P_ ev_async *arg, int events)
+{
+    LOGI("ow: core thread: aborting");
+    ev_break(EV_A_ EVBREAK_ALL);
+}
+
+static void
+ow_core_thread_call_work(struct ow_core_thread *t)
+{
+    struct ow_core_thread_call *c;
+    while ((c = ds_dlist_remove_head(&t->calls)) != NULL) {
+        LOGD("ow: core thread: calling %p(%p)", c->fn, c->fn_priv);
+        assert(c->fn != NULL);
+        c->fn_ret = c->fn(c->fn_priv);
+        LOGD("ow: core thread: returned %p", c->fn_ret);
+        c->done = true;
+    }
+    pthread_cond_signal(&t->cond);
+}
+
+static void
+ow_core_thread_call_cb(EV_P_ ev_async *arg, int events)
+{
+    struct ow_core_thread *t = container_of(arg, struct ow_core_thread, call);
+    LOGI("ow: core thread: calling");
+    pthread_mutex_lock(&t->lock);
+    ow_core_thread_call_work(t);
+    pthread_mutex_unlock(&t->lock);
+}
+
+void
+ow_core_thread_start(void)
+{
+    struct ow_core_thread *t = &g_ow_core_thread;
+
+    pthread_mutex_lock(&t->lock);
+    if (WARN_ON(t->started == true))
+        goto unlock;
+
+    ev_async_init(&t->cancel, ow_core_thread_cancel_cb);
+    ev_async_init(&t->call, ow_core_thread_call_cb);
+    ev_idle_init(&t->idle, ow_core_thread_idle_cb);
+
+    if (WARN_ON(pthread_create(&t->thread, NULL, ow_core_thread_cb, t) != 0))
+        goto unlock;
+
+    t->started = true;
+    while (t->ready == false)
+        pthread_cond_wait(&t->cond, &t->lock);
+unlock:
+    pthread_mutex_unlock(&t->lock);
+}
+
+static void
+ow_core_thread_cancel(void)
+{
+    struct ow_core_thread *t = &g_ow_core_thread;
+
+    assert(pthread_mutex_lock(&t->lock) == 0);
+    if (t->started == false)
+        goto unlock;
+    ev_async_send(EV_DEFAULT_ &t->cancel);
+    assert(pthread_join(t->thread, NULL) == 0);
+    t->ready = false;
+    t->started = false;
+unlock:
+    assert(pthread_mutex_unlock(&t->lock) == 0);
+}
+
+void *
+ow_core_thread_call(ow_core_thread_call_fn_t *fn, void *fn_priv)
+{
+    struct ow_core_thread *t = &g_ow_core_thread;
+    struct ow_core_thread_call *c = CALLOC(1, sizeof(*c));
+    void *ret;
+
+    c->fn = fn;
+    c->fn_priv = fn_priv;
+    pthread_mutex_lock(&t->lock);
+    ds_dlist_insert_tail(&t->calls, c);
+    ev_async_send(EV_DEFAULT_ &t->call);
+    while (c->done == false)
+        pthread_cond_wait(&t->cond, &t->lock);
+    pthread_mutex_unlock(&t->lock);
+
+    ret = c->fn_ret;
+    FREE(c);
+    return ret;
+}
+
+static void *
+ow_core_thread_ut_call_1_cb(void *arg)
+{
+    unsigned int *i = arg;
+    LOGI("%s: calling %p", __func__, arg);
+    assert(*i == 0x1337);
+    *i = 0xbeef;
+    LOGI("%s: returning", __func__);
+    return arg;
+}
+
+static void
+ow_core_thread_ut_cb(void *data)
+{
+    unsigned int arg = 0x1337;
+    LOGI("%s: starting\n", __func__);
+    ow_core_thread_start();
+    LOGI("%s: calling\n", __func__);
+    unsigned int *ret = ow_core_thread_call(ow_core_thread_ut_call_1_cb, &arg);
+    assert(ret == &arg);
+    assert(arg == 0xbeef);
+    LOGI("%s: canceling\n", __func__);
+    ow_core_thread_cancel();
+    LOGI("%s: done\n", __func__);
+}
+
+static void
+ow_core_thread_module_init_cb(void *data)
+{
+    osw_ut_register("ow_core_thread_ut", ow_core_thread_ut_cb, NULL);
+}
+
+static void
+ow_core_thread_module_fini_cb(void *data)
+{
+}
+
+MODULE(ow_core_thread_module,
+       ow_core_thread_module_init_cb,
+       ow_core_thread_module_fini_cb);
Index: device-core/src/lib/ow/src/ow_ovsdb.c
===================================================================
--- /dev/null
+++ device-core/src/lib/ow/src/ow_ovsdb.c
@@ -0,0 +1,2956 @@
+#include <const.h>
+#include <util.h>
+#include <memutil.h>
+#include <osw.h>
+#include <osw_drv_dummy.h>
+#include <osw_state.h>
+#include <osw_ut.h>
+#include "ow_bus.h"
+#include "ow_conf.h"
+#include "ow_ovsdb_ms.h"
+#include "ow_ovsdb_steer.h"
+#include <ovsdb.h>
+#include <ovsdb_table.h>
+#include <ovsdb_cache.h>
+#include <ovsdb_sync.h>
+#include <module.h>
+
+#define OW_OVSDB_RETRY_SECONDS 5.0
+#define OW_OVSDB_VIF_FLAG_SEEN 0x01
+
+/* FIXME: This will likely need legacy workarounds, eg. to not add
+ * objects to State tables unless they are in Config table first,
+ * unless it's AP_VLAN.
+ */
+
+static ovsdb_table_t table_Wifi_Radio_Config;
+static ovsdb_table_t table_Wifi_Radio_State;
+static ovsdb_table_t table_Wifi_VIF_Config;
+static ovsdb_table_t table_Wifi_VIF_State;
+static ovsdb_table_t table_Wifi_Credential_Config;
+static ovsdb_table_t table_Wifi_Associated_Clients;
+static ovsdb_table_t table_Openflow_Tag;
+
+struct ow_ovsdb {
+    struct ds_tree phy_tree;
+    struct ds_tree vif_tree;
+    struct ds_tree sta_tree;
+    struct ow_ovsdb_ms_root ms;
+    struct ds_tree vif_cleanup_tree;
+    struct ow_ovsdb_steer steering;
+};
+
+struct ow_ovsdb_phy {
+    struct ds_tree_node node;
+    struct ow_ovsdb *root;
+    const struct osw_state_phy_info *info;
+    struct schema_Wifi_Radio_Config config;
+    struct schema_Wifi_Radio_State state_cur;
+    struct schema_Wifi_Radio_State state_new;
+    char *phy_name;
+    ev_timer work;
+};
+
+struct ow_ovsdb_vif_cleanup {
+    struct ds_tree_node node;
+    struct ds_tree *root;
+    char *vif_name;
+    char *phy_name;
+    bool configured;
+    bool reported;
+    ev_timer work;
+};
+
+struct ow_ovsdb_vif {
+    struct ds_tree_node node;
+    struct ow_ovsdb *root;
+    const struct osw_state_vif_info *info;
+    struct schema_Wifi_VIF_Config config;
+    struct schema_Wifi_VIF_State state_cur;
+    struct schema_Wifi_VIF_State state_new;
+    char *phy_name;
+    char *vif_name;
+    ev_timer work;
+};
+
+struct ow_ovsdb_sta {
+    struct ds_tree_node node;
+    struct ow_ovsdb *root;
+    const struct osw_state_sta_info *info;
+    struct schema_Wifi_Associated_Clients state_cur;
+    struct schema_Wifi_Associated_Clients state_new;
+    struct osw_hwaddr sta_addr;
+    char *vif_name;
+    char *oftag;
+    time_t connected_at;
+    ev_timer work;
+};
+
+static int
+ow_ovsdb_sta_cmp(const void *a, const void *b)
+{
+    const struct osw_hwaddr *x = a;
+    const struct osw_hwaddr *y = b;
+    return memcmp(x, y, sizeof(*x));
+}
+
+static struct ow_ovsdb g_ow_ovsdb = {
+    .phy_tree = DS_TREE_INIT(ds_str_cmp, struct ow_ovsdb_phy, node),
+    .vif_tree = DS_TREE_INIT(ds_str_cmp, struct ow_ovsdb_vif, node),
+    .sta_tree = DS_TREE_INIT(ow_ovsdb_sta_cmp, struct ow_ovsdb_sta, node),
+    .vif_cleanup_tree = DS_TREE_INIT(ds_str_cmp, struct ow_ovsdb_vif_cleanup, node),
+};
+
+static void
+ow_ovsdb_vif_cleanup_gc(struct ow_ovsdb_vif_cleanup *vif)
+{
+    if (vif->configured == true) return;
+    if (vif->reported == true) return;
+
+    ds_tree_remove(vif->root, vif);
+    FREE(vif->phy_name);
+    FREE(vif->vif_name);
+    FREE(vif);
+}
+
+static void
+ow_ovsdb_vif_cleanup_sched(struct ow_ovsdb_vif_cleanup *vif)
+{
+    ev_timer_stop(EV_DEFAULT_ &vif->work);
+    ev_timer_set(&vif->work, 0, 5);
+    ev_timer_start(EV_DEFAULT_ &vif->work);
+}
+
+static bool
+ow_ovsdb_vif_cleanup_sync(struct ow_ovsdb_vif_cleanup *vif)
+{
+    /* FIXME: This could be using osw_conf_mutator
+     * instead of ow_conf for more independent
+     * operation and to avoid overriding
+     * accidentally ow_ovsdb core logic.
+     */
+
+    if (vif->configured == true) {
+        return true;
+    }
+
+    if (vif->reported == false) {
+        ow_conf_vif_set_enabled(vif->vif_name, NULL);
+        ow_conf_vif_set_phy_name(vif->vif_name, NULL);
+        return true;
+    }
+
+    if (vif->phy_name == NULL) {
+        LOGI("ow: ovsdb: vif: cleanup: %s: cannot force remove "
+             "because phy_name is not known, postponing",
+             vif->vif_name);
+        return true;
+    }
+
+    LOGI("ow: ovsdb: vif: cleanup: %s: force removing", vif->vif_name);
+    bool f = false;
+    ow_conf_vif_set_enabled(vif->vif_name, &f);
+    ow_conf_vif_set_phy_name(vif->vif_name, vif->phy_name);
+
+    return false;
+}
+
+static void
+ow_ovsdb_vif_cleanup_work_cb(EV_P_ ev_timer *arg, int events)
+{
+    struct ow_ovsdb_vif_cleanup *vif = container_of(arg, struct ow_ovsdb_vif_cleanup, work);
+    if (ow_ovsdb_vif_cleanup_sync(vif) == false) return;
+    ev_timer_stop(EV_A_ &vif->work);
+    ow_ovsdb_vif_cleanup_gc(vif);
+}
+
+static struct ow_ovsdb_vif_cleanup *
+ow_ovsdb_vif_cleanup_get(struct ds_tree *tree,
+                         const char *vif_name)
+{
+    struct ow_ovsdb_vif_cleanup *vif = ds_tree_find(tree, vif_name);
+    if (vif == NULL) {
+        vif = CALLOC(1, sizeof(*vif));
+        vif->vif_name = STRDUP(vif_name);
+        vif->root = tree;
+        ev_timer_init(&vif->work, ow_ovsdb_vif_cleanup_work_cb, 0, 0);
+        ds_tree_insert(tree, vif, vif->vif_name);
+    }
+    return vif;
+}
+
+static void
+ow_ovsdb_vif_cleanup_set_phy_name(const char *vif_name,
+                                  const char *phy_name)
+{
+    struct ds_tree *tree = &g_ow_ovsdb.vif_cleanup_tree;
+    struct ow_ovsdb_vif_cleanup *vif = ow_ovsdb_vif_cleanup_get(tree, vif_name);
+    FREE(vif->phy_name);
+    vif->phy_name = STRDUP(phy_name);
+    ow_ovsdb_vif_cleanup_sched(vif);
+}
+
+static void
+ow_ovsdb_vif_cleanup_set_reported(const char *vif_name,
+                                  bool reported)
+{
+    struct ds_tree *tree = &g_ow_ovsdb.vif_cleanup_tree;
+    struct ow_ovsdb_vif_cleanup *vif = ow_ovsdb_vif_cleanup_get(tree, vif_name);
+    vif->reported = reported;
+    ow_ovsdb_vif_cleanup_sched(vif);
+}
+
+static void
+ow_ovsdb_vif_cleanup_set_configured(const char *vif_name,
+                                    bool configured)
+{
+    struct ds_tree *tree = &g_ow_ovsdb.vif_cleanup_tree;
+    struct ow_ovsdb_vif_cleanup *vif = ow_ovsdb_vif_cleanup_get(tree, vif_name);
+    vif->configured = configured;
+    ow_ovsdb_vif_cleanup_sched(vif);
+}
+
+static int
+ow_ovsdb_freq_to_chan(int freq)
+{
+    /* FIXME: This could be moved to a common helper to be shared with other
+     * components. This isn't specific to ow_ovsdb or its tasks. */
+
+    if (freq >= 2412 && freq <= 2472)
+        return (freq - 2407) / 5;
+    else if (freq == 2484)
+        return 14;
+    else if (freq >= 5180 && freq <= 5885)
+        return (freq - 5000) / 5;
+    else if (freq == 5935)
+        return 2;
+    else if (freq >= 5955 && freq <= 7115)
+        return (freq - 5950) / 5;
+
+    //WARN_ON(1);
+    return 0;
+}
+
+static const char *
+ow_ovsdb_width_to_htmode(enum osw_channel_width w)
+{
+    switch (w) {
+        case OSW_CHANNEL_20MHZ: return "HT20";
+        case OSW_CHANNEL_40MHZ: return "HT40";
+        case OSW_CHANNEL_80MHZ: return "HT80";
+        case OSW_CHANNEL_160MHZ: return "HT160";
+        case OSW_CHANNEL_80P80MHZ: return "HT8080";
+    }
+    return NULL;
+}
+
+static const char *
+ow_ovsdb_acl_policy_to_str(enum osw_acl_policy p)
+{
+    switch (p) {
+        case OSW_ACL_NONE: return "none";
+        case OSW_ACL_ALLOW_LIST: return "whitelist";
+        case OSW_ACL_DENY_LIST: return "blacklist";
+    }
+    return NULL;
+}
+
+static enum osw_acl_policy
+ow_ovsdb_acl_policy_from_str(const char *type)
+{
+    if (strcmp(type, "none") == 0) return OSW_ACL_NONE;
+    if (strcmp(type, "whitelist") == 0) return OSW_ACL_ALLOW_LIST;
+    if (strcmp(type, "blacklist") == 0) return OSW_ACL_DENY_LIST;
+    return OSW_ACL_NONE;
+}
+
+/* FIXME: These get helpers could be replaced with
+ * ovsdb_cache lookups to be more efficient  */
+
+static bool
+ow_ovsdb_get_rstate(struct schema_Wifi_Radio_State *rstate,
+                   const char *phy_name)
+{
+    char arg[32];
+    int n;
+    STRSCPY_WARN(arg, phy_name);
+    memset(rstate, 0, sizeof(*rstate));
+    void *p = ovsdb_table_select(&table_Wifi_Radio_State,
+                                 SCHEMA_COLUMN(Wifi_Radio_State, if_name),
+                                 arg,
+                                 &n);
+    if (p) memcpy(rstate, p, sizeof(*rstate));
+    free(p);
+    return p && n == 1;
+}
+
+static bool
+ow_ovsdb_get_vstate(struct schema_Wifi_VIF_State *vstate,
+                   const char *vif_name)
+{
+    char arg[32];
+    int n;
+    STRSCPY_WARN(arg, vif_name);
+    memset(vstate, 0, sizeof(*vstate));
+    void *p = ovsdb_table_select(&table_Wifi_VIF_State,
+                                 SCHEMA_COLUMN(Wifi_VIF_State, if_name),
+                                 arg,
+                                 &n);
+    if (p) memcpy(vstate, p, sizeof(*vstate));
+    free(p);
+    return p && n == 1;
+}
+
+static void
+ow_ovsdb_phystate_get_bcn_int_iter_cb(const struct osw_state_vif_info *info,
+                                      void *priv)
+{
+    int *bcn_int = priv;
+    if (info->drv_state->enabled == false) return;
+    if (info->drv_state->vif_type != OSW_VIF_AP) return;
+    if (*bcn_int == 0) *bcn_int = info->drv_state->u.ap.beacon_interval_tu;
+    if (*bcn_int != info->drv_state->u.ap.beacon_interval_tu) *bcn_int = -1;
+}
+
+static void
+ow_ovsdb_phystate_fill_bcn_int(struct schema_Wifi_Radio_State *schema,
+                               const struct osw_state_phy_info *phy)
+{
+    int bcn_int = 0;
+    osw_state_vif_get_list(ow_ovsdb_phystate_get_bcn_int_iter_cb,
+                           phy->phy_name,
+                           &bcn_int);
+    if (bcn_int > 0)
+        SCHEMA_SET_INT(schema->bcn_int, bcn_int);
+}
+
+static void
+ow_ovsdb_phystate_get_channel_iter_cb(const struct osw_state_vif_info *info,
+                                      void *priv)
+{
+    const struct osw_channel *i = &info->drv_state->u.ap.channel;
+    struct osw_channel *c = priv;
+
+    if (info->drv_state->enabled == false) return;
+    if (info->drv_state->vif_type != OSW_VIF_AP) return;
+    if (c->control_freq_mhz == 0) *c = *i;
+    if (memcmp(c, i, sizeof(*c)) != 0) c->control_freq_mhz = -1;
+}
+
+static void
+ow_ovsdb_phystate_fill_channel(struct schema_Wifi_Radio_State *schema,
+                               const struct osw_state_phy_info *phy)
+{
+    struct osw_channel channel = {0};
+    osw_state_vif_get_list(ow_ovsdb_phystate_get_channel_iter_cb,
+                           phy->phy_name,
+                           &channel);
+    if (channel.control_freq_mhz > 0) {
+        int num = ow_ovsdb_freq_to_chan(channel.control_freq_mhz);
+        if (num > 0) SCHEMA_SET_INT(schema->channel, num);
+
+        const char *ht_mode = ow_ovsdb_width_to_htmode(channel.width);
+        if (ht_mode != NULL) SCHEMA_SET_STR(schema->ht_mode, ht_mode);
+    }
+}
+
+static void
+ow_ovsdb_phystate_get_mode_iter_cb(const struct osw_state_vif_info *info,
+                                   void *priv)
+{
+    const struct osw_ap_mode *i = &info->drv_state->u.ap.mode;
+    struct osw_ap_mode *m = priv;
+
+    if (info->drv_state->enabled == false) return;
+    if (info->drv_state->vif_type != OSW_VIF_AP) return;
+
+    m->ht_enabled |= i->ht_enabled;
+    m->vht_enabled |= i->vht_enabled;
+    m->he_enabled |= i->he_enabled;
+}
+
+static void
+ow_ovsdb_phystate_fill_hwmode(struct schema_Wifi_Radio_State *schema,
+                              const char *freq_band,
+                              const struct osw_state_phy_info *phy)
+{
+    struct osw_ap_mode mode = {0};
+
+    osw_state_vif_get_list(ow_ovsdb_phystate_get_mode_iter_cb,
+                           phy->phy_name,
+                           &mode);
+
+    if (mode.he_enabled)
+        SCHEMA_SET_STR(schema->hw_mode, "11ax");
+    else if (mode.vht_enabled)
+        SCHEMA_SET_STR(schema->hw_mode, "11ac");
+    else if (mode.ht_enabled)
+        SCHEMA_SET_STR(schema->hw_mode, "11n");
+    else if (freq_band != NULL) {
+        if (strcmp(freq_band, "6G") == 0 ||
+                strcmp(freq_band, "5G") == 0 ||
+                strcmp(freq_band, "5GL") == 0 ||
+                strcmp(freq_band, "5GU") == 0)
+            SCHEMA_SET_STR(schema->hw_mode, "11a");
+        else if (strcmp(freq_band, "2.4G") == 0)
+            SCHEMA_SET_STR(schema->hw_mode, "11g");
+    }
+
+    /* FIXME: 11b would need to rely on checking if basic rateset has been
+     * limited. Although that's per-BSS, not per-PHY in practice, so flattening
+     * this out here is another ugly thing to do. This is not that important
+     * so..
+     */
+}
+
+static void
+ow_ovsdb_phystate_fill_allowed_channels(struct schema_Wifi_Radio_State *schema,
+                                        const struct osw_state_phy_info *phy)
+{
+    const struct osw_channel_state *arr = phy->drv_state->channel_states;
+    size_t n = phy->drv_state->n_channel_states;
+    size_t i;
+
+    if (arr == NULL) return;
+
+    for (i = 0; i < n; i++) {
+        const struct osw_channel *c = &arr[i].channel;
+        int num = ow_ovsdb_freq_to_chan(c->control_freq_mhz);
+        if (num > 0) SCHEMA_VAL_APPEND_INT(schema->allowed_channels, num);
+    }
+}
+
+static const char *
+ow_ovsdb_chan_dfs_state(const enum osw_channel_state_dfs s)
+{
+    switch (s) {
+        case OSW_CHANNEL_NON_DFS: return "{\"state\": \"allowed\"}";
+        case OSW_CHANNEL_DFS_CAC_POSSIBLE: return "{\"state\": \"nop_finished\"}";
+        case OSW_CHANNEL_DFS_CAC_IN_PROGRESS: return "{\"state\": \"cac_started\"}";
+        case OSW_CHANNEL_DFS_CAC_COMPLETED: return "{\"state\": \"cac_completed\"}";
+        case OSW_CHANNEL_DFS_NOL: return "{\"state\": \"nop_started\"}";
+    }
+    LOGW("%s: unknown state: %d", __func__, s);
+    return NULL;
+}
+
+static void
+ow_ovsdb_phystate_fill_channels(struct schema_Wifi_Radio_State *schema,
+                                const struct osw_state_phy_info *phy)
+{
+    const struct osw_channel_state *arr = phy->drv_state->channel_states;
+    size_t n = phy->drv_state->n_channel_states;
+    size_t i;
+
+    if (arr == NULL) return;
+
+    for (i = 0; i < n; i++) {
+        const struct osw_channel_state *cs = &arr[i];
+        const struct osw_channel *c = &cs->channel;
+        int num = ow_ovsdb_freq_to_chan(c->control_freq_mhz);
+        char k[32];
+        const char *v = ow_ovsdb_chan_dfs_state(cs->dfs_state);
+        snprintf(k, sizeof(k), "%d", num);
+        if (num > 0) SCHEMA_KEY_VAL_APPEND(schema->channels, k, v);
+    }
+}
+
+static const char *
+ow_ovsdb_phystate_get_freq_band(const struct osw_state_phy_info *phy)
+{
+    bool has_2g = false;
+    bool has_5gu = false;
+    bool has_5gl = false;
+    bool has_5g = false;
+    bool has_6g = false;
+    unsigned int bands = 0;
+    const struct osw_channel_state *arr = phy->drv_state->channel_states;
+    size_t n = phy->drv_state->n_channel_states;
+    size_t i;
+
+    for (i = 0; i < n; i++) {
+        const struct osw_channel *c = &arr[i].channel;
+        const int freq = c->control_freq_mhz;
+        const int num = ow_ovsdb_freq_to_chan(freq);
+        if (freq < 5935) {
+            if (num >= 1 && num <= 14) has_2g = true;
+            if (num >= 36 && num <= 64) has_5gl = true;
+            if (num >= 100) has_5gu = true;
+        } else {
+            has_6g = true;
+        }
+    }
+
+    has_5g = has_5gl || has_5gu;
+    bands = has_2g + has_5g + has_6g;
+
+    if (WARN_ON(bands != 1)) return NULL;
+    if (has_6g) return "6G";
+    if (has_2g) return "2.4G";
+    if (has_5gl && has_5gu) return "5G";
+    if (has_5gl) return "5GL";
+    if (has_5gu) return "5GU";
+
+    return NULL;
+}
+
+static void
+ow_ovsdb_phystate_fix_no_vifs(struct schema_Wifi_Radio_State *rstate,
+                              const struct schema_Wifi_Radio_Config *rconf)
+{
+    if (rconf == NULL) return;
+    if (rconf->vif_configs_len > 0) return;
+
+    LOGI("ow: ovsdb: %s: fixing up rstate due to no vifs", rconf->if_name);
+    SCHEMA_CPY_INT(rstate->channel, rconf->channel);
+    SCHEMA_CPY_STR(rstate->ht_mode, rconf->ht_mode);
+    SCHEMA_CPY_STR(rstate->hw_mode, rconf->hw_mode);
+}
+
+static void
+ow_ovsdb_phystate_to_schema(struct schema_Wifi_Radio_State *schema,
+                            const struct schema_Wifi_Radio_Config *rconf,
+                            const struct osw_state_phy_info *phy)
+{
+    const char *freq_band = ow_ovsdb_phystate_get_freq_band(phy);
+    char mac_str[18];
+
+    SCHEMA_SET_STR(schema->freq_band, "2.4G");
+
+    if (freq_band != NULL)
+        SCHEMA_SET_STR(schema->freq_band, freq_band);
+
+    /* FIXME: Some parameters don't really are driver-driven
+     * states, but will be handled internally in OW, eg.
+     * fallback_parents, so there can be just copied.
+     * However some arguably should be dervied from the
+     * state, eg. freq_band.
+     */
+    if (rconf != NULL) {
+        int i;
+
+        if (rconf->_uuid_exists == true)
+            SCHEMA_SET_UUID(schema->radio_config, rconf->_uuid.uuid);
+
+        SCHEMA_CPY_STR(schema->channel_mode, rconf->channel_mode);
+        SCHEMA_CPY_STR(schema->hw_type, rconf->hw_type);
+        SCHEMA_CPY_STR(schema->zero_wait_dfs, rconf->zero_wait_dfs);
+
+        for (i = 0; i < rconf->hw_config_len; i++) {
+            SCHEMA_KEY_VAL_APPEND(schema->hw_config,
+                                  rconf->hw_config_keys[i],
+                                  rconf->hw_config[i]);
+        }
+
+        for (i = 0; i < rconf->fallback_parents_len; i++) {
+            SCHEMA_KEY_VAL_APPEND_INT(schema->fallback_parents,
+                                      rconf->fallback_parents_keys[i],
+                                      rconf->fallback_parents[i]);
+        }
+    }
+
+    snprintf(mac_str, sizeof(mac_str), "%02x:%02x:%02x:%02x:%02x:%02x",
+             phy->drv_state->mac_addr.octet[0],
+             phy->drv_state->mac_addr.octet[1],
+             phy->drv_state->mac_addr.octet[2],
+             phy->drv_state->mac_addr.octet[3],
+             phy->drv_state->mac_addr.octet[4],
+             phy->drv_state->mac_addr.octet[5]);
+
+    SCHEMA_SET_STR(schema->if_name, phy->phy_name);
+    SCHEMA_SET_STR(schema->mac, mac_str);
+    SCHEMA_SET_INT(schema->tx_chainmask, phy->drv_state->tx_chainmask);
+    SCHEMA_SET_BOOL(schema->enabled, phy->drv_state->enabled);
+    ow_ovsdb_phystate_fill_bcn_int(schema, phy);
+    ow_ovsdb_phystate_fill_channel(schema, phy);
+    ow_ovsdb_phystate_fill_hwmode(schema, freq_band, phy);
+    ow_ovsdb_phystate_fill_allowed_channels(schema, phy);
+    ow_ovsdb_phystate_fill_channels(schema, phy);
+    ow_ovsdb_phystate_fix_no_vifs(schema, rconf);
+
+    // FIXME: channels[], needed for DFS
+    // FIXME: tx_power
+    // FIXME: radar[] ?
+    // FIXME: country
+
+    switch (phy->drv_state->radar) {
+        case OSW_RADAR_UNSUPPORTED:
+            SCHEMA_SET_BOOL(schema->dfs_demo, false);
+            break;
+        case OSW_RADAR_DETECT_ENABLED:
+            SCHEMA_SET_BOOL(schema->dfs_demo, false);
+            break;
+        case OSW_RADAR_DETECT_DISABLED:
+            SCHEMA_SET_BOOL(schema->dfs_demo, true);
+            break;
+    }
+}
+
+static void
+ow_ovsdb_vifstate_fix_up_security(struct schema_Wifi_VIF_State *schema,
+                                  const struct schema_Wifi_VIF_Config *vconf)
+{
+    bool wpa = false;
+    bool rsn = false;
+    bool ft = false;
+    int i;
+
+    if (vconf->wpa_exists == true) return;
+    if (vconf->security_len == 0) return;
+
+    for (i = 0; i < schema->wpa_key_mgmt_len; i++) {
+        const char *akm = schema->wpa_key_mgmt[i];
+        if (strcmp(akm, "wpa2-psk") == 0) rsn = true;
+        else if (strcmp(akm, "wpa-psk") == 0) wpa = true;
+        else if (strcmp(akm, "ft-wpa2-psk") == 0) ft = true;
+        else {
+            LOGI("ow: ovsdb: vif: %s: refusing to translate security[], unknown akm: %s",
+                 schema->if_name, akm);
+            return;
+        }
+    }
+
+    const char *mode_str =  wpa &&  rsn ? "3" :
+                           !wpa &&  rsn ? "2" :
+                            wpa && !rsn ? "1" :
+                            "0";
+
+    SCHEMA_KEY_VAL_APPEND(schema->security, "mode", mode_str);
+    SCHEMA_KEY_VAL_APPEND(schema->security, "encryption", "WPA-PSK");
+    SCHEMA_SET_BOOL(schema->ft_psk, ft);
+
+    for (i = 0; i < schema->wpa_psks_len; i++) {
+        const char *k = schema->wpa_psks_keys[i];
+        const char *v = schema->wpa_psks[i];
+        SCHEMA_KEY_VAL_APPEND(schema->security, k, v);
+    }
+
+    for (i = 0; i < vconf->security_len; i++) {
+        const char *k = vconf->security_keys[i];
+        const char *v = vconf->security[i];
+        if (strstr(k, "oftag") != k) continue;
+        SCHEMA_KEY_VAL_APPEND(schema->security, k, v);
+    }
+
+    SCHEMA_UNSET_FIELD(schema->wpa);
+    SCHEMA_UNSET_MAP(schema->wpa_psks);
+    SCHEMA_UNSET_MAP(schema->wpa_key_mgmt);
+}
+
+static void
+ow_ovsdb_vifstate_fix_up(struct schema_Wifi_VIF_State *schema)
+{
+    struct schema_Wifi_VIF_Config *vconf;
+    vconf = ovsdb_cache_find_by_key(&table_Wifi_VIF_Config, schema->if_name);
+    if (vconf == NULL) return;
+
+    SCHEMA_SET_UUID(schema->vif_config, vconf->_uuid.uuid);
+    if (vconf->vif_radio_idx_exists == true)
+        SCHEMA_SET_INT(schema->vif_radio_idx, vconf->vif_radio_idx);
+
+    ow_ovsdb_vifstate_fix_up_security(schema, vconf);
+}
+
+static enum osw_vif_type
+ow_ovsdb_mode_to_type(const char *mode)
+{
+    if (strcmp(mode, "ap") == 0) return OSW_VIF_AP;
+    if (strcmp(mode, "ap_vlan") == 0) return OSW_VIF_AP_VLAN;
+    if (strcmp(mode, "sta") == 0) return OSW_VIF_STA;
+    return OSW_VIF_UNDEFINED;
+}
+
+static void
+ow_ovsdb_vifstate_fill_ap_akm(struct schema_Wifi_VIF_State *schema,
+                               const struct osw_wpa *wpa)
+{
+    /* FIXME: This isn't totally accurate, but good enough for now. */
+
+    if (wpa->akm_sae) {
+        SCHEMA_VAL_APPEND(schema->wpa_key_mgmt, "sae");
+    }
+    if (wpa->akm_ft_sae) {
+        SCHEMA_VAL_APPEND(schema->wpa_key_mgmt, "ft-sae");
+    }
+    if (wpa->akm_psk) {
+        if (wpa->wpa)
+            SCHEMA_VAL_APPEND(schema->wpa_key_mgmt, "wpa-psk");
+        if (wpa->rsn)
+            SCHEMA_VAL_APPEND(schema->wpa_key_mgmt, "wpa2-psk");
+    }
+    if (wpa->akm_ft_psk) {
+        SCHEMA_VAL_APPEND(schema->wpa_key_mgmt, "ft-wpa2-psk");
+    }
+}
+
+static int
+ow_ovsdb_str2keyid(const char *key_id)
+{
+    int i;
+    if (strcmp(key_id, "key") == 0)
+        return 0;
+    if (sscanf(key_id, "key-%d", &i) == 1)
+        return i;
+    return -1;
+}
+
+static void
+ow_ovsdb_keyid2str(char *buf, const size_t len, const int key_id)
+{
+    if (key_id == 0)
+        snprintf(buf, len, "key");
+    else
+        snprintf(buf, len, "key-%d", key_id);
+}
+
+static void
+ow_ovsdb_vifstate_fill_ap_psk(struct schema_Wifi_VIF_State *schema,
+                              const struct osw_ap_psk_list *psks)
+{
+    size_t i;
+    for (i = 0; i < psks->count; i++) {
+        const struct osw_ap_psk *psk = &psks->list[i];
+        char key_id[64];
+
+        if (WARN_ON(i >= ARRAY_SIZE(schema->wpa_psks)))
+            break;
+
+        ow_ovsdb_keyid2str(key_id, sizeof(key_id), psk->key_id);
+        SCHEMA_KEY_VAL_APPEND(schema->wpa_psks, key_id, psk->psk.str);
+    }
+}
+
+static void
+ow_ovsdb_vifstate_fill_ap_acl(struct schema_Wifi_VIF_State *schema,
+                              const struct osw_hwaddr_list *acl)
+{
+    size_t i;
+    for (i = 0; i < acl->count; i++) {
+        struct osw_hwaddr_str buf;
+        const char *str = osw_hwaddr2str(&acl->list[i], &buf);
+
+        if (WARN_ON(i >= ARRAY_SIZE(schema->mac_list)))
+            break;
+
+        SCHEMA_VAL_APPEND(schema->mac_list, str);
+    }
+}
+
+static void
+ow_ovsdb_vifstate_fix_min_hw_mode(struct schema_Wifi_VIF_State *vstate,
+                                  const struct schema_Wifi_VIF_Config *vconf)
+{
+    if (vconf == NULL) return;
+    SCHEMA_CPY_STR(vstate->min_hw_mode, vconf->min_hw_mode);
+}
+
+static void
+ow_ovsdb_vifstate_to_schema(struct schema_Wifi_VIF_State *schema,
+                            const struct schema_Wifi_VIF_Config *vconf,
+                            const struct osw_state_vif_info *vif)
+{
+    const struct osw_drv_vif_state_ap *ap = &vif->drv_state->u.ap;
+    struct osw_hwaddr_str mac;
+    int c;
+
+    SCHEMA_SET_STR(schema->if_name, vif->vif_name);
+    SCHEMA_SET_BOOL(schema->enabled, vif->drv_state->enabled);
+    SCHEMA_SET_STR(schema->mac, osw_hwaddr2str(&vif->drv_state->mac_addr, &mac));
+
+    switch (vif->drv_state->vif_type) {
+        case OSW_VIF_UNDEFINED:
+            break;
+        case OSW_VIF_AP:
+            SCHEMA_SET_STR(schema->mode, "ap");
+            SCHEMA_SET_STR(schema->ssid, ap->ssid.buf);
+            SCHEMA_SET_STR(schema->ssid_broadcast, ap->ssid_hidden ? "disabled" : "enabled");
+            SCHEMA_SET_STR(schema->bridge, ap->bridge_if_name.buf);
+            SCHEMA_SET_INT(schema->ft_mobility_domain, ap->wpa.ft_mobility_domain);
+            SCHEMA_SET_BOOL(schema->wpa, ap->wpa.wpa || ap->wpa.rsn);
+            SCHEMA_SET_BOOL(schema->ap_bridge, ap->isolated ? false : true);
+            SCHEMA_SET_BOOL(schema->btm, ap->mode.wnm_bss_trans);
+            SCHEMA_SET_BOOL(schema->rrm, ap->mode.rrm_neighbor_report);
+            SCHEMA_SET_BOOL(schema->wps, ap->mode.wps);
+            SCHEMA_SET_BOOL(schema->uapsd_enable, ap->mode.wmm_uapsd_enabled);
+            SCHEMA_SET_BOOL(schema->mcast2ucast, ap->mcast2ucast);
+            SCHEMA_SET_BOOL(schema->dynamic_beacon, false); // FIXME
+
+            {
+                const char *acl_policy_str = ow_ovsdb_acl_policy_to_str(ap->acl_policy);
+                if (acl_policy_str != NULL)
+                    SCHEMA_SET_STR(schema->mac_list_type, acl_policy_str);
+            }
+
+            if (ap->wpa.group_rekey_seconds != OSW_WPA_GROUP_REKEY_UNDEFINED)
+                SCHEMA_SET_INT(schema->group_rekey, ap->wpa.group_rekey_seconds);
+
+            c = ow_ovsdb_freq_to_chan(ap->channel.control_freq_mhz);
+            if (c != 0)
+                SCHEMA_SET_INT(schema->channel, c);
+
+            ow_ovsdb_vifstate_fill_ap_akm(schema, &ap->wpa);
+            ow_ovsdb_vifstate_fill_ap_psk(schema, &ap->psk_list);
+            ow_ovsdb_vifstate_fill_ap_acl(schema, &ap->acl);
+            ow_ovsdb_vifstate_fix_min_hw_mode(schema, vconf);
+            break;
+        case OSW_VIF_AP_VLAN:
+            SCHEMA_SET_STR(schema->mode, "ap_vlan");
+            break;
+        case OSW_VIF_STA:
+            SCHEMA_SET_STR(schema->mode, "sta");
+            break;
+    }
+
+    ow_ovsdb_vifstate_fix_up(schema);
+}
+
+static void
+ow_ovsdb_phystate_fix_vif_states(struct ow_ovsdb_phy *phy)
+{
+    struct schema_Wifi_Radio_State *rstate = &phy->state_new;
+    struct ds_tree *tree = &phy->root->vif_tree;
+    struct ow_ovsdb_vif *vif;
+    const char *phy_name = phy->phy_name;
+
+    ds_tree_foreach(tree, vif) {
+        if (vif->phy_name == NULL) continue;
+        if (strcmp(vif->phy_name, phy_name) != 0) continue;
+        if (strlen(vif->state_cur._uuid.uuid) == 0) continue;
+
+        ovs_uuid_t *uuid = &rstate->vif_states[rstate->vif_states_len];
+        rstate->vif_states_len++;
+        *uuid = vif->state_cur._uuid;
+    }
+}
+
+static void
+ow_ovsdb_phy_gc(struct ow_ovsdb_phy *phy)
+{
+    struct ds_tree *tree = &phy->root->phy_tree;
+
+    if (strlen(phy->config.if_name) > 0) return;
+    if (strlen(phy->state_cur.if_name) > 0) return;
+    if (phy->info != NULL) return;
+
+    ds_tree_remove(tree, phy);
+    FREE(phy->phy_name);
+    FREE(phy);
+}
+
+static void
+ow_ovsdb_phy_fill_schema(struct ow_ovsdb_phy *phy)
+{
+    const struct schema_Wifi_Radio_Config *rconf = NULL;
+
+    memset(&phy->state_new, 0, sizeof(phy->state_new));
+    if (strlen(phy->state_cur._uuid.uuid) > 0)
+        STRSCPY(phy->state_new._uuid.uuid, phy->state_cur._uuid.uuid);
+
+    if (strlen(phy->config.if_name) > 0)
+        rconf = &phy->config;
+
+    ow_ovsdb_phystate_to_schema(&phy->state_new, rconf, phy->info); // FIXME
+    ow_ovsdb_phystate_fix_vif_states(phy);
+}
+
+static void /* forward decl */
+ow_ovsdb_vif_work_sched(struct ow_ovsdb_vif *vif);
+
+static void
+ow_ovsdb_phy_sync_vifs(struct ow_ovsdb_phy *phy)
+{
+    struct ow_ovsdb *root = &g_ow_ovsdb;
+    struct ow_ovsdb_vif *vif;
+
+    ds_tree_foreach(&root->vif_tree, vif) {
+        if (vif->phy_name == NULL)
+            continue;
+        if (strcmp(vif->phy_name, phy->phy_name) != 0)
+            continue;
+        ow_ovsdb_vif_work_sched(vif);
+    }
+}
+
+static bool
+ow_ovsdb_phy_sync(struct ow_ovsdb_phy *phy)
+{
+    if (phy->info == NULL) {
+        if (strlen(phy->state_cur.if_name) == 0) return true;
+
+        LOGI("ow: ovsdb: phy: %s: deleting", phy->phy_name);
+
+        ovsdb_table_delete(&table_Wifi_Radio_State, &phy->state_cur);
+        memset(&phy->state_cur, 0, sizeof(phy->state_cur));
+        return true;
+    }
+    else {
+        ow_ovsdb_phy_fill_schema(phy);
+
+        if (memcmp(&phy->state_cur, &phy->state_new, sizeof(phy->state_cur)) == 0)
+            return true;
+
+        LOGI("ow: ovsdb: phy: %s: upserting", phy->phy_name);
+
+        bool ok = ovsdb_table_upsert(&table_Wifi_Radio_State, &phy->state_new, true);
+        if (ok == false)
+            return false;
+
+        phy->state_cur = phy->state_new;
+        ow_ovsdb_phy_sync_vifs(phy);
+        return true;
+    }
+}
+
+static void
+ow_ovsdb_phy_work_cb(EV_P_ ev_timer *arg, int events)
+{
+    struct ow_ovsdb_phy *phy = container_of(arg, struct ow_ovsdb_phy, work);
+    if (ow_ovsdb_phy_sync(phy) == false) return;
+    ev_timer_stop(EV_A_ arg);
+    ow_ovsdb_phy_gc(phy);
+}
+
+static void
+ow_ovsdb_phy_work_sched(struct ow_ovsdb_phy *phy)
+{
+    ev_timer_stop(EV_DEFAULT_ &phy->work);
+    ev_timer_set(&phy->work, 0, 5);
+    ev_timer_start(EV_DEFAULT_ &phy->work);
+}
+
+static void
+ow_ovsdb_phy_init(struct ow_ovsdb *root,
+                  struct ow_ovsdb_phy *phy,
+                  const char *phy_name)
+{
+    phy->root = root;
+    phy->phy_name = STRDUP(phy_name);
+    ev_timer_init(&phy->work, ow_ovsdb_phy_work_cb, 0, 0);
+    ds_tree_insert(&root->phy_tree, phy, phy->phy_name);
+}
+
+static struct ow_ovsdb_phy *
+ow_ovsdb_phy_get(const char *phy_name)
+{
+    struct ow_ovsdb *root = &g_ow_ovsdb;
+    struct ow_ovsdb_phy *phy = ds_tree_find(&root->phy_tree, phy_name);
+    if (phy == NULL) {
+        phy = CALLOC(1, sizeof(*phy));
+        ow_ovsdb_phy_init(root, phy, phy_name);
+    }
+    return phy;
+}
+
+static void
+ow_ovsdb_phy_set_info(const char *phy_name,
+                      const struct osw_state_phy_info *info)
+{
+    struct ow_ovsdb_phy *phy = ow_ovsdb_phy_get(phy_name);
+    phy->info = info;
+    ow_ovsdb_phy_work_sched(phy);
+}
+
+static void
+ow_ovsdb_phy_set_config(const char *phy_name,
+                        const struct schema_Wifi_Radio_Config *config)
+{
+    struct ow_ovsdb_phy *phy = ow_ovsdb_phy_get(phy_name);
+
+    memset(&phy->config, 0, sizeof(phy->config));
+    if (config != NULL)
+        phy->config = *config;
+
+    ow_ovsdb_phy_work_sched(phy);
+}
+
+static bool
+ow_ovsdb_vif_is_phy_ready(struct ow_ovsdb_vif *vif)
+{
+    struct ow_ovsdb *root = &g_ow_ovsdb;
+    struct ow_ovsdb_phy *phy;
+
+    if (vif->phy_name == NULL)
+        return false;
+
+    phy = ds_tree_find(&root->phy_tree, vif->phy_name);
+    if (phy == NULL)
+        return false;
+
+    if (ev_is_active(&phy->work) == true)
+        return false;
+
+    if (strlen(phy->state_cur.if_name) == 0)
+        return false;
+
+    return true;
+}
+
+static void
+ow_ovsdb_vif_gc(struct ow_ovsdb_vif *vif)
+{
+    struct ds_tree *tree = &vif->root->vif_tree;
+
+    if (strlen(vif->config.if_name) > 0) return;
+    if (strlen(vif->state_cur.if_name) > 0) return;
+    if (vif->info != NULL) return;
+
+    ds_tree_remove(tree, vif);
+    FREE(vif->phy_name);
+    FREE(vif->vif_name);
+    FREE(vif);
+}
+
+static void
+ow_ovsdb_vif_fill_schema(struct ow_ovsdb_vif *vif)
+{
+    const struct schema_Wifi_VIF_Config *vconf = NULL;
+    const char *uuid = vif->state_cur._uuid.uuid;
+
+    memset(&vif->state_new, 0, sizeof(vif->state_new));
+    if (strlen(uuid) > 0)
+        STRSCPY(vif->state_new._uuid.uuid, uuid);
+    if (strlen(vif->config.if_name) > 0)
+        vconf = &vif->config;
+
+    ow_ovsdb_vifstate_to_schema(&vif->state_new, vconf, vif->info);
+}
+
+static void /* forward decl */
+ow_ovsdb_sta_work_sched(struct ow_ovsdb_sta *sta);
+
+static void
+ow_ovsdb_vif_sync_stas(struct ow_ovsdb_vif *vif)
+{
+    struct ow_ovsdb *root = &g_ow_ovsdb;
+    struct ow_ovsdb_sta *sta;
+
+    ds_tree_foreach(&root->sta_tree, sta) {
+        if (sta->info == NULL)
+            continue;
+        if (strcmp(vif->vif_name, sta->info->vif->vif_name) != 0)
+            continue;
+        ow_ovsdb_sta_work_sched(sta);
+    }
+}
+
+static bool
+ow_ovsdb_vif_state_is_wanted(struct ow_ovsdb_vif *vif)
+{
+    if (vif->info == NULL) return false;
+    if (vif->info->drv_state->enabled == true) return true;
+    if (vif->info->drv_state->vif_type == OSW_VIF_AP_VLAN) return true;
+    if (strlen(vif->config.if_name) == 0) return false;
+    return true;
+}
+
+static bool
+ow_ovsdb_vif_sync(struct ow_ovsdb_vif *vif)
+{
+    if (ow_ovsdb_vif_state_is_wanted(vif) == false) {
+        if (strlen(vif->state_cur.if_name) == 0) return true;
+
+        LOGI("ow: ovsdb: vif: %s: deleting", vif->vif_name);
+
+        ovsdb_table_delete(&table_Wifi_VIF_State, &vif->state_cur);
+        memset(&vif->state_cur, 0, sizeof(vif->state_cur));
+        return true;
+    }
+    else {
+        if (ow_ovsdb_vif_is_phy_ready(vif) == false)
+            return false;
+
+        ow_ovsdb_vif_fill_schema(vif);
+
+        if (memcmp(&vif->state_cur, &vif->state_new, sizeof(vif->state_cur)) == 0)
+            return true;
+
+        ovsdb_table_t *t = &table_Wifi_VIF_State;
+        char *pt = SCHEMA_TABLE(Wifi_Radio_State);
+        char *pc = SCHEMA_COLUMN(Wifi_Radio_State, vif_states);
+        char *pk = SCHEMA_COLUMN(Wifi_Radio_State, if_name);
+        json_t *w = ovsdb_where_simple(pk, vif->phy_name);
+
+        if (w == NULL)
+            return false;
+
+        LOGI("ow: ovsdb: vif: %s: upserting", vif->vif_name);
+
+        bool ok = ovsdb_table_upsert_with_parent(t, &vif->state_new, true, NULL,
+                                                 pt, w, pc);
+        if (ok == false)
+            return false;
+
+        vif->state_cur = vif->state_new;
+        ow_ovsdb_vif_sync_stas(vif);
+        return true;
+    }
+}
+
+static void
+ow_ovsdb_vif_work_cb(EV_P_ ev_timer *arg, int events)
+{
+    struct ow_ovsdb_vif *vif = container_of(arg, struct ow_ovsdb_vif, work);
+    if (ow_ovsdb_vif_sync(vif) == false) return;
+    ev_timer_stop(EV_A_ arg);
+    ow_ovsdb_vif_gc(vif);
+}
+
+static void
+ow_ovsdb_vif_work_sched(struct ow_ovsdb_vif *vif)
+{
+    ev_timer_stop(EV_DEFAULT_ &vif->work);
+    ev_timer_set(&vif->work, 0, 5);
+    ev_timer_start(EV_DEFAULT_ &vif->work);
+
+    if (vif->phy_name != NULL) {
+        struct ow_ovsdb *root = &g_ow_ovsdb;
+        struct ow_ovsdb_phy *phy = ds_tree_find(&root->phy_tree, vif->phy_name);
+        if (phy == NULL) return;
+
+        ow_ovsdb_phy_work_sched(phy);
+    }
+}
+
+static void
+ow_ovsdb_vif_init(struct ow_ovsdb *root,
+                  struct ow_ovsdb_vif *vif,
+                  const char *vif_name)
+{
+    vif->root = root;
+    vif->vif_name = STRDUP(vif_name);
+    ev_timer_init(&vif->work, ow_ovsdb_vif_work_cb, 0, 0);
+    ds_tree_insert(&root->vif_tree, vif, vif->vif_name);
+}
+
+static struct ow_ovsdb_vif *
+ow_ovsdb_vif_get(const char *vif_name)
+{
+    struct ow_ovsdb *root = &g_ow_ovsdb;
+    struct ow_ovsdb_vif *vif = ds_tree_find(&root->vif_tree, vif_name);
+    if (vif == NULL) {
+        vif = CALLOC(1, sizeof(*vif));
+        ow_ovsdb_vif_init(root, vif, vif_name);
+    }
+    return vif;
+}
+
+static void
+ow_ovsdb_vif_set_info(const char *vif_name,
+                      const struct osw_state_vif_info *info)
+{
+    struct ow_ovsdb_vif *vif = ow_ovsdb_vif_get(vif_name);
+
+    vif->info = info;
+    if (vif->phy_name == NULL)
+        vif->phy_name = STRDUP(info->phy->phy_name);
+
+    ow_ovsdb_vif_work_sched(vif);
+}
+
+static void
+ow_ovsdb_vif_set_config(const char *vif_name,
+                        const struct schema_Wifi_VIF_Config *config)
+{
+    struct ow_ovsdb_vif *vif = ow_ovsdb_vif_get(vif_name);
+
+    memset(&vif->config, 0, sizeof(vif->config));
+    if (config != NULL)
+        vif->config = *config;
+
+    ow_ovsdb_vif_cleanup_set_configured(vif_name, config ? true : false);
+    ow_ovsdb_vif_work_sched(vif);
+}
+
+static void
+ow_ovsdb_sta_gc(struct ow_ovsdb_sta *sta)
+{
+    struct ds_tree *tree = &sta->root->sta_tree;
+
+    if (sta->info != NULL) return;
+    if (sta->vif_name != NULL) return;
+    if (sta->oftag != NULL) return;
+    if (strlen(sta->state_cur.mac) > 0) return;
+
+    ds_tree_remove(tree, sta);
+    FREE(sta);
+}
+
+static bool
+ow_ovsdb_sta_is_vif_ready(struct ow_ovsdb_sta *sta)
+{
+    struct ow_ovsdb *root = &g_ow_ovsdb;
+    struct ow_ovsdb_vif *vif;
+
+    if (sta->info == NULL)
+        return false;
+
+    vif = ds_tree_find(&root->vif_tree, sta->info->vif->vif_name);
+    if (vif == NULL)
+        return false;
+
+    if (ev_is_active(&vif->work) == true)
+        return false;
+
+    if (strlen(vif->state_cur.if_name) == 0)
+        return false;
+
+    return true;
+}
+
+static const char *
+ow_ovsdb_sta_derive_oftag(struct ow_ovsdb_sta *sta)
+{
+    struct ow_ovsdb *root = &g_ow_ovsdb;
+    struct ow_ovsdb_vif *vif;
+    char key1[32];
+    char key2[64];
+    const char *oftag;
+
+    if (sta->info == NULL)
+        return NULL;
+
+    vif = ds_tree_find(&root->vif_tree, sta->info->vif->vif_name ?: "");
+    if (vif == NULL)
+        return NULL;
+
+    if (sta->info == NULL)
+        return NULL;
+
+    ow_ovsdb_keyid2str(key1, sizeof(key1), sta->info->drv_state->key_id);
+    oftag = SCHEMA_KEY_VAL_NULL(vif->config.wpa_oftags, key1);
+    if (oftag != NULL)
+        return oftag;
+
+    if (sta->info->drv_state->key_id == 0)
+        snprintf(key2, sizeof(key2), "oftag");
+    else
+        snprintf(key2, sizeof(key2), "oftag-%s", key1);
+    oftag = SCHEMA_KEY_VAL_NULL(vif->config.security, key2);
+    if (oftag != NULL)
+        return oftag;
+
+    if (vif->config.default_oftag_exists)
+        return vif->config.default_oftag;
+
+    return NULL;
+}
+
+static void
+ow_ovsdb_sta_fill_schema(struct ow_ovsdb_sta *sta)
+{
+    struct schema_Wifi_Associated_Clients *schema = &sta->state_new;
+    const char *oftag = ow_ovsdb_sta_derive_oftag(sta);
+    const char *uuid = sta->state_cur._uuid.uuid;
+    struct osw_hwaddr_str mac_str;
+    char key_id[64];
+
+    memset(schema, 0, sizeof(*schema));
+
+    if (strlen(uuid) > 0)
+        STRSCPY(schema->_uuid.uuid, uuid);
+
+    osw_hwaddr2str(&sta->sta_addr, &mac_str);
+    ow_ovsdb_keyid2str(key_id, sizeof(key_id), sta->info->drv_state->key_id);
+
+    SCHEMA_SET_STR(schema->mac, mac_str.buf);
+    SCHEMA_SET_STR(schema->state, "active");
+    SCHEMA_SET_STR(schema->key_id, key_id);
+
+    if (oftag != NULL)
+        SCHEMA_SET_STR(schema->oftag, oftag);
+}
+
+static int
+ow_ovsdb_sta_tag_mutate(const struct osw_hwaddr *addr,
+                        const char *oftag,
+                        const char *action)
+{
+    const char *table = SCHEMA_TABLE(Openflow_Tag);
+    const char *column = SCHEMA_COLUMN(Openflow_Tag, name);
+    struct osw_hwaddr_str mac_str;
+    osw_hwaddr2str(addr, &mac_str);
+
+    /* FIXME: This imperative approach to mutating doesn't
+     * guarantee consistency in case of process restart,
+     * etc. This doesn't clean up the ovsdb state that it
+     * gets to see on boot. A more robust solution would be
+     * to monitor Openflow_Tag in its entirety and re-sync
+     * only when the entries of interest are out of sync.
+     */
+
+    json_t *where = ovsdb_tran_cond(OCLM_STR, column, OFUNC_EQ, oftag);
+    if (where == NULL) {
+        return -1;
+    }
+
+    json_t *row = ovsdb_mutation("device_value",
+                                 json_string(action), /* "insert" or "delete" */
+                                 json_string(mac_str.buf));
+    if (row == NULL) {
+        free(where);
+        return -1;
+    }
+
+    json_t *rows = json_array();
+    if (rows == NULL) {
+        free(row);
+        free(where);
+        return -1;
+    }
+    json_array_append_new(rows, row);
+
+    json_t *res = ovsdb_tran_call_s(table, OTR_MUTATE, where, rows);
+    if (res == NULL) {
+        return -1;
+    }
+
+    int cnt = ovsdb_get_update_result_count(res, table, "mutate");
+
+    return cnt;
+}
+
+static bool
+ow_ovsdb_sta_set_tag(struct ow_ovsdb_sta *sta, const char *oftag)
+{
+    if (WARN_ON(sta->oftag != NULL)) return true;
+
+    int c = ow_ovsdb_sta_tag_mutate(&sta->sta_addr, oftag, "insert");
+    if (c != 1) return false;
+
+    sta->oftag = STRDUP(oftag);
+    return true;
+}
+
+static bool
+ow_ovsdb_sta_unset_tag(struct ow_ovsdb_sta *sta)
+{
+    if (WARN_ON(sta->oftag == NULL)) return true;
+
+    ow_ovsdb_sta_tag_mutate(&sta->sta_addr, sta->oftag, "delete");
+    FREE(sta->oftag);
+    sta->oftag = NULL;
+    return true;
+}
+
+static bool
+ow_ovsdb_sta_sync_tag(struct ow_ovsdb_sta *sta)
+{
+    const char *oftag = ow_ovsdb_sta_derive_oftag(sta);
+    bool ok = true;
+
+    if (oftag != NULL && sta->oftag == NULL) {
+        LOGI("ow: ovsdb: sta: "OSW_HWADDR_FMT": setting oftag: '%s'",
+             OSW_HWADDR_ARG(&sta->sta_addr), oftag);
+        ok &= ow_ovsdb_sta_set_tag(sta, oftag);
+    }
+    else if (oftag == NULL && sta->oftag != NULL) {
+        LOGI("ow: ovsdb: sta: "OSW_HWADDR_FMT": clearing oftag: '%s'",
+             OSW_HWADDR_ARG(&sta->sta_addr), sta->oftag);
+        ok &= ow_ovsdb_sta_unset_tag(sta);
+    }
+    else if (oftag != NULL && sta->oftag != NULL && strcmp(oftag, sta->oftag) != 0) {
+        LOGI("ow: ovsdb: sta: "OSW_HWADDR_FMT": changing oftag: '%s' -> '%s'",
+             OSW_HWADDR_ARG(&sta->sta_addr), sta->oftag, oftag);
+        ok &= ow_ovsdb_sta_unset_tag(sta);
+        ok &= ow_ovsdb_sta_set_tag(sta, oftag);
+    }
+
+
+    /* FIXME: This can't easily return false because it is
+     * not guaranteed that Openflow_Tag entry will ever
+     * exist. If this returned false it would risk running a
+     * re-try job forever. So instead just print a message
+     * for now.
+     */
+    if (ok != true) {
+        LOGI("ow: ovsdb: sta: %s: failed to set oftag, ignoring",
+             sta->state_cur.mac);
+    }
+
+    return true;
+}
+
+static bool
+ow_ovsdb_sta_upsert(struct ow_ovsdb_sta *sta)
+{
+    if (ow_ovsdb_sta_is_vif_ready(sta) == false)
+        return false;
+
+    ow_ovsdb_sta_fill_schema(sta);
+
+    if (memcmp(&sta->state_cur, &sta->state_new, sizeof(sta->state_cur)) == 0)
+        return true;
+
+    ovsdb_table_t *t = &table_Wifi_Associated_Clients;
+    char *pt = SCHEMA_TABLE(Wifi_VIF_State);
+    char *pc = SCHEMA_COLUMN(Wifi_VIF_State, associated_clients);
+    char *pk = SCHEMA_COLUMN(Wifi_VIF_State, if_name);
+    json_t *w = ovsdb_where_simple(pk, sta->info->vif->vif_name);
+
+    if (w == NULL)
+        return false;
+
+    LOGI("ow: ovsdb: sta: %s: upserting: vif='%s' oftag='%s'",
+         sta->state_new.mac, sta->info->vif->vif_name, sta->state_new.oftag);
+
+    bool ok = ovsdb_table_upsert_with_parent(t, &sta->state_new, true, NULL,
+                                             pt, w, pc);
+    if (ok == false)
+        return false;
+
+    FREE(sta->vif_name);
+    sta->vif_name = STRDUP(sta->info->vif->vif_name);
+    sta->connected_at = sta->info->connected_at;
+    sta->state_cur = sta->state_new;
+
+    return true;
+}
+
+static bool
+ow_ovsdb_sta_delete(struct ow_ovsdb_sta *sta)
+{
+    if (strlen(sta->state_cur.mac) == 0) return true;
+
+    LOGI("ow: ovsdb: sta: %s: deleting: vif='%s' oftag='%s'",
+         sta->state_cur.mac, sta->vif_name, sta->state_cur.oftag);
+
+    ovsdb_table_delete(&table_Wifi_Associated_Clients, &sta->state_cur);
+    memset(&sta->state_cur, 0, sizeof(sta->state_cur));
+    FREE(sta->vif_name);
+    sta->vif_name = NULL;
+    sta->connected_at = 0;
+
+    return true;
+}
+
+static bool
+ow_ovsdb_sta_roamed(struct ow_ovsdb_sta *sta)
+{
+    if (sta->vif_name == NULL)
+        return false;
+
+    if (sta->info == NULL)
+        return false;
+
+    if (strcmp(sta->vif_name, sta->info->vif->vif_name) == 0)
+        return false;
+
+    if (sta->connected_at == sta->info->connected_at)
+        return false;
+
+    return true;
+}
+
+static bool
+ow_ovsdb_sta_sync(struct ow_ovsdb_sta *sta)
+{
+    bool ok = true;
+    bool roamed = ow_ovsdb_sta_roamed(sta);
+
+    if (roamed) {
+        LOGI("ow: ovsdb: sta: %s: roamed from '%s' to '%s'",
+             sta->state_cur.mac,
+             sta->vif_name,
+             sta->info->vif->vif_name);
+    }
+
+    if (roamed == true || sta->info == NULL)
+        ok &= ow_ovsdb_sta_delete(sta);
+
+    if (sta->info != NULL)
+        ok &= ow_ovsdb_sta_upsert(sta);
+
+    if (ok == true)
+        ok &= ow_ovsdb_sta_sync_tag(sta);
+
+    return ok;
+}
+
+static void
+ow_ovsdb_sta_work_cb(EV_P_ ev_timer *arg, int events)
+{
+    struct ow_ovsdb_sta *sta = container_of(arg, struct ow_ovsdb_sta, work);
+    if (ow_ovsdb_sta_sync(sta) == false) return;
+    ev_timer_stop(EV_A_ arg);
+    ow_ovsdb_sta_gc(sta);
+}
+
+static void
+ow_ovsdb_sta_work_sched(struct ow_ovsdb_sta *sta)
+{
+    ev_timer_stop(EV_DEFAULT_ &sta->work);
+    ev_timer_set(&sta->work, 0, 5);
+    ev_timer_start(EV_DEFAULT_ &sta->work);
+
+    if (sta->info != NULL) {
+        struct ow_ovsdb *root = &g_ow_ovsdb;
+        struct ow_ovsdb_vif *vif = ds_tree_find(&root->vif_tree, sta->info->vif->vif_name);
+        if (vif == NULL) return;
+
+        ow_ovsdb_vif_work_sched(vif);
+    }
+}
+
+static void
+ow_ovsdb_sta_init(struct ow_ovsdb *root,
+                  struct ow_ovsdb_sta *sta,
+                  const struct osw_hwaddr *sta_addr)
+{
+    sta->root = root;
+    sta->sta_addr = *sta_addr;
+    ev_timer_init(&sta->work, ow_ovsdb_sta_work_cb, 0, 0);
+    ds_tree_insert(&root->sta_tree, sta, &sta->sta_addr);
+}
+
+static struct ow_ovsdb_sta *
+ow_ovsdb_sta_get(const struct osw_hwaddr *sta_addr)
+{
+    struct ow_ovsdb *root = &g_ow_ovsdb;
+    struct ow_ovsdb_sta *sta = ds_tree_find(&root->sta_tree, sta_addr);
+    if (sta == NULL) {
+        sta = CALLOC(1, sizeof(*sta));
+        ow_ovsdb_sta_init(root, sta, sta_addr);
+    }
+    return sta;
+}
+
+static void
+ow_ovsdb_sta_set_info(const struct osw_hwaddr *sta_addr,
+                      const struct osw_state_sta_info *info)
+{
+    struct ow_ovsdb_sta *sta = ow_ovsdb_sta_get(sta_addr);
+
+    sta->info = osw_state_sta_lookup_newest(info->mac_addr);
+    if (sta->info && sta->info->drv_state->connected == false)
+        sta->info = NULL;
+
+    ow_ovsdb_sta_work_sched(sta);
+}
+
+static void
+ow_ovsdb_phy_added_cb(struct osw_state_observer *self,
+                      const struct osw_state_phy_info *info)
+{
+    ow_ovsdb_phy_set_info(info->phy_name, info);
+}
+
+static void
+ow_ovsdb_phy_changed_cb(struct osw_state_observer *self,
+                        const struct osw_state_phy_info *info)
+{
+    ow_ovsdb_phy_set_info(info->phy_name, info);
+}
+
+static void
+ow_ovsdb_phy_removed_cb(struct osw_state_observer *self,
+                        const struct osw_state_phy_info *info)
+{
+    ow_ovsdb_phy_set_info(info->phy_name, NULL);
+}
+
+static void
+ow_ovsdb_vif_added_cb(struct osw_state_observer *self,
+                      const struct osw_state_vif_info *info)
+{
+    ow_ovsdb_vif_set_info(info->vif_name, info);
+    ow_ovsdb_ms_set_vif(&g_ow_ovsdb.ms, info);
+    ow_ovsdb_vif_cleanup_set_phy_name(info->vif_name, info->phy->phy_name);
+    ow_ovsdb_vif_cleanup_set_reported(info->vif_name, info->drv_state->enabled);
+}
+
+static void
+ow_ovsdb_vif_changed_cb(struct osw_state_observer *self,
+                      const struct osw_state_vif_info *info)
+{
+    ow_ovsdb_vif_set_info(info->vif_name, info);
+    ow_ovsdb_ms_set_vif(&g_ow_ovsdb.ms, info);
+    ow_ovsdb_vif_cleanup_set_phy_name(info->vif_name, info->phy->phy_name);
+    ow_ovsdb_vif_cleanup_set_reported(info->vif_name, info->drv_state->enabled);
+}
+
+static void
+ow_ovsdb_vif_removed_cb(struct osw_state_observer *self,
+                      const struct osw_state_vif_info *info)
+{
+    ow_ovsdb_vif_set_info(info->vif_name, NULL);
+    ow_ovsdb_ms_set_vif(&g_ow_ovsdb.ms, info);
+    ow_ovsdb_vif_cleanup_set_reported(info->vif_name, false);
+}
+
+static void
+ow_ovsdb_sta_connected_cb(struct osw_state_observer *self,
+                          const struct osw_state_sta_info *info)
+{
+    ow_ovsdb_sta_set_info(info->mac_addr, info);
+}
+
+static void
+ow_ovsdb_sta_changed_cb(struct osw_state_observer *self,
+                        const struct osw_state_sta_info *info)
+{
+    ow_ovsdb_sta_set_info(info->mac_addr, info);
+}
+
+static void
+ow_ovsdb_sta_disconnected_cb(struct osw_state_observer *self,
+                             const struct osw_state_sta_info *info)
+{
+    ow_ovsdb_sta_set_info(info->mac_addr, info);
+}
+
+static struct osw_state_observer g_ow_ovsdb_osw_state_obs = {
+    .name = "ow_ovsdb",
+    .phy_added_fn = ow_ovsdb_phy_added_cb,
+    .phy_changed_fn = ow_ovsdb_phy_changed_cb,
+    .phy_removed_fn = ow_ovsdb_phy_removed_cb,
+    .vif_added_fn = ow_ovsdb_vif_added_cb,
+    .vif_changed_fn = ow_ovsdb_vif_changed_cb,
+    .vif_removed_fn = ow_ovsdb_vif_removed_cb,
+    .sta_connected_fn = ow_ovsdb_sta_connected_cb,
+    .sta_changed_fn = ow_ovsdb_sta_changed_cb,
+    .sta_disconnected_fn = ow_ovsdb_sta_disconnected_cb,
+};
+
+static void
+ow_ovsdb_link_phy_vif(void)
+{
+    ovsdb_cache_row_t *rrow;
+    ovsdb_cache_row_t *vrow;
+    int i;
+
+    /* FIXME: This could be optimized and moved to be called
+     * through async debounce, instead of being called back
+     * directly through callback_*().
+     */
+
+    ds_tree_foreach(&table_Wifi_VIF_Config.rows, vrow)
+        vrow->user_flags &= ~OW_OVSDB_VIF_FLAG_SEEN;
+
+    ds_tree_foreach(&table_Wifi_Radio_Config.rows, rrow) {
+        const struct schema_Wifi_Radio_Config *rconf = (const void *)rrow->record;
+        for (i = 0; i < rconf->vif_configs_len; i++) {
+            ovsdb_cache_row_t *vrow = ovsdb_cache_find_row_by_uuid(&table_Wifi_VIF_Config, rconf->vif_configs[i].uuid);
+            if (vrow == NULL) continue;
+            const struct schema_Wifi_VIF_Config *vconf = (const void *)vrow->record;
+            ow_conf_vif_set_phy_name(vconf->if_name, rconf->if_name);
+            vrow->user_flags |= OW_OVSDB_VIF_FLAG_SEEN;
+        }
+    }
+
+    ds_tree_foreach(&table_Wifi_VIF_Config.rows, vrow) {
+        const struct schema_Wifi_VIF_Config *vconf = (const void *)vrow->record;
+        if (vrow->user_flags & OW_OVSDB_VIF_FLAG_SEEN) continue;
+        ow_conf_vif_set_phy_name(vconf->if_name, NULL);
+    }
+}
+
+static void
+callback_Wifi_VIF_State(ovsdb_update_monitor_t *mon,
+                           struct schema_Wifi_VIF_State *old,
+                           struct schema_Wifi_VIF_State *rconf,
+                           ovsdb_cache_row_t *row)
+{
+    /* Nothing to do here. This is only needed to satisfy
+     * OVSDB_CACHE_MONITOR() and collect vstate cache for
+     * quick access at runtime.
+     */
+}
+
+static int
+ow_ovsdb_ch2freq(int band_num, int chan)
+{
+    switch (band_num) {
+        case 2: return 2407 + (chan * 5);
+        case 5: return 5000 + (chan * 5);
+        case 6: if (chan == 2) return 5935;
+                else return 5950 + (chan * 5);
+    }
+    return 0;
+}
+
+static int
+ow_ovsdb_band2num(const char *freq_band)
+{
+    return strcmp(freq_band, "5G") == 0 ? 5 :
+           strcmp(freq_band, "5GL") == 0 ? 5 :
+           strcmp(freq_band, "5GU") == 0 ? 5 :
+           strcmp(freq_band, "6G") == 0 ? 6 :
+           2;
+}
+
+static enum osw_channel_width
+ow_ovsdb_htmode2width(const char *ht_mode)
+{
+    return strcmp(ht_mode, "HT20") == 0 ? OSW_CHANNEL_20MHZ :
+           strcmp(ht_mode, "HT40") == 0 ? OSW_CHANNEL_40MHZ :
+           strcmp(ht_mode, "HT80") == 0 ? OSW_CHANNEL_80MHZ :
+           strcmp(ht_mode, "HT160") == 0 ? OSW_CHANNEL_160MHZ :
+           OSW_CHANNEL_20MHZ;
+}
+
+static void
+ow_ovsdb_rconf_to_ow_conf(const struct schema_Wifi_Radio_Config *rconf,
+                          const bool is_new)
+{
+    if (is_new == true || rconf->enabled_changed == true) {
+        if (rconf->enabled_exists == true) {
+            ow_conf_phy_set_enabled(rconf->if_name, &rconf->enabled);
+        }
+        else {
+            ow_conf_phy_set_enabled(rconf->if_name, NULL);
+        }
+    }
+
+    if (is_new == true || rconf->tx_chainmask_changed == true) {
+        if (rconf->tx_chainmask_exists == true) {
+            ow_conf_phy_set_tx_chainmask(rconf->if_name, &rconf->tx_chainmask);
+        }
+        else {
+            ow_conf_phy_set_tx_chainmask(rconf->if_name, NULL);
+        }
+    }
+
+    if (is_new == true ||
+            rconf->channel_changed == true ||
+            rconf->ht_mode_changed == true ||
+            rconf->freq_band_changed == true) {
+        if (rconf->channel_exists == true &&
+                rconf->ht_mode_exists == true &&
+                rconf->freq_band_exists == true) {
+            const int band_num = ow_ovsdb_band2num(rconf->freq_band);
+            const int cn = rconf->channel;
+            const enum osw_channel_width w = ow_ovsdb_htmode2width(rconf->ht_mode);
+            const struct osw_channel c = {
+                .control_freq_mhz = ow_ovsdb_ch2freq(band_num, cn),
+                .center_freq0_mhz = 0, /* let osw_confsync compute it */
+                .width = w,
+            };
+            ow_conf_phy_set_ap_channel(rconf->if_name, &c);
+        }
+        else {
+            ow_conf_phy_set_ap_channel(rconf->if_name, NULL);
+        }
+    }
+
+    if (is_new == true || rconf->bcn_int_changed == true) {
+        if (rconf->bcn_int_exists == true) {
+            ow_conf_phy_set_ap_beacon_interval_tu(rconf->if_name, &rconf->bcn_int);
+        }
+        else {
+            ow_conf_phy_set_ap_beacon_interval_tu(rconf->if_name, NULL);
+        }
+    }
+
+    if (is_new == true || rconf->hw_mode_changed == true) {
+        if (rconf->hw_mode_exists == true) {
+            bool ht = false;
+            bool vht = false;
+            bool he = false;
+
+            if (strcmp(rconf->hw_mode, "11ax") == 0) {
+                he = true;
+                if (strcmp(rconf->freq_band, "6G") != 0) {
+                    vht = true;
+                    ht = true;
+                }
+            }
+            else if (strcmp(rconf->hw_mode, "11ac") == 0) {
+                /* FIXME: Technically 11ac is not allowed on 2.4G except
+                 * vendor extensions.
+                 */
+                vht = true;
+                ht = true;
+            }
+            else if (strcmp(rconf->hw_mode, "11n") == 0) {
+                ht = true;
+            }
+
+            ow_conf_phy_set_ap_ht_enabled(rconf->if_name, &ht);
+            ow_conf_phy_set_ap_vht_enabled(rconf->if_name, &vht);
+            ow_conf_phy_set_ap_he_enabled(rconf->if_name, &he);
+        }
+        else {
+            ow_conf_phy_set_ap_ht_enabled(rconf->if_name, NULL);
+            ow_conf_phy_set_ap_vht_enabled(rconf->if_name, NULL);
+            ow_conf_phy_set_ap_he_enabled(rconf->if_name, NULL);
+        }
+    }
+}
+
+static void
+callback_Wifi_Radio_Config(ovsdb_update_monitor_t *mon,
+                           struct schema_Wifi_Radio_Config *old,
+                           struct schema_Wifi_Radio_Config *rconf,
+                           ovsdb_cache_row_t *row)
+{
+    const bool is_new = (mon->mon_type == OVSDB_UPDATE_NEW);
+    LOGI("ow: ovsdb: radio config: %s: %s",
+         rconf->if_name,
+         (mon->mon_type == OVSDB_UPDATE_NEW ? "new" :
+          mon->mon_type == OVSDB_UPDATE_MODIFY ? "modify" :
+          mon->mon_type == OVSDB_UPDATE_DEL ? "del" :
+          mon->mon_type == OVSDB_UPDATE_ERROR ? "error" :
+          ""));
+
+    switch (mon->mon_type) {
+        case OVSDB_UPDATE_NEW:
+        case OVSDB_UPDATE_MODIFY:
+            ow_ovsdb_rconf_to_ow_conf(rconf, is_new);
+            ow_ovsdb_phy_set_config(rconf->if_name, rconf);
+            break;
+        case OVSDB_UPDATE_DEL:
+            ow_conf_phy_unset(rconf->if_name);
+            ow_ovsdb_phy_set_config(rconf->if_name, NULL);
+            break;
+        case OVSDB_UPDATE_ERROR:
+            break;
+    }
+
+    ow_ovsdb_link_phy_vif();
+}
+
+static void
+ow_ovsdb_vstate_fix_vif_config(struct schema_Wifi_VIF_Config *vconf)
+{
+    struct schema_Wifi_VIF_State vstate = {0};
+    vstate._partial_update = true;
+    SCHEMA_SET_STR(vstate.if_name, vconf->if_name);
+    SCHEMA_SET_UUID(vstate.vif_config, vconf->_uuid.uuid);
+    ovsdb_table_update(&table_Wifi_VIF_State, &vstate);
+}
+
+static void
+ow_ovsdb_vconf_to_ow_conf_ap_wpa(const struct schema_Wifi_VIF_Config *vconf)
+{
+    if (vconf->wpa_exists == true) {
+        if (vconf->wpa == true) {
+            WARN_ON(vconf->security_len > 0);
+            int i;
+            bool t = true;
+            bool need_11w = false;
+            bool non_11w = false;
+            enum osw_pmf pmf;
+
+            for (i = 0; i < vconf->wpa_key_mgmt_len; i++) {
+                const char *akm = vconf->wpa_key_mgmt[i];
+                if (strcmp(akm, "wpa-psk") == 0) {
+                    ow_conf_vif_set_ap_wpa(vconf->if_name, &t);
+                    ow_conf_vif_set_ap_akm_psk(vconf->if_name, &t);
+                    ow_conf_vif_set_ap_pairwise_tkip(vconf->if_name, &t);
+                    non_11w = true;
+                }
+                else if (strcmp(akm, "wpa2-psk") == 0) {
+                    ow_conf_vif_set_ap_rsn(vconf->if_name, &t);
+                    ow_conf_vif_set_ap_akm_psk(vconf->if_name, &t);
+                    ow_conf_vif_set_ap_pairwise_ccmp(vconf->if_name, &t);
+                    non_11w = true;
+                }
+                else if (strcmp(akm, "sae") == 0) {
+                    ow_conf_vif_set_ap_rsn(vconf->if_name, &t);
+                    ow_conf_vif_set_ap_akm_sae(vconf->if_name, &t);
+                    ow_conf_vif_set_ap_pairwise_ccmp(vconf->if_name, &t);
+                    need_11w = true;
+                }
+
+                if (strstr(akm, "ft-wpa") != NULL) {
+                    ow_conf_vif_set_ap_akm_ft_psk(vconf->if_name, &t);
+                }
+                if (strstr(akm, "ft-sae") != NULL) {
+                    ow_conf_vif_set_ap_akm_ft_sae(vconf->if_name, &t);
+                }
+            }
+
+            if (need_11w == false)
+                pmf = OSW_PMF_DISABLED;
+            else if (non_11w == true)
+                pmf = OSW_PMF_OPTIONAL;
+            else
+                pmf = OSW_PMF_REQUIRED;
+
+            ow_conf_vif_set_ap_pmf(vconf->if_name, &pmf);
+            return;
+        }
+    }
+    else if (vconf->security_len > 0) {
+        const char *enc = SCHEMA_KEY_VAL_NULL(vconf->security, "encryption");
+        const bool t = true;
+        const bool f = false;
+        const enum osw_pmf pmf = OSW_PMF_DISABLED;
+
+        ow_conf_vif_flush_ap_psk(vconf->if_name);
+
+        if (strcmp(enc, "WPA-PSK") == 0) {
+            const char *mode = SCHEMA_KEY_VAL_NULL(vconf->security, "mode");
+
+            if (mode == NULL) {
+                LOGI("ow: ovsdb: vif: %s: mode undefined, implying 3",
+                     vconf->if_name);
+                mode = "3";
+            }
+
+            if (strcmp(mode, "mixed") == 0) {
+                LOGD("ow: ovsdb: vif: %s: mode mixed, implying 3",
+                     vconf->if_name);
+                mode = "3";
+            }
+
+            int mask = atoi(mode);
+            if (mask < 0 || mask > 3) {
+                LOGI("ow: ovsdb: vif: %s: invalid mode: %s, implying 3",
+                     vconf->if_name, mode);
+                mask = 3;
+            }
+
+            if (mask & 1) {
+                ow_conf_vif_set_ap_wpa(vconf->if_name, &t);
+                ow_conf_vif_set_ap_rsn(vconf->if_name, &f);
+                ow_conf_vif_set_ap_akm_psk(vconf->if_name, &t);
+                ow_conf_vif_set_ap_akm_sae(vconf->if_name, &f);
+                ow_conf_vif_set_ap_akm_ft_psk(vconf->if_name, &f);
+                ow_conf_vif_set_ap_akm_ft_sae(vconf->if_name, &f);
+                ow_conf_vif_set_ap_pairwise_tkip(vconf->if_name, &t);
+                ow_conf_vif_set_ap_pairwise_ccmp(vconf->if_name, &f);
+                ow_conf_vif_set_ap_pmf(vconf->if_name, &pmf);
+            }
+
+            if (mask & 2) {
+                ow_conf_vif_set_ap_wpa(vconf->if_name, &f);
+                ow_conf_vif_set_ap_rsn(vconf->if_name, &t);
+                ow_conf_vif_set_ap_akm_psk(vconf->if_name, &t);
+                ow_conf_vif_set_ap_akm_sae(vconf->if_name, &f);
+                ow_conf_vif_set_ap_akm_ft_psk(vconf->if_name, &f);
+                ow_conf_vif_set_ap_akm_ft_sae(vconf->if_name, &f);
+                ow_conf_vif_set_ap_pairwise_tkip(vconf->if_name, &f);
+                ow_conf_vif_set_ap_pairwise_ccmp(vconf->if_name, &t);
+                ow_conf_vif_set_ap_pmf(vconf->if_name, &pmf);
+            }
+
+            if (vconf->ft_psk_exists) {
+                bool x = vconf->ft_psk;
+                ow_conf_vif_set_ap_akm_ft_psk(vconf->if_name, &x);
+            }
+
+            int i;
+            for (i = 0; i < vconf->security_len; i++) {
+                const char *k = vconf->security_keys[i];
+                const char *psk = vconf->security[i];
+                if (strstr(k, "key") != k) continue;
+
+                int key_id;
+                if (sscanf(k, "key-%d", &key_id) != 1)
+                    key_id = 0;
+
+                ow_conf_vif_set_ap_psk(vconf->if_name, key_id, psk);
+                // FIXME: lookup oftag, and do something about it?
+            }
+
+            return;
+        }
+    }
+
+    ow_conf_vif_set_ap_akm_ft_psk(vconf->if_name, NULL);
+    ow_conf_vif_set_ap_akm_ft_sae(vconf->if_name, NULL);
+    ow_conf_vif_set_ap_akm_psk(vconf->if_name, NULL);
+    ow_conf_vif_set_ap_akm_sae(vconf->if_name, NULL);
+    ow_conf_vif_set_ap_pairwise_ccmp(vconf->if_name, NULL);
+    ow_conf_vif_set_ap_pairwise_tkip(vconf->if_name, NULL);
+    ow_conf_vif_set_ap_pmf(vconf->if_name, NULL);
+    ow_conf_vif_set_ap_rsn(vconf->if_name, NULL);
+    ow_conf_vif_set_ap_wpa(vconf->if_name, NULL);
+}
+
+static void
+ow_ovsdb_vconf_to_ow_conf_ap(const struct schema_Wifi_VIF_Config *vconf,
+                             const bool is_new)
+{
+    if (is_new == true || vconf->ssid_changed == true) {
+        if (vconf->ssid_exists == true) {
+            struct osw_ssid x = {0};
+            STRSCPY_WARN(x.buf, vconf->ssid);
+            x.len = strlen(x.buf);
+            ow_conf_vif_set_ap_ssid(vconf->if_name, &x);
+        }
+        else {
+            ow_conf_vif_set_ap_ssid(vconf->if_name, NULL);
+        }
+    }
+
+    if (is_new == true || vconf->ssid_broadcast_changed == true) {
+        if (vconf->ssid_broadcast_exists == true) {
+            bool x =
+                strcmp(vconf->ssid_broadcast, "enabled") == 0 ? false :
+                strcmp(vconf->ssid_broadcast, "disabled") == 0 ? true :
+                false;
+            ow_conf_vif_set_ap_ssid_hidden(vconf->if_name, &x);
+        }
+        else {
+            ow_conf_vif_set_ap_ssid_hidden(vconf->if_name, NULL);
+        }
+    }
+
+    if (is_new == true || vconf->bridge_changed == true) {
+        if (vconf->bridge_exists == true && strlen(vconf->bridge) > 0) {
+            struct osw_ifname x = {0};
+            STRSCPY_WARN(x.buf, vconf->bridge);
+            ow_conf_vif_set_ap_bridge_if_name(vconf->if_name, &x);
+        } else {
+            ow_conf_vif_set_ap_bridge_if_name(vconf->if_name, NULL);
+        }
+    }
+
+    if (is_new == true || vconf->mac_list_changed == true) {
+        ow_conf_vif_flush_ap_acl(vconf->if_name);
+        int i;
+        for (i = 0; i < vconf->mac_list_len; i++) {
+            struct osw_hwaddr addr;
+            sscanf(vconf->mac_list[i], OSW_HWADDR_FMT, OSW_HWADDR_SARG(&addr));
+            ow_conf_vif_add_ap_acl(vconf->if_name, &addr);
+        }
+    }
+
+    if (is_new == true || vconf->wpa_psks_changed == true) {
+        ow_conf_vif_flush_ap_psk(vconf->if_name);
+        int i;
+        for (i = 0; i < vconf->wpa_psks_len; i++) {
+            int key_id = ow_ovsdb_str2keyid(vconf->wpa_psks_keys[i]);
+            const char *psk = vconf->wpa_psks[i];
+            ow_conf_vif_set_ap_psk(vconf->if_name, key_id, psk);
+        }
+    }
+
+    if (is_new == true || vconf->mac_list_type_changed == true) {
+        if (vconf->mac_list_type_exists == true) {
+            const char *t = vconf->mac_list_type;
+            enum osw_acl_policy p = ow_ovsdb_acl_policy_from_str(t);
+            ow_conf_vif_set_ap_acl_policy(vconf->if_name, &p);
+        }
+        else {
+            ow_conf_vif_set_ap_acl_policy(vconf->if_name, NULL);
+        }
+    }
+
+    if (is_new == true || vconf->uapsd_enable_changed == true) {
+        if (vconf->uapsd_enable_exists == true) {
+            bool x = vconf->uapsd_enable;
+            bool y = true;
+            ow_conf_vif_set_ap_wmm_uapsd(vconf->if_name, &x);
+            ow_conf_vif_set_ap_wmm(vconf->if_name, &y);
+        }
+        else {
+            ow_conf_vif_set_ap_wmm_uapsd(vconf->if_name, NULL);
+            ow_conf_vif_set_ap_wmm(vconf->if_name, NULL);
+        }
+    }
+
+    if (is_new == true || vconf->rrm_changed == true) {
+        if (vconf->rrm_exists == true) {
+            bool x = vconf->rrm;
+            ow_conf_vif_set_ap_rrm_neighbor_report(vconf->if_name, &x);
+        }
+        else {
+            ow_conf_vif_set_ap_rrm_neighbor_report(vconf->if_name, NULL);
+        }
+    }
+
+    if (is_new == true || vconf->btm_changed == true) {
+        if (vconf->btm_exists == true) {
+            bool x = vconf->btm;
+            ow_conf_vif_set_ap_wnm_bss_trans(vconf->if_name, &x);
+        }
+        else {
+            ow_conf_vif_set_ap_wnm_bss_trans(vconf->if_name, NULL);
+        }
+    }
+
+    if (is_new == true || vconf->mcast2ucast_changed == true) {
+        if (vconf->mcast2ucast_exists == true) {
+            bool x = vconf->mcast2ucast;
+            ow_conf_vif_set_ap_mcast2ucast(vconf->if_name, &x);
+        }
+        else {
+            ow_conf_vif_set_ap_mcast2ucast(vconf->if_name, NULL);
+        }
+    }
+
+    if (is_new == true || vconf->group_rekey_changed == true) {
+        if (vconf->group_rekey_exists == true) {
+            int x = vconf->group_rekey;
+            ow_conf_vif_set_ap_group_rekey_seconds(vconf->if_name, &x);
+        }
+        else {
+            ow_conf_vif_set_ap_group_rekey_seconds(vconf->if_name, NULL);
+        }
+    }
+
+    if (is_new == true || vconf->ap_bridge_changed == true) {
+        if (vconf->ap_bridge_exists == true) {
+            bool x = vconf->ap_bridge ? false : true;
+            ow_conf_vif_set_ap_isolated(vconf->if_name, &x);
+        }
+        else {
+            ow_conf_vif_set_ap_isolated(vconf->if_name, NULL);
+        }
+    }
+
+    if (is_new == true || vconf->ft_mobility_domain_changed == true) {
+        if (vconf->ft_mobility_domain_exists == true) {
+            int x = vconf->ft_mobility_domain;
+            ow_conf_vif_set_ap_ft_mobility_domain(vconf->if_name, &x);
+        }
+        else {
+            ow_conf_vif_set_ap_ft_mobility_domain(vconf->if_name, NULL);
+        }
+    }
+
+    if (is_new == true || vconf->wpa_changed == true || vconf->security_changed == true)
+        ow_ovsdb_vconf_to_ow_conf_ap_wpa(vconf);
+
+    // wps_pbc
+    // multiap
+    // dynamic beacon
+    // vlan_id
+    // min_hw_mode
+    // parent
+    // vif_radio_idx
+    // vif_dbg_lvl
+    // wds
+}
+
+static void
+ow_ovsdb_vconf_to_ow_conf(const struct schema_Wifi_VIF_Config *vconf,
+                          const bool is_new)
+{
+    enum osw_vif_type type = ow_ovsdb_mode_to_type(vconf->mode);
+
+    if (is_new == true || vconf->enabled_changed == true) {
+        if (vconf->enabled_exists == true) {
+            bool x = vconf->enabled;
+            ow_conf_vif_set_enabled(vconf->if_name, &x);
+        }
+        else {
+            ow_conf_vif_set_enabled(vconf->if_name, NULL);
+        }
+    }
+
+    if (is_new == true || vconf->mode_changed == true) {
+        if (vconf->mode_exists == true) {
+            ow_conf_vif_set_type(vconf->if_name, &type);
+        }
+        else {
+            ow_conf_vif_set_type(vconf->if_name, NULL);
+        }
+    }
+
+    switch (type) {
+        case OSW_VIF_UNDEFINED:
+            break;
+        case OSW_VIF_AP:
+            ow_ovsdb_vconf_to_ow_conf_ap(vconf, is_new);
+            break;
+        case OSW_VIF_AP_VLAN:
+            break;
+        case OSW_VIF_STA:
+            break;
+    }
+}
+
+static void
+callback_Wifi_VIF_Config(ovsdb_update_monitor_t *mon,
+                         struct schema_Wifi_VIF_Config *old,
+                         struct schema_Wifi_VIF_Config *vconf,
+                         ovsdb_cache_row_t *row)
+{
+    const bool is_new = (mon->mon_type == OVSDB_UPDATE_NEW);
+    LOGI("ow: ovsdb: vif config: %s: %s",
+         vconf->if_name,
+         (mon->mon_type == OVSDB_UPDATE_NEW ? "new" :
+          mon->mon_type == OVSDB_UPDATE_MODIFY ? "modify" :
+          mon->mon_type == OVSDB_UPDATE_DEL ? "del" :
+          mon->mon_type == OVSDB_UPDATE_ERROR ? "error" :
+          ""));
+
+    if (strcmp(vconf->mode, "ap")) return; /* only AP is supported for now */
+
+    switch (mon->mon_type) {
+        case OVSDB_UPDATE_NEW:
+            ow_ovsdb_vstate_fix_vif_config(vconf);
+            /* fall through */
+        case OVSDB_UPDATE_MODIFY:
+            ow_ovsdb_vconf_to_ow_conf(vconf, is_new);
+            ow_ovsdb_vif_set_config(vconf->if_name, vconf);
+            break;
+        case OVSDB_UPDATE_DEL:
+            ow_conf_vif_unset(vconf->if_name);
+            ow_ovsdb_vif_set_config(vconf->if_name, NULL);
+            break;
+        case OVSDB_UPDATE_ERROR:
+            break;
+    }
+
+    ow_ovsdb_link_phy_vif();
+}
+
+static struct ev_timer g_ow_ovsdb_retry;
+
+static void
+ow_ovsdb_flush(void)
+{
+    /* FIXME: This shouldn't be necessary. The code should actually sync not
+     * only rows, but also (non)existance of rows. One idea would be to employ
+     * ovsdb ping and/or ev_idle (to allow real ovsdb transactions to be
+     * delivered to the process) and then - based on what rows are reported -
+     * remove those that shouldn't be there.
+     *
+     * With this the controller will see a blip whenever this module (and
+     * typically the process) is restarted.
+     */
+    ovsdb_table_delete_where(&table_Wifi_Associated_Clients, NULL);
+    ovsdb_table_delete_where(&table_Wifi_Radio_State, NULL);
+    ovsdb_table_delete_where(&table_Wifi_VIF_State, NULL);
+}
+
+static void
+ow_ovsdb_retry_cb(EV_P_ ev_timer *arg, int events)
+{
+    if (ovsdb_init_loop(EV_A_ "OW") == false) {
+        LOGI("ow: ovsdb: failed to connect, will retry later");
+        return;
+    }
+
+    OVSDB_CACHE_MONITOR(Wifi_Radio_Config, true);
+    OVSDB_CACHE_MONITOR(Wifi_VIF_Config, true);
+    OVSDB_CACHE_MONITOR(Wifi_VIF_State, true);
+
+    ow_ovsdb_ms_init(&g_ow_ovsdb.ms);
+    ow_ovsdb_steer_init(&g_ow_ovsdb.steering);
+    ow_ovsdb_flush();
+    osw_state_register_observer(&g_ow_ovsdb_osw_state_obs);
+    ev_timer_stop(EV_A_ arg);
+
+    LOGI("ow: ovsdb: ready");
+}
+
+void
+ow_ovsdb_init(struct ow_bus_ops *ops)
+{
+    static bool initialized;
+
+    if (initialized == true) return;
+
+    OVSDB_TABLE_INIT(Wifi_Radio_Config, if_name);
+    OVSDB_TABLE_INIT(Wifi_Radio_State, if_name);
+    OVSDB_TABLE_INIT(Wifi_VIF_Config, if_name);
+    OVSDB_TABLE_INIT(Wifi_VIF_State, if_name);
+    OVSDB_TABLE_INIT(Wifi_Credential_Config, _uuid);
+    OVSDB_TABLE_INIT(Wifi_Associated_Clients, mac);
+    OVSDB_TABLE_INIT(Openflow_Tag, name);
+
+    ev_timer_init(&g_ow_ovsdb_retry, ow_ovsdb_retry_cb, 0, OW_OVSDB_RETRY_SECONDS);
+    ev_timer_start(EV_DEFAULT_ &g_ow_ovsdb_retry);
+
+    initialized = true;
+}
+
+static bool
+ow_ovsdb_enabled(void)
+{
+    if (getenv("OW_OVSDB_DISABLED") == NULL)
+        return true;
+    else
+        return false;
+}
+
+static void
+ow_ovsdb_module_init(void *arg)
+{
+    static struct ow_bus_ops ops = {
+        .name = "ovsdb",
+        .init_fn = ow_ovsdb_init,
+    };
+
+    if (ow_ovsdb_enabled() == false) {
+        LOGI("ow: ovsdb: disabled");
+        return;
+    }
+
+    ow_bus_register_ops(&ops);
+}
+
+static void
+ow_ovsdb_module_fini(void *arg)
+{
+}
+
+MODULE(ow_ovsdb_module,
+       ow_ovsdb_module_init,
+       ow_ovsdb_module_fini);
+
+struct ow_ovsdb_ut {
+    ev_async async;
+};
+
+static void
+ow_ovsdb_ut_async_cb(EV_P_ ev_async *arg, int events)
+{
+}
+
+static void
+ow_ovsdb_ut_echo_cb(int id, bool is_error, json_t *js, void *data)
+{
+    struct ow_ovsdb_ut *ut = data;
+    ev_async_stop(EV_DEFAULT_ &ut->async);
+    ev_unref(EV_DEFAULT);
+}
+
+static void
+ow_ovsdb_ut_idle_cb(EV_P_ ev_idle *idle, int events)
+{
+    ev_idle_stop(EV_A_ idle);
+}
+
+static void
+ow_ovsdb_ut_run(void)
+{
+    struct ow_ovsdb_ut ut;
+    char *argv[] = { "ow_ovsdb" };
+    struct ev_idle idle;
+
+    ev_idle_init(&idle, ow_ovsdb_ut_idle_cb);
+    ev_async_init(&ut.async, ow_ovsdb_ut_async_cb);
+
+    ev_idle_start(EV_DEFAULT_ &idle);
+    ev_unref(EV_DEFAULT);
+    ev_run(EV_DEFAULT_ 0);
+    ev_ref(EV_DEFAULT);
+
+    assert(ovsdb_echo_call_argv(ow_ovsdb_ut_echo_cb, &ut, 1, argv) == true);
+    ev_run(EV_DEFAULT_ 0);
+
+    ev_idle_start(EV_DEFAULT_ &idle);
+    ev_run(EV_DEFAULT_ 0);
+
+    ev_ref(EV_DEFAULT);
+    assert(ow_conf_is_settled() == true);
+}
+
+static void
+ow_ovsdb_ut_init(void)
+{
+    osw_init();
+    ow_conf_init();
+    ow_ovsdb_init(NULL);
+    while (ev_is_active(&g_ow_ovsdb_retry))
+        ev_run(EV_DEFAULT_ EVRUN_ONCE);
+
+    ovsdb_table_delete_where(&table_Wifi_Radio_Config, NULL);
+    ovsdb_table_delete_where(&table_Wifi_VIF_Config, NULL);
+    ovsdb_table_delete_where(&table_Wifi_Radio_State, NULL);
+    ovsdb_table_delete_where(&table_Wifi_VIF_State, NULL);
+    ovsdb_table_delete_where(&table_Wifi_Associated_Clients, NULL);
+    ovsdb_table_delete_where(&table_Openflow_Tag, NULL);
+    ow_ovsdb_ut_run();
+}
+
+static void
+ow_ovsdb_ut_rconf_cb(void *arg)
+{
+    const char *phy_name = "phy1";
+    struct schema_Wifi_Radio_Config rconf = {0};
+    SCHEMA_SET_STR(rconf.if_name, phy_name);
+    SCHEMA_SET_STR(rconf.freq_band, "2.4G");
+    SCHEMA_SET_BOOL(rconf.enabled, true);
+    /* tx_chainmask is left unset */
+
+    ow_ovsdb_ut_init();
+    ovsdb_table_insert(&table_Wifi_Radio_Config, &rconf);
+    ow_ovsdb_ut_run();
+
+    assert(ow_conf_phy_is_set(phy_name) == true);
+    assert(ow_conf_phy_get_enabled(phy_name) != NULL);
+    assert(ow_conf_phy_get_tx_chainmask(phy_name) == NULL);
+    assert(*ow_conf_phy_get_enabled(phy_name) == rconf.enabled);
+
+    ovsdb_table_delete(&table_Wifi_Radio_Config, &rconf);
+    ow_ovsdb_ut_run();
+    assert(ow_conf_phy_is_set(phy_name) == false);
+}
+
+static void
+ow_ovsdb_ut_vconf_cb(void *arg)
+{
+    const char *phy_name = "phy1";
+    struct schema_Wifi_Radio_Config rconf = {0};
+    SCHEMA_SET_STR(rconf.if_name, phy_name);
+    SCHEMA_SET_STR(rconf.freq_band, "2.4G");
+    SCHEMA_SET_BOOL(rconf.enabled, true);
+
+    const char *vif_name = "vif1";
+    const bool update_uuid = true;
+    struct schema_Wifi_VIF_Config vconf = {0};
+    void *filter = NULL;
+    SCHEMA_SET_STR(vconf.if_name, vif_name);
+    SCHEMA_SET_BOOL(vconf.enabled, true);
+    SCHEMA_SET_STR(vconf.ssid, "hello_ssid");
+    SCHEMA_SET_STR(vconf.mode, "ap");
+
+    ow_ovsdb_ut_init();
+    json_t *where = ovsdb_where_simple(SCHEMA_COLUMN(Wifi_Radio_Config, if_name),
+                                       phy_name);
+    assert(where != NULL);
+    ovsdb_table_insert(&table_Wifi_Radio_Config, &rconf);
+    ovsdb_table_upsert_with_parent(&table_Wifi_VIF_Config,
+                                   &vconf,
+                                   update_uuid,
+                                   filter,
+                                   SCHEMA_TABLE(Wifi_Radio_Config),
+                                   where,
+                                   SCHEMA_COLUMN(Wifi_Radio_Config, vif_configs));
+    ow_ovsdb_ut_run();
+
+    assert(ow_conf_phy_is_set(phy_name) == true);
+    assert(ow_conf_vif_is_set(vif_name) == true);
+    assert(ow_conf_vif_get_phy_name(vif_name) != NULL);
+    assert(strcmp(ow_conf_vif_get_phy_name(vif_name), phy_name) == 0);
+    assert(ow_conf_vif_get_enabled(vif_name) != NULL);
+    assert(ow_conf_vif_get_ap_ssid(vif_name) != NULL);
+    assert(strcmp(ow_conf_vif_get_ap_ssid(vif_name)->buf, vconf.ssid) == 0);
+
+    ovsdb_table_delete(&table_Wifi_Radio_Config, &rconf);
+    ow_ovsdb_ut_run();
+
+    assert(ow_conf_phy_is_set(phy_name) == false);
+    assert(ow_conf_vif_is_set(vif_name) == true);
+    assert(ow_conf_vif_get_phy_name(vif_name) == NULL);
+
+    rconf.vif_configs_len = 1;
+    STRSCPY_WARN(rconf.vif_configs[0].uuid, vconf._uuid.uuid);
+    ovsdb_table_insert(&table_Wifi_Radio_Config, &rconf);
+    ow_ovsdb_ut_run();
+    assert(ow_conf_phy_is_set(phy_name) == true);
+    assert(ow_conf_vif_is_set(vif_name) == true);
+    assert(ow_conf_vif_get_phy_name(vif_name) != NULL);
+    assert(strcmp(ow_conf_vif_get_phy_name(vif_name), phy_name) == 0);
+}
+
+static void
+ow_ovsdb_ut_rstate_cb(void *arg)
+{
+    struct schema_Wifi_Radio_State rstate = {0};
+    const struct osw_state_phy_info phy = {
+        .phy_name = "phy1",
+        .drv_state = (const struct osw_drv_phy_state []){{
+            .exists = true,
+            .enabled = true,
+            .tx_chainmask = 0x0f,
+        }}
+    };
+
+    ow_ovsdb_ut_init();
+    ow_ovsdb_phy_added_cb(NULL, &phy);
+    ow_ovsdb_ut_run();
+    ow_ovsdb_get_rstate(&rstate, phy.phy_name);
+
+    assert(rstate.enabled_exists == true);
+    assert(rstate.enabled == phy.drv_state->enabled);
+    assert(rstate.tx_chainmask_exists == true);
+    assert(rstate.tx_chainmask == phy.drv_state->tx_chainmask);
+}
+
+static void
+ow_ovsdb_ut_rstate_bcn_int_cb(void *arg)
+{
+    struct schema_Wifi_Radio_State rstate = {0};
+    const struct osw_state_phy_info phy = {
+        .phy_name = "phy1",
+        .drv_state = (const struct osw_drv_phy_state []){{
+            .exists = true,
+            .enabled = true,
+        }}
+    };
+    const struct osw_state_vif_info vif1_100 = {
+        .phy = &phy,
+        .vif_name = "vif1",
+        .drv_state = (const struct osw_drv_vif_state []){{
+            .exists = true,
+            .enabled = true,
+            .vif_type = OSW_VIF_AP,
+            .u = { .ap = { .beacon_interval_tu = 100 } },
+        }}
+    };
+    const struct osw_state_vif_info vif1_200 = {
+        .phy = &phy,
+        .vif_name = "vif1",
+        .drv_state = (const struct osw_drv_vif_state []){{
+            .exists = true,
+            .enabled = true,
+            .vif_type = OSW_VIF_AP,
+            .u = { .ap = { .beacon_interval_tu = 200 } },
+        }}
+    };
+    const struct osw_state_vif_info vif2 = {
+        .phy = &phy,
+        .vif_name = "vif2",
+        .drv_state = (const struct osw_drv_vif_state []){{
+            .exists = true,
+            .enabled = true,
+            .vif_type = OSW_VIF_AP,
+            .u = { .ap = { .beacon_interval_tu = 200 } },
+        }}
+    };
+    struct osw_drv_dummy dummy = {
+        .name = "rstate",
+    };
+    struct schema_Wifi_VIF_Config vconf1 = {0};
+    struct schema_Wifi_VIF_Config vconf2 = {0};
+
+    SCHEMA_SET_STR(vconf1.if_name, vif1_100.vif_name);
+    SCHEMA_SET_STR(vconf2.if_name, vif2.vif_name);
+
+    osw_init();
+    osw_drv_dummy_init(&dummy);
+
+    ow_ovsdb_ut_init();
+    osw_drv_dummy_set_phy(&dummy, phy.phy_name, (void *)phy.drv_state);
+    ow_ovsdb_ut_run();
+    ow_ovsdb_get_rstate(&rstate, phy.phy_name);
+    assert(rstate.enabled_exists == true);
+    assert(rstate.enabled == phy.drv_state->enabled);
+
+    ow_ovsdb_vif_set_config(vconf1.if_name, &vconf1);
+    osw_drv_dummy_set_vif(&dummy, phy.phy_name, vif1_100.vif_name, (void *)vif1_100.drv_state);
+    ow_ovsdb_ut_run();
+    assert(osw_state_vif_lookup(phy.phy_name, vif1_100.vif_name) != NULL);
+    ow_ovsdb_get_rstate(&rstate, phy.phy_name);
+    assert(rstate.bcn_int_exists == true);
+    assert(rstate.bcn_int == vif1_100.drv_state->u.ap.beacon_interval_tu);
+
+    ow_ovsdb_vif_set_config(vconf2.if_name, &vconf2);
+    osw_drv_dummy_set_vif(&dummy, phy.phy_name, vif2.vif_name, (void *)vif2.drv_state);
+    ow_ovsdb_ut_run();
+    ow_ovsdb_get_rstate(&rstate, phy.phy_name);
+    assert(rstate.bcn_int_exists == false);
+
+    osw_drv_dummy_set_vif(&dummy, phy.phy_name, vif1_200.vif_name, (void *)vif1_200.drv_state);
+    ow_ovsdb_ut_run();
+    ow_ovsdb_get_rstate(&rstate, phy.phy_name);
+    assert(rstate.bcn_int_exists == true);
+    assert(rstate.bcn_int == vif1_200.drv_state->u.ap.beacon_interval_tu);
+}
+
+static void
+ow_ovsdb_ut_vstate_cb(void *arg)
+{
+    struct schema_Wifi_Radio_State rstate = {0};
+    struct schema_Wifi_VIF_State vstate = {0};
+    const struct osw_state_phy_info phy = {
+        .phy_name = "phy1",
+        .drv_state = (const struct osw_drv_phy_state []){{
+            .exists = true,
+            .enabled = true,
+        }}
+    };
+    const struct osw_state_vif_info vif = {
+        .phy = &phy,
+        .vif_name = "vif1",
+        .drv_state = (const struct osw_drv_vif_state []){{
+            .exists = true,
+            .enabled = true,
+            .vif_type = OSW_VIF_AP,
+            .u = { .ap = { .ssid = { .buf = "ssid123", .len = 7 } } },
+        }}
+    };
+    struct schema_Wifi_VIF_Config vconf = {0};
+
+    SCHEMA_SET_STR(vconf.if_name, vif.vif_name);
+
+    ow_ovsdb_ut_init();
+    ow_ovsdb_phy_added_cb(NULL, &phy);
+    ow_ovsdb_vif_added_cb(NULL, &vif);
+    ow_ovsdb_vif_set_config(vif.vif_name, &vconf);
+    ow_ovsdb_ut_run();
+    ow_ovsdb_get_rstate(&rstate, phy.phy_name);
+    ow_ovsdb_get_vstate(&vstate, vif.vif_name);
+
+    assert(vstate.enabled_exists == true);
+    assert(vstate.enabled == vif.drv_state->enabled);
+    assert(vstate.ssid_exists == true);
+    assert(strcmp(vstate.ssid, vif.drv_state->u.ap.ssid.buf) == 0);
+    assert(rstate.vif_states_len == 1);
+    assert(strcmp(rstate.vif_states[0].uuid, vstate._uuid.uuid) == 0);
+
+    assert(vstate.vif_config_exists == false);
+
+    struct schema_Wifi_Radio_Config rconf = {0};
+    SCHEMA_SET_STR(rconf.if_name, phy.phy_name);
+    SCHEMA_SET_STR(rconf.freq_band, "2.4G");
+    SCHEMA_SET_BOOL(rconf.enabled, phy.drv_state->enabled);
+
+    const bool update_uuid = false;
+    void *filter = NULL;
+    memset(&vconf, 0, sizeof(vconf));
+    SCHEMA_SET_STR(vconf.if_name, vif.vif_name);
+    SCHEMA_SET_BOOL(vconf.enabled, vif.drv_state->enabled);
+    SCHEMA_SET_STR(vconf.mode, "ap");
+    SCHEMA_SET_STR(vconf.ssid, vif.drv_state->u.ap.ssid.buf);
+
+    json_t *where = ovsdb_where_simple(SCHEMA_COLUMN(Wifi_Radio_Config, if_name),
+                                       phy.phy_name);
+    assert(where != NULL);
+    ovsdb_table_insert(&table_Wifi_Radio_Config, &rconf);
+    ovsdb_table_upsert_with_parent(&table_Wifi_VIF_Config,
+                                   &vconf,
+                                   update_uuid,
+                                   filter,
+                                   SCHEMA_TABLE(Wifi_Radio_Config),
+                                   where,
+                                   SCHEMA_COLUMN(Wifi_Radio_Config, vif_configs));
+
+    ow_ovsdb_ut_run();
+    ow_ovsdb_get_vstate(&vstate, vif.vif_name);
+    assert(vstate.vif_config_exists == true);
+    ow_ovsdb_vif_removed_cb(NULL, &vif);
+    ow_ovsdb_ut_run();
+    assert(ow_ovsdb_get_vstate(&vstate, vif.vif_name) == false);
+    ow_ovsdb_vif_added_cb(NULL, &vif);
+    ow_ovsdb_ut_run();
+    assert(ow_ovsdb_get_vstate(&vstate, vif.vif_name) == true);
+    assert(vstate.vif_config_exists == true);
+}
+
+static void
+ow_ovsdb_ut_rstate_channel_cb(void *arg)
+{
+    struct schema_Wifi_Radio_State rstate = {0};
+    const struct osw_state_phy_info phy = {
+        .phy_name = "phy1",
+        .drv_state = (const struct osw_drv_phy_state []){{
+            .exists = true,
+            .enabled = true,
+        }}
+    };
+    const struct osw_state_vif_info vif1_c1w20 = {
+        .phy = &phy,
+        .vif_name = "vif1",
+        .drv_state = (const struct osw_drv_vif_state []){{
+            .exists = true,
+            .enabled = true,
+            .vif_type = OSW_VIF_AP,
+            .u = { .ap = { .channel = { .control_freq_mhz = 2412, .width = OSW_CHANNEL_20MHZ} } },
+        }}
+    };
+    const struct osw_state_vif_info vif2_c1w20 = {
+        .phy = &phy,
+        .vif_name = "vif2",
+        .drv_state = (const struct osw_drv_vif_state []){{
+            .exists = true,
+            .enabled = true,
+            .vif_type = OSW_VIF_AP,
+            .u = { .ap = { .channel = { .control_freq_mhz = 2412, .width = OSW_CHANNEL_20MHZ} } },
+        }}
+    };
+    const struct osw_state_vif_info vif2_c6w20 = {
+        .phy = &phy,
+        .vif_name = "vif2",
+        .drv_state = (const struct osw_drv_vif_state []){{
+            .exists = true,
+            .enabled = true,
+            .vif_type = OSW_VIF_AP,
+            .u = { .ap = { .channel = { .control_freq_mhz = 2437, .width = OSW_CHANNEL_20MHZ} } },
+        }}
+    };
+    const struct osw_state_vif_info vif2_c1w40 = {
+        .phy = &phy,
+        .vif_name = "vif2",
+        .drv_state = (const struct osw_drv_vif_state []){{
+            .exists = true,
+            .enabled = true,
+            .vif_type = OSW_VIF_AP,
+            .u = { .ap = { .channel = { .control_freq_mhz = 2412, .width = OSW_CHANNEL_40MHZ} } },
+        }}
+    };
+    struct osw_drv_dummy dummy = {
+        .name = "rstate",
+    };
+    struct schema_Wifi_VIF_Config vconf1 = {0};
+    struct schema_Wifi_VIF_Config vconf2 = {0};
+
+    SCHEMA_SET_STR(vconf1.if_name, vif1_c1w20.vif_name);
+    SCHEMA_SET_STR(vconf2.if_name, vif2_c1w20.vif_name);
+
+    osw_init();
+    osw_drv_dummy_init(&dummy);
+
+    ow_ovsdb_ut_init();
+    osw_drv_dummy_set_phy(&dummy, phy.phy_name, (void *)phy.drv_state);
+    ow_ovsdb_ut_run();
+    ow_ovsdb_get_rstate(&rstate, phy.phy_name);
+    assert(rstate.enabled_exists == true);
+    assert(rstate.enabled == phy.drv_state->enabled);
+
+    ow_ovsdb_vif_set_config(vconf1.if_name, &vconf1);
+    osw_drv_dummy_set_vif(&dummy, phy.phy_name, vif1_c1w20.vif_name, (void *)vif1_c1w20.drv_state);
+    ow_ovsdb_ut_run();
+    assert(osw_state_vif_lookup(phy.phy_name, vif1_c1w20.vif_name) != NULL);
+    ow_ovsdb_get_rstate(&rstate, phy.phy_name);
+    assert(rstate.channel_exists == true);
+    assert(rstate.ht_mode_exists == true);
+    assert(rstate.channel == 1);
+    assert(strcmp(rstate.ht_mode, "HT20") == 0);
+
+    ow_ovsdb_vif_set_config(vconf2.if_name, &vconf2);
+    osw_drv_dummy_set_vif(&dummy, phy.phy_name, vif2_c1w20.vif_name, (void *)vif2_c1w20.drv_state);
+    ow_ovsdb_ut_run();
+    assert(osw_state_vif_lookup(phy.phy_name, vif2_c1w20.vif_name) != NULL);
+    ow_ovsdb_get_rstate(&rstate, phy.phy_name);
+    assert(rstate.channel_exists == true);
+    assert(rstate.ht_mode_exists == true);
+    assert(rstate.channel == 1);
+    assert(strcmp(rstate.ht_mode, "HT20") == 0);
+
+    osw_drv_dummy_set_vif(&dummy, phy.phy_name, vif2_c1w40.vif_name, (void *)vif2_c1w40.drv_state);
+    ow_ovsdb_ut_run();
+    assert(osw_state_vif_lookup(phy.phy_name, vif2_c1w40.vif_name) != NULL);
+    ow_ovsdb_get_rstate(&rstate, phy.phy_name);
+    assert(rstate.channel_exists == false);
+    assert(rstate.ht_mode_exists == false);
+
+    osw_drv_dummy_set_vif(&dummy, phy.phy_name, vif2_c6w20.vif_name, (void *)vif2_c6w20.drv_state);
+    ow_ovsdb_ut_run();
+    assert(osw_state_vif_lookup(phy.phy_name, vif2_c6w20.vif_name) != NULL);
+    ow_ovsdb_get_rstate(&rstate, phy.phy_name);
+    assert(rstate.channel_exists == false);
+    assert(rstate.ht_mode_exists == false);
+}
+
+static void
+ow_ovsdb_ut_freq_band_cb(void *arg)
+{
+    struct osw_drv_phy_state state = {0};
+    struct osw_channel_state cs_2g[] = {
+            { .channel = { .control_freq_mhz = 2412 } },
+    };
+    struct osw_channel_state cs_5gl[] = {
+            { .channel = { .control_freq_mhz = 5180 } },
+    };
+    struct osw_channel_state cs_5gu[] = {
+            { .channel = { .control_freq_mhz = 5745 } },
+    };
+    struct osw_channel_state cs_5g[] = {
+            { .channel = { .control_freq_mhz = 5180 } },
+            { .channel = { .control_freq_mhz = 5600 } },
+    };
+    struct osw_channel_state cs_6g2[] = {
+            { .channel = { .control_freq_mhz = 6935 } },
+    };
+    struct osw_channel_state cs_6g1[] = {
+            { .channel = { .control_freq_mhz = 6955 } },
+    };
+    struct osw_channel_state cs_2g5g[] = {
+            { .channel = { .control_freq_mhz = 2412 } },
+            { .channel = { .control_freq_mhz = 5180 } },
+            { .channel = { .control_freq_mhz = 5600 } },
+    };
+    struct osw_state_phy_info info = { .drv_state = &state };
+    const char *str;
+
+    state.channel_states = cs_2g;
+    state.n_channel_states = ARRAY_SIZE(cs_2g);
+    str = ow_ovsdb_phystate_get_freq_band(&info);
+    assert(str != NULL);
+    assert(strcmp(str, "2.4G") == 0);
+
+    state.channel_states = cs_5gl;
+    state.n_channel_states = ARRAY_SIZE(cs_5gl);
+    str = ow_ovsdb_phystate_get_freq_band(&info);
+    assert(str != NULL);
+    assert(strcmp(str, "5GL") == 0);
+
+    state.channel_states = cs_5gu;
+    state.n_channel_states = ARRAY_SIZE(cs_5gu);
+    str = ow_ovsdb_phystate_get_freq_band(&info);
+    assert(str != NULL);
+    assert(strcmp(str, "5GU") == 0);
+
+    state.channel_states = cs_5g;
+    state.n_channel_states = ARRAY_SIZE(cs_5g);
+    str = ow_ovsdb_phystate_get_freq_band(&info);
+    assert(str != NULL);
+    assert(strcmp(str, "5G") == 0);
+
+    state.channel_states = cs_6g1;
+    state.n_channel_states = ARRAY_SIZE(cs_6g1);
+    str = ow_ovsdb_phystate_get_freq_band(&info);
+    assert(str != NULL);
+    assert(strcmp(str, "6G") == 0);
+
+    state.channel_states = cs_6g2;
+    state.n_channel_states = ARRAY_SIZE(cs_6g2);
+    str = ow_ovsdb_phystate_get_freq_band(&info);
+    assert(str != NULL);
+    assert(strcmp(str, "6G") == 0);
+
+    state.channel_states = cs_2g5g;
+    state.n_channel_states = ARRAY_SIZE(cs_2g5g);
+    str = ow_ovsdb_phystate_get_freq_band(&info);
+    assert(str == NULL);
+
+    state.channel_states = NULL;
+    state.n_channel_states = 0;
+    str = ow_ovsdb_phystate_get_freq_band(&info);
+    assert(str == NULL);
+}
+
+static void
+ow_ovsdb_ut_phy_mem_cb(void *data)
+{
+    struct osw_drv_phy_state pstate = {0};
+    struct osw_state_phy_info pinfo = {
+        .phy_name = "phy1",
+        .drv_state = &pstate,
+    };
+    struct schema_Wifi_Radio_Config rconf = {0};
+
+    SCHEMA_SET_STR(rconf.if_name, pinfo.phy_name);
+
+    ow_ovsdb_ut_init();
+    ow_ovsdb_phy_set_info(pinfo.phy_name, &pinfo);
+    ow_ovsdb_ut_run();
+    assert(ds_tree_find(&g_ow_ovsdb.phy_tree, pinfo.phy_name) != NULL);
+
+    ow_ovsdb_phy_set_info(pinfo.phy_name, NULL);
+    ow_ovsdb_ut_run();
+    assert(ds_tree_find(&g_ow_ovsdb.phy_tree, pinfo.phy_name) == NULL);
+
+    ow_ovsdb_phy_set_config(pinfo.phy_name, &rconf);
+    ow_ovsdb_ut_run();
+    assert(ds_tree_find(&g_ow_ovsdb.phy_tree, pinfo.phy_name) != NULL);
+
+    ow_ovsdb_phy_set_info(pinfo.phy_name, &pinfo);
+    ow_ovsdb_ut_run();
+    assert(ds_tree_find(&g_ow_ovsdb.phy_tree, pinfo.phy_name) != NULL);
+
+    ow_ovsdb_phy_set_config(pinfo.phy_name, NULL);
+    ow_ovsdb_ut_run();
+    assert(ds_tree_find(&g_ow_ovsdb.phy_tree, pinfo.phy_name) != NULL);
+
+    ow_ovsdb_phy_set_config(pinfo.phy_name, &rconf);
+    ow_ovsdb_ut_run();
+    assert(ds_tree_find(&g_ow_ovsdb.phy_tree, pinfo.phy_name) != NULL);
+
+    ow_ovsdb_phy_set_info(pinfo.phy_name, NULL);
+    ow_ovsdb_ut_run();
+    assert(ds_tree_find(&g_ow_ovsdb.phy_tree, pinfo.phy_name) != NULL);
+
+    ow_ovsdb_phy_set_config(pinfo.phy_name, NULL);
+    ow_ovsdb_ut_run();
+    assert(ds_tree_find(&g_ow_ovsdb.phy_tree, pinfo.phy_name) == NULL);
+}
+
+static void
+ow_ovsdb_ut_sta_cb(void *data)
+{
+    struct osw_channel_state cs_2g[] = {
+            { .channel = { .control_freq_mhz = 2412 } },
+    };
+    const struct osw_state_phy_info phy = {
+        .phy_name = "phy1",
+        .drv_state = (const struct osw_drv_phy_state []){{
+            .exists = true,
+            .enabled = true,
+            .n_channel_states = ARRAY_SIZE(cs_2g),
+            .channel_states = cs_2g,
+        }},
+    };
+    const struct osw_state_vif_info vif1 = {
+        .phy = &phy,
+        .vif_name = "vif1",
+        .drv_state = (const struct osw_drv_vif_state []){{
+            .exists = true,
+            .enabled = true,
+            .vif_type = OSW_VIF_AP,
+            .u = { .ap = { .ssid = { .buf = "ssid1", .len = 5 } } },
+        }},
+    };
+    const struct osw_state_vif_info vif2 = {
+        .phy = &phy,
+        .vif_name = "vif2",
+        .drv_state = (const struct osw_drv_vif_state []){{
+            .exists = true,
+            .enabled = true,
+            .vif_type = OSW_VIF_AP,
+            .u = { .ap = { .ssid = { .buf = "ssid2", .len = 5 } } },
+        }},
+    };
+    const struct osw_hwaddr addr1 = { .octet = { 0, 1, 2, 3, 4, 5 } };
+    struct osw_drv_sta_state k1conn = {
+        .key_id = 1,
+        .connected = true,
+    };
+    struct osw_drv_sta_state k1disc = {
+        .key_id = 1,
+        .connected = false,
+    };
+    struct osw_drv_dummy dummy = {
+        .name = "ut_sta",
+    };
+    struct schema_Wifi_VIF_Config vconf1 = {0};
+    struct schema_Wifi_VIF_Config vconf2 = {0};
+
+    SCHEMA_SET_STR(vconf1.if_name, vif1.vif_name);
+    SCHEMA_KEY_VAL_APPEND(vconf1.wpa_oftags, "key-1", "hello");
+    SCHEMA_KEY_VAL_APPEND(vconf1.security, "oftag-key-2", "world");
+
+    SCHEMA_SET_STR(vconf2.if_name, vif2.vif_name);
+    SCHEMA_KEY_VAL_APPEND(vconf1.wpa_oftags, "key-1", "hello");
+    SCHEMA_KEY_VAL_APPEND(vconf1.security, "oftag-key-2", "world");
+
+    osw_init();
+    osw_drv_dummy_init(&dummy);
+
+    ow_ovsdb_ut_init();
+    osw_drv_dummy_set_phy(&dummy, phy.phy_name, (void *)phy.drv_state);
+    osw_drv_dummy_set_vif(&dummy, phy.phy_name, vif1.vif_name, (void *)vif1.drv_state);
+    osw_drv_dummy_set_vif(&dummy, phy.phy_name, vif2.vif_name, (void *)vif2.drv_state);
+    osw_drv_dummy_set_sta(&dummy, phy.phy_name, vif1.vif_name, &addr1, &k1conn);
+    ow_ovsdb_vif_set_config(vif1.vif_name, &vconf1);
+    ow_ovsdb_vif_set_config(vif2.vif_name, &vconf2);
+    ow_ovsdb_ut_run();
+
+    osw_drv_dummy_set_sta(&dummy, phy.phy_name, vif1.vif_name, &addr1, &k1disc);
+    ow_ovsdb_ut_run();
+
+    osw_drv_dummy_set_sta(&dummy, phy.phy_name, vif1.vif_name, &addr1, &k1conn);
+    ow_ovsdb_ut_run();
+
+    osw_drv_dummy_set_sta(&dummy, phy.phy_name, vif2.vif_name, &addr1, &k1conn);
+    ow_ovsdb_ut_run();
+
+    osw_drv_dummy_set_sta(&dummy, phy.phy_name, vif1.vif_name, &addr1, &k1disc);
+    ow_ovsdb_ut_run();
+
+    osw_drv_dummy_fini(&dummy);
+    ow_ovsdb_ut_run();
+}
+
+static void
+ow_ovsdb_ut_module_init(void *arg)
+{
+    osw_ut_register("ow_ovsdb_ut_rconf", ow_ovsdb_ut_rconf_cb, NULL);
+    osw_ut_register("ow_ovsdb_ut_vconf", ow_ovsdb_ut_vconf_cb, NULL);
+    osw_ut_register("ow_ovsdb_ut_rstate", ow_ovsdb_ut_rstate_cb, NULL);
+    osw_ut_register("ow_ovsdb_ut_rstate_bcn_int", ow_ovsdb_ut_rstate_bcn_int_cb, NULL);
+    osw_ut_register("ow_ovsdb_ut_rstate_channel", ow_ovsdb_ut_rstate_channel_cb, NULL);
+    osw_ut_register("ow_ovsdb_ut_vstate", ow_ovsdb_ut_vstate_cb, NULL);
+    osw_ut_register("ow_ovsdb_ut_freq_band", ow_ovsdb_ut_freq_band_cb, NULL);
+    osw_ut_register("ow_ovsdb_ut_phy_mem", ow_ovsdb_ut_phy_mem_cb, NULL);
+    osw_ut_register("ow_ovsdb_ut_sta", ow_ovsdb_ut_sta_cb, NULL);
+}
+
+static void
+ow_ovsdb_ut_module_fini(void *arg)
+{
+}
+
+MODULE(ow_ovsdb_ut_module,
+       ow_ovsdb_ut_module_init,
+       ow_ovsdb_ut_module_fini);
Index: device-core/src/lib/ow/src/ow_ovsdb.h
===================================================================
--- /dev/null
+++ device-core/src/lib/ow/src/ow_ovsdb.h
@@ -0,0 +1,4 @@
+#ifndef OW_OVSDB_H
+#define OW_OVSDB_H
+
+#endif /* OW_OVSDB_H */
Index: device-core/src/lib/ow/src/ow_ovsdb_ms.c
===================================================================
--- /dev/null
+++ device-core/src/lib/ow/src/ow_ovsdb_ms.c
@@ -0,0 +1,250 @@
+#include <const.h>
+#include <memutil.h>
+#include "ow_ovsdb_ms.h"
+#include <ovsdb_cache.h>
+#include <ev.h>
+
+/**
+ * OneWifi OVSDB Wifi_Master_State synchronization
+ *
+ * This takes care of keeping Wifi_Master_State synchronized
+ * as per inputs from OVSDB and ow_ovsdb core (eventually
+ * osw_state). It'll keep retrying as necessary and correct
+ * deviations, even when Wifi_Master_State is altered from
+ * the outside.
+ */
+
+#define OW_OVSDB_MS_RETRY_SECONDS 5.0
+
+struct ow_ovsdb_ms {
+    struct ds_tree_node node;
+    struct ow_ovsdb_ms_root *root;
+    char *vif_name;
+    bool vif_exists;
+    bool vif_active;
+    bool ovsdb_sync;
+    bool ovsdb_exists;
+    bool ovsdb_active;
+    ev_timer work;
+};
+
+static const char *
+ow_ovsdb_ms_bool_to_str(bool active)
+{
+    if (active) return "active";
+    else return "inactive";
+}
+
+static bool
+ow_ovsdb_ms_str_to_bool(const char *port_state)
+{
+    return strcmp(port_state, "active") == 0;
+}
+
+static bool
+ow_ovsdb_ms_is_vif(const char *if_type)
+{
+    return strcmp(if_type, "vif") == 0;
+}
+
+static void
+ow_ovsdb_ms_gc(struct ow_ovsdb_ms *ms)
+{
+    if (ms->vif_exists == true) return;
+    if (ms->ovsdb_exists == true) return;
+
+    LOGI("ow: ovsdb: ms: %s: freeing", ms->vif_name);
+
+    ev_timer_stop(EV_DEFAULT_ &ms->work);
+    ds_tree_remove(&ms->root->tree, ms);
+    FREE(ms->vif_name);
+    FREE(ms);
+}
+
+static bool
+ow_ovsdb_ms_sync(struct ow_ovsdb_ms *ms)
+{
+    ovsdb_table_t *table = &ms->root->table;
+
+    if (ms->ovsdb_sync == false) return true;
+    if (ms->vif_active == ms->ovsdb_active) return true;
+
+    LOGI("ow: ovsdb: ms: %s: setting from %s to %s",
+         ms->vif_name,
+         ow_ovsdb_ms_bool_to_str(ms->ovsdb_active),
+         ow_ovsdb_ms_bool_to_str(ms->vif_active));
+
+    struct schema_Wifi_Master_State state = {0};
+    state._partial_update = true;
+    SCHEMA_SET_STR(state.if_name, ms->vif_name);
+    SCHEMA_SET_STR(state.port_state, ow_ovsdb_ms_bool_to_str(ms->vif_active));
+    int cnt = ovsdb_table_update(table, &state);
+
+    if (cnt == 1)
+        return true;
+
+    if (ms->vif_exists == false) {
+        /* There won't be a reply, but that's fine. This
+         * gives the opportunity to update the state column
+         * on best-effort basis for dying breath case.
+         */
+        ms->vif_active = ms->ovsdb_active;
+        return true;
+    }
+
+    LOGI("ow: ovsdb: ms: %s: failed to update to %s, cnt = %d, will retry",
+         ms->vif_name, state.port_state, cnt);
+    return false;
+}
+
+static void
+ow_ovsdb_ms_work_cb(EV_P_ ev_timer *arg, int events)
+{
+    struct ow_ovsdb_ms *ms = container_of(arg, struct ow_ovsdb_ms, work);
+    LOGT("ow: ovsdb: ms: %s: working", ms->vif_name);
+    if (ow_ovsdb_ms_sync(ms) == false) return;
+    ev_timer_stop(EV_A_ &ms->work);
+    ow_ovsdb_ms_gc(ms);
+}
+
+static void
+ow_ovsdb_ms_work_sched(struct ow_ovsdb_ms *ms)
+{
+    LOGT("ow: ovsdb: ms: %s: scheduling work", ms->vif_name);
+    ev_timer_stop(EV_DEFAULT_ &ms->work);
+    ev_timer_set(&ms->work, 0, OW_OVSDB_MS_RETRY_SECONDS);
+    ev_timer_start(EV_DEFAULT_ &ms->work);
+}
+
+static struct ow_ovsdb_ms *
+ow_ovsdb_ms_get(struct ow_ovsdb_ms_root *root,
+                const char *vif_name)
+{
+    struct ow_ovsdb_ms *ms = ds_tree_find(&root->tree, vif_name);
+
+    if (ms == NULL) {
+        LOGT("ow: ovsdb: ms: %s: allocating", vif_name);
+        ms = CALLOC(1, sizeof(*ms));
+        ms->vif_name = STRDUP(vif_name);
+        ms->root = root;
+        ds_tree_insert(&root->tree, ms, ms->vif_name);
+        ev_timer_init(&ms->work, ow_ovsdb_ms_work_cb, 0, 0);
+    }
+
+    return ms;
+}
+
+static void
+ow_ovsdb_ms_set_row(struct ow_ovsdb_ms_root *root,
+                    const char *vif_name,
+                    const struct schema_Wifi_Master_State *row)
+{
+    struct ow_ovsdb_ms *ms = ow_ovsdb_ms_get(root, vif_name);
+
+    ms->ovsdb_exists = (row != NULL);
+
+    if (row) {
+        ms->ovsdb_active = ow_ovsdb_ms_str_to_bool(row->port_state);
+        ms->ovsdb_sync = ow_ovsdb_ms_is_vif(row->if_type);
+    }
+
+    ow_ovsdb_ms_work_sched(ms);
+
+    LOGD("ow: ovsdb: ms: %s: row: exists=%d active=%d sync=%d",
+         vif_name,
+         ms->ovsdb_exists,
+         ms->ovsdb_active,
+         ms->ovsdb_sync);
+}
+
+static void
+ow_ovsdb_ms_table_cb(ovsdb_update_monitor_t *mon,
+                     struct schema_Wifi_Master_State *old,
+                     struct schema_Wifi_Master_State *rec,
+                     ovsdb_cache_row_t *row)
+{
+    ovsdb_table_t *table = mon->mon_data;
+    struct ow_ovsdb_ms_root *root = container_of(table, struct ow_ovsdb_ms_root, table);
+    const struct schema_Wifi_Master_State *state = (void *)row->record;
+
+    switch (mon->mon_type) {
+        case OVSDB_UPDATE_NEW:
+        case OVSDB_UPDATE_MODIFY:
+            ow_ovsdb_ms_set_row(root, state->if_name, state);
+            break;
+        case OVSDB_UPDATE_DEL:
+            ow_ovsdb_ms_set_row(root, state->if_name, NULL);
+            break;
+        case OVSDB_UPDATE_ERROR:
+            break;
+    }
+}
+
+static void
+ow_ovsdb_ms_dump(struct ow_ovsdb_ms_root *root)
+{
+    struct ow_ovsdb_ms *ms;
+
+    LOGI("ow: ovsdb: ms: dumping");
+
+    ds_tree_foreach(&root->tree, ms) {
+        LOGI("ow: ovsdb: ms: %s: exists=%d/%d active=%d/%d sync=%d work=%d/%d",
+             ms->vif_name,
+             ms->vif_exists,
+             ms->ovsdb_exists,
+             ms->vif_active,
+             ms->ovsdb_active,
+             ms->ovsdb_sync,
+             ev_is_active(&ms->work),
+             ev_is_pending(&ms->work));
+    }
+}
+
+static void
+ow_ovsdb_ms_sigusr1_cb(EV_P_ ev_signal *arg, int events)
+{
+    struct ow_ovsdb_ms_root *root = container_of(arg, struct ow_ovsdb_ms_root, sigusr1);
+    ow_ovsdb_ms_dump(root);
+}
+
+void
+ow_ovsdb_ms_init(struct ow_ovsdb_ms_root *root)
+{
+    ev_signal_init(&root->sigusr1, ow_ovsdb_ms_sigusr1_cb, SIGUSR1);
+    ev_signal_start(EV_DEFAULT_ &root->sigusr1);
+    ev_unref(EV_DEFAULT);
+    ds_tree_init(&root->tree, ds_str_cmp, struct ow_ovsdb_ms, node);
+    OVSDB_TABLE_VAR_INIT(&root->table, Wifi_Master_State, if_name);
+    ovsdb_cache_monitor(&root->table, (void *)ow_ovsdb_ms_table_cb, true);
+}
+
+void
+ow_ovsdb_ms_set_vif(struct ow_ovsdb_ms_root *root,
+                    const struct osw_state_vif_info *vif)
+{
+    struct ow_ovsdb_ms *ms = ow_ovsdb_ms_get(root, vif->vif_name);
+
+    ms->vif_exists = vif->drv_state->exists;
+
+    switch (vif->drv_state->vif_type) {
+        case OSW_VIF_UNDEFINED:
+            break;
+        case OSW_VIF_AP:
+            ms->vif_active = vif->drv_state->enabled;
+            break;
+        case OSW_VIF_AP_VLAN:
+            break;
+        case OSW_VIF_STA:
+            break;
+    }
+
+    if (ms->vif_exists == false)
+        ms->vif_active = false;
+
+    ow_ovsdb_ms_work_sched(ms);
+
+    LOGD("ow: ovsdb: ms: %s: vif: exists=%d active=%d",
+         ms->vif_name,
+         ms->vif_exists,
+         ms->vif_active);
+}
Index: device-core/src/lib/ow/src/ow_ovsdb_ms.h
===================================================================
--- /dev/null
+++ device-core/src/lib/ow/src/ow_ovsdb_ms.h
@@ -0,0 +1,21 @@
+#ifndef OW_OVSDB_MS_H
+#define OW_OVSDB_MS_H
+
+#include <ovsdb_table.h>
+#include <ds_tree.h>
+#include <osw_state.h>
+
+struct ow_ovsdb_ms_root {
+    ovsdb_table_t table;
+    struct ds_tree tree;
+    ev_signal sigusr1;
+};
+
+void
+ow_ovsdb_ms_set_vif(struct ow_ovsdb_ms_root *root,
+                    const struct osw_state_vif_info *vif);
+
+void
+ow_ovsdb_ms_init(struct ow_ovsdb_ms_root *root);
+
+#endif /* OW_OVSDB_MS_H */
Index: device-core/src/lib/ow/src/ow_ovsdb_steer.c
===================================================================
--- /dev/null
+++ device-core/src/lib/ow/src/ow_ovsdb_steer.c
@@ -0,0 +1,76 @@
+#include <ovsdb_cache.h>
+#include <const.h>
+
+#include "ow_ovsdb_steer.h"
+#include "ow_steer.h"
+
+static void
+ow_ovsdb_steer_new_config(struct ow_ovsdb_steer *steering,
+                          const struct schema_Band_Steering_Config *row)
+{
+    if (row->ifnames_len > 0) {
+        /* TODO */
+    }
+}
+
+static void
+ow_ovsdb_steer_new_client(struct ow_ovsdb_steer *steering,
+                          const struct schema_Band_Steering_Clients *row)
+{
+    /* TODO */
+}
+
+static void
+ow_ovsdb_steer_config_table_cb(ovsdb_update_monitor_t *mon,
+                               struct schema_Band_Steering_Config *old,
+                               struct schema_Band_Steering_Config *rec,
+                               ovsdb_cache_row_t *row)
+{
+    ovsdb_table_t *table = mon->mon_data;
+    struct ow_ovsdb_steer *steering = container_of(table, struct ow_ovsdb_steer, config_table);
+    const struct schema_Band_Steering_Config *config = (void *)row->record;
+
+    switch (mon->mon_type) {
+        case OVSDB_UPDATE_NEW:
+            ow_ovsdb_steer_new_config(steering, config);
+            break;
+        case OVSDB_UPDATE_MODIFY:
+            break;
+        case OVSDB_UPDATE_DEL:
+            break;
+        case OVSDB_UPDATE_ERROR:
+            break;
+    }
+}
+
+static void
+ow_ovsdb_steer_clients_table_cb(ovsdb_update_monitor_t *mon,
+                                struct schema_Band_Steering_Clients *old,
+                                struct schema_Band_Steering_Clients *rec,
+                                ovsdb_cache_row_t *row)
+{
+    ovsdb_table_t *table = mon->mon_data;
+    struct ow_ovsdb_steer *steering = container_of(table, struct ow_ovsdb_steer, clients_table);
+    const struct schema_Band_Steering_Clients *client = (void *)row->record;
+
+    switch (mon->mon_type) {
+        case OVSDB_UPDATE_NEW:
+            ow_ovsdb_steer_new_client(steering, client);
+            break;
+        case OVSDB_UPDATE_MODIFY:
+            break;
+        case OVSDB_UPDATE_DEL:
+            break;
+        case OVSDB_UPDATE_ERROR:
+            break;
+    }
+}
+
+void
+ow_ovsdb_steer_init(struct ow_ovsdb_steer *steering)
+{
+    OVSDB_TABLE_VAR_INIT_NO_KEY(&steering->config_table, Band_Steering_Config);
+    ovsdb_cache_monitor(&steering->config_table, (void *)ow_ovsdb_steer_config_table_cb, true);
+    OVSDB_TABLE_VAR_INIT(&steering->clients_table, Band_Steering_Clients, mac);
+    ovsdb_cache_monitor(&steering->clients_table, (void *)ow_ovsdb_steer_clients_table_cb, true);
+}
Index: device-core/src/lib/ow/src/ow_ovsdb_steer.h
===================================================================
--- /dev/null
+++ device-core/src/lib/ow/src/ow_ovsdb_steer.h
@@ -0,0 +1,17 @@
+#ifndef OW_OVSDB_STEER_H
+#define OW_OVSDB_STEER_H
+
+#include <ovsdb_table.h>
+#include <ds_tree.h>
+#include <osw_state.h>
+
+struct ow_ovsdb_steer {
+    ovsdb_table_t config_table;
+    ovsdb_table_t clients_table;
+    ovsdb_table_t neighbors_table;
+};
+
+void
+ow_ovsdb_steer_init(struct ow_ovsdb_steer *steering);
+
+#endif /* OW_OVSDB_STEER_H */
Index: device-core/src/lib/ow/src/ow_sigalrm.c
===================================================================
--- /dev/null
+++ device-core/src/lib/ow/src/ow_sigalrm.c
@@ -0,0 +1,52 @@
+/* libc */
+#include <unistd.h>
+#include <stdio.h>
+
+/* 3rd party */
+#include <ev.h>
+
+/* opensync */
+#include <module.h>
+
+#define OW_SIGALRM_WDOG_SECONDS 30.0
+#define OW_SIGALRM_WDOG_COUNT 3
+
+static ev_async g_ow_sigalrm_async;
+static int g_ow_sigalrm_cnt;
+
+static void
+ow_sigalrm_sig_cb(int signum)
+{
+    if (signum != SIGALRM) return;
+
+    assert(++g_ow_sigalrm_cnt < OW_SIGALRM_WDOG_COUNT);
+    ev_async_send(EV_DEFAULT_ &g_ow_sigalrm_async);
+    alarm(OW_SIGALRM_WDOG_SECONDS);
+}
+
+static void
+ow_sigalrm_async_cb(EV_P_ ev_async *arg, int events)
+{
+    alarm(0);
+    g_ow_sigalrm_cnt = 0;
+    alarm(OW_SIGALRM_WDOG_SECONDS);
+}
+
+static void
+ow_sigalrm_module_init_cb(void *arg)
+{
+    ev_async_init(&g_ow_sigalrm_async, ow_sigalrm_async_cb);
+    ev_async_start(EV_DEFAULT_ &g_ow_sigalrm_async);
+    ev_unref(EV_DEFAULT);
+    signal(SIGALRM, ow_sigalrm_sig_cb);
+    alarm(OW_SIGALRM_WDOG_SECONDS);
+}
+
+static void
+ow_sigalrm_module_fini_cb(void *arg)
+{
+}
+
+MODULE(ow_sigalrm_module,
+       ow_sigalrm_module_init_cb,
+       ow_sigalrm_module_fini_cb);
Index: device-core/src/lib/ow/src/ow_steer.c
===================================================================
--- /dev/null
+++ device-core/src/lib/ow/src/ow_steer.c
@@ -0,0 +1,21 @@
+#include <memutil.h>
+#include <ds_dlist.h>
+#include <ds_tree.h>
+#include <osw_ut.h>
+#include <module.h>
+
+#include "ow_steer.h"
+
+static void
+ow_steer_ut_module_init(void *data)
+{
+
+}
+
+static void
+ow_steer_ut_module_fini(void *data)
+{
+    /* nop */
+}
+
+MODULE(ow_steer_ut_module, ow_steer_ut_module_init, ow_steer_ut_module_fini);
Index: device-core/src/lib/ow/src/ow_steer.h
===================================================================
--- /dev/null
+++ device-core/src/lib/ow/src/ow_steer.h
@@ -0,0 +1,6 @@
+#ifndef OSW_STEER_H
+#define OSW_STEER_H
+
+
+
+#endif /* OSW_STEER_H */
Index: device-core/src/lib/ow/src/ow_steer_ue.c
===================================================================
--- /dev/null
+++ device-core/src/lib/ow/src/ow_steer_ue.c
@@ -0,0 +1,212 @@
+#include <time.h>
+#include <ev.h>
+#include <memutil.h>
+#include <const.h>
+#include <osw_types.h>
+#include <osw_state.h>
+#include <log.h>
+#include <ds_tree.h>
+#include <ds_dlist.h>
+#include <os_time.h>
+#include "ow_steer_ue.h"
+
+struct ow_steer_ue {
+    struct osw_hwaddr mac_addr;
+    struct ds_tree sta_tree;
+    ev_timer gc_timer;
+
+    struct ds_tree_node node;
+};
+
+struct ow_steer_sta {
+    char *vif_name;
+
+    bool connected;
+    void *assoc_req_ies;
+    size_t assoc_req_ies_len;
+
+    time_t last_connect_tstamp;
+    time_t last_probe_req_tstamp;
+
+    struct ds_tree_node node;
+};
+
+#define UE_GC_PERIOD_SEC 60.
+#define UE_GC_EXPIRATION_SEC 60.
+
+static struct ds_dlist g_observer_list = DS_DLIST_INIT(struct ow_steer_ue_observer, node);
+static struct ds_tree g_ue_tree = DS_TREE_INIT((ds_key_cmp_t*) osw_hwaddr_cmp, struct ow_steer_ue, node);
+
+static void
+ow_steer_sta_free(struct ow_steer_sta *sta)
+{
+    FREE(sta->vif_name);
+    FREE(sta->assoc_req_ies);
+    FREE(sta);
+}
+
+static void
+ow_steer_ue_free(struct ow_steer_ue *ue)
+{
+    struct ow_steer_sta *sta;
+    struct ow_steer_sta *tmp;
+
+    ds_tree_foreach_safe(&ue->sta_tree, sta, tmp) {
+        ds_tree_remove(&ue->sta_tree, sta);
+        ow_steer_sta_free(sta);
+    }
+
+    ev_timer_stop(EV_DEFAULT_ &ue->gc_timer);
+    FREE(ue);
+}
+
+static bool
+ow_steer_ue_is_alive(struct ow_steer_ue *ue)
+{
+    struct ow_steer_sta *sta;
+    const time_t now = time_monotonic();
+
+    ds_tree_foreach(&ue->sta_tree, sta) {
+        if (sta->connected == true) {
+            return true;
+        }
+
+        if (sta->last_connect_tstamp > 0 &&
+            difftime(now, sta->last_connect_tstamp) <= UE_GC_EXPIRATION_SEC)
+        {
+           return true;
+        }
+
+        if (sta->last_probe_req_tstamp > 0 &&
+            difftime(now, sta->last_probe_req_tstamp) <= UE_GC_EXPIRATION_SEC)
+        {
+           return true;
+        }
+    }
+
+    return false;
+}
+
+static void
+ow_steer_ue_gc_cb(EV_P_ ev_timer *arg,
+                  int events)
+{
+    struct ow_steer_ue *ue = container_of(arg, struct ow_steer_ue, gc_timer);
+
+    if (ow_steer_ue_is_alive(ue) == true)
+        return;
+
+    LOGD("ow: steer: ue: "OSW_HWADDR_FMT": gc absent", OSW_HWADDR_ARG(&ue->mac_addr));
+    ow_steer_ue_free(ue);
+}
+
+static struct ow_steer_ue*
+ow_steer_ue_get(const struct osw_hwaddr *mac_addr)
+{
+    struct ow_steer_ue *ue = ds_tree_find(&g_ue_tree, mac_addr);
+    if (ue != NULL)
+        return ue;
+
+    ue = CALLOC(1, sizeof(*ue));
+    memcpy(&ue->mac_addr, mac_addr, sizeof(*mac_addr));
+    ds_tree_init(&ue->sta_tree, ds_str_cmp, struct ow_steer_sta, node);
+    ev_timer_init(&ue->gc_timer, ow_steer_ue_gc_cb, UE_GC_PERIOD_SEC, UE_GC_PERIOD_SEC);
+    ev_timer_start(EV_DEFAULT_ &ue->gc_timer);
+
+    ds_tree_insert(&g_ue_tree, ue, mac_addr);
+
+    return ue;
+}
+
+static struct ow_steer_sta*
+ow_steer_ue_get_sta(struct ow_steer_ue* ue,
+                    const char *vif_name)
+{
+    struct ow_steer_sta *sta = ds_tree_find(&ue->sta_tree, vif_name);
+    if (sta != NULL)
+        return sta;
+
+    sta = CALLOC(1, sizeof(*sta));
+    sta->vif_name = STRDUP(vif_name);
+    ds_tree_insert(&ue->sta_tree, sta, vif_name);
+
+    return sta;
+}
+
+static void
+ow_steer_ue_state_sta_connected_cb(struct osw_state_observer *self,
+                                   const struct osw_state_sta_info *sta_info)
+{
+    struct ow_steer_ue* ue = ow_steer_ue_get(sta_info->mac_addr);
+    struct ow_steer_sta* sta = ow_steer_ue_get_sta(ue, sta_info->vif->vif_name);
+
+    if(sta->connected == true) {
+        /* TODO log msg? */
+    }
+
+    sta->connected = true;
+    sta->last_connect_tstamp = sta_info->connected_at;
+    FREE(sta->assoc_req_ies);
+    sta->assoc_req_ies = MEMNDUP(sta_info->assoc_req_ies, sta_info->assoc_req_ies_len);
+    sta->assoc_req_ies_len = sta_info->assoc_req_ies_len;
+
+    /* TODO iterate observers */
+}
+
+static void
+ow_steer_ue_state_sta_disconnected_cb(struct osw_state_observer *self,
+                                      const struct osw_state_sta_info *sta_info)
+{
+    /* TODO */
+}
+
+static void
+ow_steer_ue_state_sta_probe_req_cb(struct osw_state_observer *self,
+                                   const struct osw_state_sta_info *sta_info,
+                                   const struct osw_state_sta_probe_req_arg *arg)
+{
+    /* TODO */
+}
+
+static void
+ow_steer_ue_state_sta_auth_fail_cb(struct osw_state_observer *self,
+                                   const struct osw_state_sta_info *sta_info,
+                                   const struct osw_state_sta_auth_fail_arg *arg)
+{
+    /* TODO */
+}
+
+static void
+ow_steer_ue_state_sta_action_frame_cb(struct osw_state_observer *self,
+                                      const struct osw_state_sta_info *sta_info,
+                                      const struct osw_state_sta_action_frame_arg *arg)
+{
+    /* TODO */
+}
+
+void
+ow_steer_ue_init(void)
+{
+    static struct osw_state_observer state_sta_obsrv = {
+        .name = "ow_steer",
+        .sta_connected_fn = ow_steer_ue_state_sta_connected_cb,
+        .sta_disconnected_fn = ow_steer_ue_state_sta_disconnected_cb,
+        .sta_probe_req_fn = ow_steer_ue_state_sta_probe_req_cb,
+        .sta_auth_fail_fn = ow_steer_ue_state_sta_auth_fail_cb,
+        .sta_action_frame_fn = ow_steer_ue_state_sta_action_frame_cb,
+    };
+
+    osw_state_register_observer(&state_sta_obsrv);
+}
+
+void
+ow_steer_ue_register_observer(struct ow_steer_ue_observer *observer)
+{
+    ds_dlist_insert_tail(&g_observer_list, observer);
+}
+
+void
+ow_steer_ue_unregister_observer(struct ow_steer_ue_observer *observer)
+{
+    ds_dlist_remove(&g_observer_list, observer);
+}
Index: device-core/src/lib/ow/src/ow_steer_ue.h
===================================================================
--- /dev/null
+++ device-core/src/lib/ow/src/ow_steer_ue.h
@@ -0,0 +1,56 @@
+#ifndef OSW_STEER_UE_H
+#define OSW_STEER_UE_H
+
+struct ow_steer_ue_observer;
+
+struct osw_steer_ue_probe_req_arg {
+    unsigned int snr;
+};
+
+typedef void
+osw_steer_ue_connected_fn_t(struct ow_steer_ue_observer *self,
+                            const struct osw_hwaddr *ue_mac_addr,
+                            const char *vif_name);
+
+typedef void
+osw_steer_ue_disconnected_fn_t(struct ow_steer_ue_observer *self,
+                               const struct osw_hwaddr *ue_mac_addr,
+                               const char *vif_name);
+
+typedef void
+osw_steer_ue_probe_req_fn_t(struct ow_steer_ue_observer *self,
+                            const struct osw_hwaddr *ue_mac_addr,
+                            const char *vif_name,
+                            const struct osw_steer_ue_probe_req_arg *arg);
+
+typedef void
+osw_steer_ue_auth_fail_fn_t(struct ow_steer_ue_observer *self,
+                            const struct osw_hwaddr *ue_mac_addr,
+                            const char *vif_name);
+
+typedef void
+osw_steer_ue_action_frame_fn_t(struct ow_steer_ue_observer *self,
+                               const struct osw_hwaddr *ue_mac_addr,
+                               const char *vif_name);
+
+struct ow_steer_ue_observer {
+    const char *name;
+    osw_steer_ue_connected_fn_t const *connected_fn;
+    osw_steer_ue_disconnected_fn_t const *disconnected_fn;
+    osw_steer_ue_probe_req_fn_t const *probe_req_fn;
+    osw_steer_ue_auth_fail_fn_t const *auth_fail;
+    osw_steer_ue_action_frame_fn_t const *action_frame_fn;
+
+    struct ds_dlist_node node;
+};
+
+void
+ow_steer_ue_init(void);
+
+void
+ow_steer_ue_register_observer(struct ow_steer_ue_observer *observer);
+
+void
+ow_steer_ue_unregister_observer(struct ow_steer_ue_observer *observer);
+
+#endif /* OSW_STEER_UE_H */
Index: device-core/src/lib/ow/src/ow_webconfig.c
===================================================================
--- /dev/null
+++ device-core/src/lib/ow/src/ow_webconfig.c
@@ -0,0 +1,326 @@
+/* libc */
+#include <stdlib.h>
+#include <stddef.h>
+
+/* 3rd party */
+#include <ccsp/wifi_hal.h>
+
+/* opensync */
+#include <module.h>
+#include <const.h>
+#include <util.h>
+#include <log.h>
+
+/* osw */
+#include <osw_types.h>
+#include <osw_state.h>
+#include "ow_conf.h"
+
+/* Walkaround for this definition in hal:
+ *
+ *   #ifndef BOOL
+ *   #define BOOL  unsigned char
+ *   #endif
+ *
+ *   decode/encode library validates this field
+ */
+#define TO_BOOL(x) (x != 0 ? true : false)
+
+static enum
+osw_channel_width ow_webconfig_bandwidth2osw(wifi_channelBandwidth_t bandwidth)
+{
+    switch (bandwidth) {
+        case WIFI_CHANNELBANDWIDTH_80_80MHZ: return OSW_CHANNEL_80P80MHZ;
+        case WIFI_CHANNELBANDWIDTH_160MHZ:   return OSW_CHANNEL_160MHZ;
+        case WIFI_CHANNELBANDWIDTH_80MHZ:    return OSW_CHANNEL_80MHZ;
+        case WIFI_CHANNELBANDWIDTH_40MHZ:    return OSW_CHANNEL_40MHZ;
+        case WIFI_CHANNELBANDWIDTH_20MHZ:    return OSW_CHANNEL_20MHZ;
+    }
+    LOGW("%s: unknown bandwidth: %d", __func__, bandwidth);
+    return OSW_CHANNEL_20MHZ;
+}
+
+static int
+ow_webconfig_ch2freq(wifi_freq_bands_t band, unsigned int chan)
+{
+    switch (band) {
+        case WIFI_FREQUENCY_2_4_BAND:
+            return 2407 + (chan * 5);
+        case WIFI_FREQUENCY_5_BAND:
+        case WIFI_FREQUENCY_5L_BAND:
+        case WIFI_FREQUENCY_5H_BAND:
+            return 5000 + (chan * 5);
+        case WIFI_FREQUENCY_6_BAND:
+            if (chan == 2) return 5935;
+            else return 5950 + (chan * 5);
+        case WIFI_FREQUENCY_60_BAND:
+            return 0;
+    }
+    LOGW("%s: unknown band: %d", __func__, band);
+    return 0;
+}
+
+static enum osw_pmf
+ow_webconfig_mfp2pmf(wifi_mfp_cfg_t mfp)
+{
+    switch (mfp) {
+        case wifi_mfp_cfg_disabled:
+            return OSW_PMF_DISABLED;
+        case wifi_mfp_cfg_optional:
+            return OSW_PMF_OPTIONAL;
+        case wifi_mfp_cfg_required:
+            return OSW_PMF_REQUIRED;
+    }
+    LOGW("%s: unknown mfp: %d", __func__, mfp);
+    return OSW_PMF_OPTIONAL;
+}
+
+static enum osw_acl_policy
+ow_webconfig_macmode2aclpolicy(wifi_mac_filter_mode_t mac_filter_mode)
+{
+    switch (mac_filter_mode) {
+        case wifi_mac_filter_mode_white_list:
+            return OSW_ACL_ALLOW_LIST;
+        case wifi_mac_filter_mode_black_list:
+            return OSW_ACL_DENY_LIST;
+    }
+    return OSW_ACL_NONE;
+}
+
+static void
+ow_webconfig_fill_security(const wifi_vap_info_t *vap,
+                           struct osw_wpa *wpa)
+{
+    const wifi_front_haul_bss_t *bss = &vap->u.bss_info;
+    const wifi_vap_security_t *sec = &bss->security;
+    bool is_key = false;
+
+    switch (sec->mode) {
+        case wifi_security_mode_none:
+            return;
+        case wifi_security_mode_wep_64:
+            LOGW("%s: wep 64 not supported", vap->vap_name);
+            return;
+        case wifi_security_mode_wep_128:
+            LOGW("%s: wep 128 not supported", vap->vap_name);
+            return;
+        case wifi_security_mode_wpa_personal:
+            wpa->wpa = true;
+            wpa->akm_psk = true;
+            is_key = true;
+            break;
+        case wifi_security_mode_wpa2_personal:
+            wpa->rsn = true;
+            wpa->akm_psk = true;
+            is_key = true;
+            break;
+        case wifi_security_mode_wpa_wpa2_personal:
+            wpa->wpa = true;
+            wpa->rsn = true;
+            wpa->akm_psk = true;
+            is_key = true;
+            break;
+        case wifi_security_mode_wpa_enterprise:
+            LOGI("%s: wpa enterprise not supported", vap->vap_name);
+            break;
+        case wifi_security_mode_wpa2_enterprise:
+            LOGI("%s: wpa2 enterprise not supported", vap->vap_name);
+            break;
+        case wifi_security_mode_wpa_wpa2_enterprise:
+            LOGI("%s: wpa1+2 enterprise not supported", vap->vap_name);
+            break;
+        case wifi_security_mode_wpa3_personal:
+            wpa->rsn = true;
+            wpa->akm_sae = true;
+            is_key = true;
+            break;
+        case wifi_security_mode_wpa3_transition:
+            wpa->rsn = true;
+            wpa->akm_psk = true;
+            wpa->akm_sae = true;
+            is_key = true;
+            break;
+        case wifi_security_mode_wpa3_enterprise:
+            LOGI("%s: wpa3 enterprise not supported", vap->vap_name);
+            break;
+    }
+
+    switch (sec->encr) {
+        case wifi_encryption_none:
+            break;
+        case wifi_encryption_tkip:
+            wpa->pairwise_tkip = true;
+            break;
+        case wifi_encryption_aes:
+            wpa->pairwise_ccmp = true;
+            break;
+        case wifi_encryption_aes_tkip:
+            wpa->pairwise_tkip = true;
+            wpa->pairwise_ccmp = true;
+            break;
+    }
+
+    wpa->pmf = ow_webconfig_mfp2pmf(sec->mfp);
+
+    /* FIXME: Is this expected? This isn't documented. */
+    if (sec->wpa3_transition_disable &&
+        wpa->akm_sae == true &&
+        wpa->akm_psk == true) {
+        wpa->akm_psk = false;
+        LOGI("%s: overriding: disabling wpa3 transition", vap->vap_name);
+    }
+
+    wpa->group_rekey_seconds = sec->rekey_interval;
+
+    if (is_key == true) {
+        size_t max = sizeof(sec->u.key.key);
+
+        switch (sec->u.key.type) {
+            case wifi_security_key_type_psk:
+            case wifi_security_key_type_pass:
+            case wifi_security_key_type_sae:
+            case wifi_security_key_type_psk_sae:
+                /* FIXME: What's the difference between PSK
+                 * and PASS? PSK and SAE? Is one of these an
+                 * actual PMK instead? Assume everything as
+                 * ASCII for now. */
+
+                /* FIXME: Call to ow_conf* function here is basically
+                 * against the use of this helper. It shall only fill
+                 * the structure and setting shall be handled outside.
+                 */
+                if (WARN_ON(strnlen(sec->u.key.key, max) >= max) == false)
+                    ow_conf_vif_set_ap_psk(vap->vap_name, -1, bss->security.u.key.key);
+                break;
+        }
+    }
+
+    /* FIXME: ft_mobility_domain and akm_ft_* aren't
+     * implemented in Wifi HAL at this time.
+     */
+}
+
+static void
+ow_webconfig_set_vif_ap(const char *phy_name,
+                        const char *vif_name,
+                        const wifi_vap_info_t *vap)
+{
+    const wifi_front_haul_bss_t *bss = &vap->u.bss_info;
+
+    /* FIXME handle ow_conf_vif_unset */
+    ow_conf_vif_set_phy_name(vif_name, phy_name);
+
+    const enum osw_vif_type vif_type = OSW_VIF_AP;
+    ow_conf_vif_set_type(vif_name, &vif_type);
+    const bool enabled = TO_BOOL(bss->enabled);
+    ow_conf_vif_set_enabled(vif_name, &enabled);
+
+    struct osw_ssid ssid = {0};
+    STRSCPY_WARN(ssid.buf, bss->ssid);
+    ssid.len = strlen(ssid.buf);
+    ow_conf_vif_set_ap_ssid(vif_name, &ssid);
+
+    const bool hidden = !TO_BOOL(bss->showSsid);
+    ow_conf_vif_set_ap_ssid_hidden(vif_name, &hidden);
+
+    struct osw_ifname name = {0};
+    STRSCPY_WARN(name.buf, vap->bridge_name);
+    ow_conf_vif_set_ap_bridge_if_name(vif_name, &name);
+
+    const bool isolated = TO_BOOL(bss->isolation);
+    ow_conf_vif_set_ap_isolated(vif_name, &isolated);
+
+    struct osw_wpa wpa = {0};
+    ow_webconfig_fill_security(vap, &wpa);
+    ow_conf_vif_set_ap_wpa(vif_name, &wpa.wpa);
+    ow_conf_vif_set_ap_rsn(vif_name, &wpa.rsn);
+    ow_conf_vif_set_ap_pairwise_tkip(vif_name, &wpa.pairwise_tkip);
+    ow_conf_vif_set_ap_pairwise_ccmp(vif_name, &wpa.pairwise_ccmp);
+    ow_conf_vif_set_ap_akm_psk(vif_name, &wpa.akm_psk);
+    ow_conf_vif_set_ap_akm_sae(vif_name, &wpa.akm_sae);
+    ow_conf_vif_set_ap_pmf(vif_name, &wpa.pmf);
+    ow_conf_vif_set_ap_group_rekey_seconds(vif_name, &wpa.group_rekey_seconds);
+
+    const enum osw_acl_policy policy = ow_webconfig_macmode2aclpolicy(bss->mac_filter_mode);
+    ow_conf_vif_set_ap_acl_policy(vif_name, &policy);
+
+    /* FIXME WPS pin method not supported */
+    //const bool wps_enabled = TO_BOOL(bss->wps.enable);
+    //ow_conf_vif_set_ap_wps(vif_name, &wps_enabled);
+
+    const bool wmm_enabled = TO_BOOL(bss->wmm_enabled);
+    ow_conf_vif_set_ap_wmm(vif_name, &wmm_enabled);
+
+    const bool wmm_uapsd_enabled = TO_BOOL(bss->UAPSDEnabled);
+    ow_conf_vif_set_ap_wmm_uapsd(vif_name, &wmm_uapsd_enabled);
+}
+
+void
+ow_webconfig_set_phy(const char *phy_name,
+                     const wifi_radio_operationParam_t *oper)
+{
+    const bool enabled = TO_BOOL(oper->enable);
+    ow_conf_phy_set_enabled(phy_name, &enabled);
+
+    const struct osw_channel channel = {
+        .control_freq_mhz = ow_webconfig_ch2freq(oper->band, oper->channel),
+        .width = ow_webconfig_bandwidth2osw(oper->channelWidth)
+    };
+    ow_conf_phy_set_ap_channel(phy_name, &channel);
+    const int tu = oper->beaconInterval;
+    ow_conf_phy_set_ap_beacon_interval_tu(phy_name, &tu);
+
+    const bool ht = (oper->variant & WIFI_80211_VARIANT_N) ? true : false;
+    const bool vht = (oper->variant & WIFI_80211_VARIANT_AC) ? true : false;
+    const bool he = (oper->variant & WIFI_80211_VARIANT_AX) ? true : false;
+    ow_conf_phy_set_ap_ht_enabled(phy_name, &ht);
+    ow_conf_phy_set_ap_vht_enabled(phy_name, &vht);
+    ow_conf_phy_set_ap_he_enabled(phy_name, &he);
+}
+
+void
+ow_webconfig_set_vif(const char *phy_name,
+                     const char *vif_name,
+                     const wifi_vap_info_t *vap)
+{
+    assert(phy_name != NULL);
+    assert(vif_name != NULL);
+    assert(vap != NULL);
+
+    switch (vap->vap_mode) {
+        case wifi_vap_mode_ap:
+            ow_webconfig_set_vif_ap(phy_name, vif_name, vap);
+            return;
+        case wifi_vap_mode_sta:
+            /* FIXME add support for STA */
+            LOGW("%s: STA mode not supported yet", __func__);
+            return;
+        case wifi_vap_mode_monitor:
+            LOGW("%s: Monitor mode not supported", __func__);
+            return;
+    }
+}
+
+void
+ow_webconfig_get_phy(const char *phy_name,
+                     wifi_radio_operationParam_t *oper,
+                     wifi_vap_info_map_t *map)
+{
+    /* FIXME: This should rely on osw_state to report actual
+     * system state.
+     */
+}
+
+static void
+ow_webconfig_module_init_cb(void *arg)
+{
+}
+
+static void
+ow_webconfig_module_fini_cb(void *arg)
+{
+}
+
+MODULE(ow_webconfig_module,
+       ow_webconfig_module_init_cb,
+       ow_webconfig_module_fini_cb);
Index: device-core/src/lib/ow/unit.mk
===================================================================
--- /dev/null
+++ device-core/src/lib/ow/unit.mk
@@ -0,0 +1,33 @@
+###############################################################################
+#
+# OneWiFi Library
+#
+###############################################################################
+UNIT_DISABLE := $(if $(CONFIG_OW),n,y)
+
+UNIT_NAME := ow
+UNIT_TYPE := SHLIB
+UNIT_DIR := lib
+
+UNIT_SRC += src/ow_core.c
+UNIT_SRC += src/ow_core_thread.c
+UNIT_SRC += src/ow_conf.c
+UNIT_SRC += src/ow_conf_barrier.c
+UNIT_SRC += src/ow_bus.c
+UNIT_SRC += $(if $(wildcard $(PKG_CONFIG_SYSROOT_DIR)/usr/include/ccsp)$(wildcard $(UNIT_PATH)/inc/ccsp),src/ow_webconfig.c,)
+UNIT_SRC += src/ow_ovsdb.c
+UNIT_SRC += src/ow_ovsdb_ms.c
+UNIT_SRC += src/ow_sigalrm.c
+UNIT_SRC += src/ow_ovsdb_steer.c
+UNIT_SRC += src/ow_steer.c
+UNIT_SRC += src/ow_steer_ue.c
+UNIT_SRC += src/ow_acl_kick.c
+
+UNIT_EXPORT_CFLAGS += -I$(UNIT_PATH)/inc
+UNIT_CFLAGS += -I$(UNIT_PATH)/inc
+UNIT_DEPS += src/lib/osw
+
+# ow_drv_target (to be removed eventually):
+UNIT_DEPS += src/lib/target
+UNIT_DEPS += src/lib/schema
+UNIT_DEPS += src/lib/ovsdb
